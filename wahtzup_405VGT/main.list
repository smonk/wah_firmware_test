
main.out:     file format elf32-littlearm


Disassembly of section .text:

08000190 <deregister_tm_clones>:
 8000190:	b508      	push	{r3, lr}
 8000192:	f240 4030 	movw	r0, #1072	; 0x430
 8000196:	4b07      	ldr	r3, [pc, #28]	; (80001b4 <deregister_tm_clones+0x24>)
 8000198:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800019c:	1a1b      	subs	r3, r3, r0
 800019e:	2b06      	cmp	r3, #6
 80001a0:	d800      	bhi.n	80001a4 <deregister_tm_clones+0x14>
 80001a2:	bd08      	pop	{r3, pc}
 80001a4:	f240 0300 	movw	r3, #0
 80001a8:	f2c0 0300 	movt	r3, #0
 80001ac:	2b00      	cmp	r3, #0
 80001ae:	d0f8      	beq.n	80001a2 <deregister_tm_clones+0x12>
 80001b0:	4798      	blx	r3
 80001b2:	e7f6      	b.n	80001a2 <deregister_tm_clones+0x12>
 80001b4:	20000433 	.word	0x20000433

080001b8 <register_tm_clones>:
 80001b8:	b508      	push	{r3, lr}
 80001ba:	f240 4030 	movw	r0, #1072	; 0x430
 80001be:	f240 4330 	movw	r3, #1072	; 0x430
 80001c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80001c6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80001ca:	1a1b      	subs	r3, r3, r0
 80001cc:	109b      	asrs	r3, r3, #2
 80001ce:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 80001d2:	1059      	asrs	r1, r3, #1
 80001d4:	d100      	bne.n	80001d8 <register_tm_clones+0x20>
 80001d6:	bd08      	pop	{r3, pc}
 80001d8:	f240 0200 	movw	r2, #0
 80001dc:	f2c0 0200 	movt	r2, #0
 80001e0:	2a00      	cmp	r2, #0
 80001e2:	d0f8      	beq.n	80001d6 <register_tm_clones+0x1e>
 80001e4:	4790      	blx	r2
 80001e6:	e7f6      	b.n	80001d6 <register_tm_clones+0x1e>

080001e8 <__do_global_dtors_aux>:
 80001e8:	b510      	push	{r4, lr}
 80001ea:	f240 4430 	movw	r4, #1072	; 0x430
 80001ee:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80001f2:	7823      	ldrb	r3, [r4, #0]
 80001f4:	b973      	cbnz	r3, 8000214 <__do_global_dtors_aux+0x2c>
 80001f6:	f7ff ffcb 	bl	8000190 <deregister_tm_clones>
 80001fa:	f240 0300 	movw	r3, #0
 80001fe:	f2c0 0300 	movt	r3, #0
 8000202:	b12b      	cbz	r3, 8000210 <__do_global_dtors_aux+0x28>
 8000204:	f64b 10e0 	movw	r0, #47584	; 0xb9e0
 8000208:	f6c0 0000 	movt	r0, #2048	; 0x800
 800020c:	f3af 8000 	nop.w
 8000210:	2301      	movs	r3, #1
 8000212:	7023      	strb	r3, [r4, #0]
 8000214:	bd10      	pop	{r4, pc}
 8000216:	bf00      	nop

08000218 <frame_dummy>:
 8000218:	b508      	push	{r3, lr}
 800021a:	f240 0300 	movw	r3, #0
 800021e:	f2c0 0300 	movt	r3, #0
 8000222:	b14b      	cbz	r3, 8000238 <frame_dummy+0x20>
 8000224:	f64b 10e0 	movw	r0, #47584	; 0xb9e0
 8000228:	f240 4134 	movw	r1, #1076	; 0x434
 800022c:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000230:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000234:	f3af 8000 	nop.w
 8000238:	f240 4030 	movw	r0, #1072	; 0x430
 800023c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000240:	6803      	ldr	r3, [r0, #0]
 8000242:	b12b      	cbz	r3, 8000250 <frame_dummy+0x38>
 8000244:	f240 0300 	movw	r3, #0
 8000248:	f2c0 0300 	movt	r3, #0
 800024c:	b103      	cbz	r3, 8000250 <frame_dummy+0x38>
 800024e:	4798      	blx	r3
 8000250:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8000254:	e7b0      	b.n	80001b8 <register_tm_clones>
 8000256:	bf00      	nop

08000258 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8000258:	b480      	push	{r7}
 800025a:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800025c:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8000260:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000264:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 8000268:	f2ce 0200 	movt	r2, #57344	; 0xe000
 800026c:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 8000270:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8000274:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000278:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800027c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000280:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000284:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000288:	6812      	ldr	r2, [r2, #0]
 800028a:	f042 0201 	orr.w	r2, r2, #1
 800028e:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8000290:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000294:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000298:	2200      	movs	r2, #0
 800029a:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 800029c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80002a0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80002a4:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80002a8:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80002ac:	6812      	ldr	r2, [r2, #0]
 80002ae:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 80002b2:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80002b6:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80002b8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80002bc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80002c0:	f243 0210 	movw	r2, #12304	; 0x3010
 80002c4:	f2c2 4200 	movt	r2, #9216	; 0x2400
 80002c8:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80002ca:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80002ce:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80002d2:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80002d6:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80002da:	6812      	ldr	r2, [r2, #0]
 80002dc:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80002e0:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 80002e2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80002e6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80002ea:	2200      	movs	r2, #0
 80002ec:	60da      	str	r2, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80002ee:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 80002f2:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80002f6:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80002fa:	609a      	str	r2, [r3, #8]
#endif
}
 80002fc:	46bd      	mov	sp, r7
 80002fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000302:	4770      	bx	lr

08000304 <SystemCoreClockUpdate>:
  *     
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
 8000304:	b480      	push	{r7}
 8000306:	b087      	sub	sp, #28
 8000308:	af00      	add	r7, sp, #0
  uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
 800030a:	2300      	movs	r3, #0
 800030c:	613b      	str	r3, [r7, #16]
 800030e:	2300      	movs	r3, #0
 8000310:	617b      	str	r3, [r7, #20]
 8000312:	2302      	movs	r3, #2
 8000314:	60fb      	str	r3, [r7, #12]
 8000316:	2300      	movs	r3, #0
 8000318:	60bb      	str	r3, [r7, #8]
 800031a:	2302      	movs	r3, #2
 800031c:	607b      	str	r3, [r7, #4]
  
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 800031e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000322:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000326:	689b      	ldr	r3, [r3, #8]
 8000328:	f003 030c 	and.w	r3, r3, #12
 800032c:	613b      	str	r3, [r7, #16]

  switch (tmp)
 800032e:	693b      	ldr	r3, [r7, #16]
 8000330:	2b04      	cmp	r3, #4
 8000332:	d00d      	beq.n	8000350 <SystemCoreClockUpdate+0x4c>
 8000334:	2b08      	cmp	r3, #8
 8000336:	d015      	beq.n	8000364 <SystemCoreClockUpdate+0x60>
 8000338:	2b00      	cmp	r3, #0
 800033a:	d163      	bne.n	8000404 <SystemCoreClockUpdate+0x100>
  {
    case 0x00:  /* HSI used as system clock source */
      SystemCoreClock = HSI_VALUE;
 800033c:	f240 0300 	movw	r3, #0
 8000340:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000344:	f44f 5210 	mov.w	r2, #9216	; 0x2400
 8000348:	f2c0 02f4 	movt	r2, #244	; 0xf4
 800034c:	601a      	str	r2, [r3, #0]
      break;
 800034e:	e063      	b.n	8000418 <SystemCoreClockUpdate+0x114>
    case 0x04:  /* HSE used as system clock source */
      SystemCoreClock = HSE_VALUE;
 8000350:	f240 0300 	movw	r3, #0
 8000354:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000358:	f44f 5290 	mov.w	r2, #4608	; 0x1200
 800035c:	f2c0 027a 	movt	r2, #122	; 0x7a
 8000360:	601a      	str	r2, [r3, #0]
      break;
 8000362:	e059      	b.n	8000418 <SystemCoreClockUpdate+0x114>
    case 0x08:  /* PLL used as system clock source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8000364:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000368:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800036c:	685b      	ldr	r3, [r3, #4]
 800036e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8000372:	0d9b      	lsrs	r3, r3, #22
 8000374:	60bb      	str	r3, [r7, #8]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8000376:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800037a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800037e:	685b      	ldr	r3, [r3, #4]
 8000380:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8000384:	607b      	str	r3, [r7, #4]
      
      if (pllsource != 0)
 8000386:	68bb      	ldr	r3, [r7, #8]
 8000388:	2b00      	cmp	r3, #0
 800038a:	d013      	beq.n	80003b4 <SystemCoreClockUpdate+0xb0>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 800038c:	f44f 5390 	mov.w	r3, #4608	; 0x1200
 8000390:	f2c0 037a 	movt	r3, #122	; 0x7a
 8000394:	687a      	ldr	r2, [r7, #4]
 8000396:	fbb3 f2f2 	udiv	r2, r3, r2
 800039a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800039e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80003a2:	6859      	ldr	r1, [r3, #4]
 80003a4:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 80003a8:	400b      	ands	r3, r1
 80003aa:	099b      	lsrs	r3, r3, #6
 80003ac:	fb03 f302 	mul.w	r3, r3, r2
 80003b0:	617b      	str	r3, [r7, #20]
 80003b2:	e012      	b.n	80003da <SystemCoreClockUpdate+0xd6>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 80003b4:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 80003b8:	f2c0 03f4 	movt	r3, #244	; 0xf4
 80003bc:	687a      	ldr	r2, [r7, #4]
 80003be:	fbb3 f2f2 	udiv	r2, r3, r2
 80003c2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80003c6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80003ca:	6859      	ldr	r1, [r3, #4]
 80003cc:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 80003d0:	400b      	ands	r3, r1
 80003d2:	099b      	lsrs	r3, r3, #6
 80003d4:	fb03 f302 	mul.w	r3, r3, r2
 80003d8:	617b      	str	r3, [r7, #20]
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 80003da:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80003de:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80003e2:	685b      	ldr	r3, [r3, #4]
 80003e4:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 80003e8:	0c1b      	lsrs	r3, r3, #16
 80003ea:	3301      	adds	r3, #1
 80003ec:	005b      	lsls	r3, r3, #1
 80003ee:	60fb      	str	r3, [r7, #12]
      SystemCoreClock = pllvco/pllp;
 80003f0:	697a      	ldr	r2, [r7, #20]
 80003f2:	68fb      	ldr	r3, [r7, #12]
 80003f4:	fbb2 f2f3 	udiv	r2, r2, r3
 80003f8:	f240 0300 	movw	r3, #0
 80003fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000400:	601a      	str	r2, [r3, #0]
      break;
 8000402:	e009      	b.n	8000418 <SystemCoreClockUpdate+0x114>
    default:
      SystemCoreClock = HSI_VALUE;
 8000404:	f240 0300 	movw	r3, #0
 8000408:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800040c:	f44f 5210 	mov.w	r2, #9216	; 0x2400
 8000410:	f2c0 02f4 	movt	r2, #244	; 0xf4
 8000414:	601a      	str	r2, [r3, #0]
      break;
 8000416:	bf00      	nop
  }
  /* Compute HCLK frequency --------------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8000418:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800041c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000420:	689b      	ldr	r3, [r3, #8]
 8000422:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8000426:	091a      	lsrs	r2, r3, #4
 8000428:	f64b 13f8 	movw	r3, #47608	; 0xb9f8
 800042c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000430:	5c9b      	ldrb	r3, [r3, r2]
 8000432:	613b      	str	r3, [r7, #16]
  /* HCLK frequency */
  SystemCoreClock >>= tmp;
 8000434:	f240 0300 	movw	r3, #0
 8000438:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800043c:	681a      	ldr	r2, [r3, #0]
 800043e:	693b      	ldr	r3, [r7, #16]
 8000440:	40da      	lsrs	r2, r3
 8000442:	f240 0300 	movw	r3, #0
 8000446:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800044a:	601a      	str	r2, [r3, #0]
}
 800044c:	371c      	adds	r7, #28
 800044e:	46bd      	mov	sp, r7
 8000450:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000454:	4770      	bx	lr
 8000456:	bf00      	nop

08000458 <MX_ADC3_Init>:
ADC_HandleTypeDef hadc3;
DMA_HandleTypeDef hdma_adc3;

/* ADC3 init function */
void MX_ADC3_Init(void)
{
 8000458:	b580      	push	{r7, lr}
 800045a:	b084      	sub	sp, #16
 800045c:	af00      	add	r7, sp, #0
  ADC_ChannelConfTypeDef sConfig;

    /**Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion) 
    */
  hadc3.Instance = ADC3;
 800045e:	f240 434c 	movw	r3, #1100	; 0x44c
 8000462:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000466:	f44f 5208 	mov.w	r2, #8704	; 0x2200
 800046a:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800046e:	601a      	str	r2, [r3, #0]
  hadc3.Init.ClockPrescaler = ADC_CLOCKPRESCALER_PCLK_DIV4;
 8000470:	f240 434c 	movw	r3, #1100	; 0x44c
 8000474:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000478:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800047c:	605a      	str	r2, [r3, #4]
  hadc3.Init.Resolution = ADC_RESOLUTION12b;
 800047e:	f240 434c 	movw	r3, #1100	; 0x44c
 8000482:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000486:	2200      	movs	r2, #0
 8000488:	609a      	str	r2, [r3, #8]
  hadc3.Init.ScanConvMode = DISABLE;
 800048a:	f240 434c 	movw	r3, #1100	; 0x44c
 800048e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000492:	2200      	movs	r2, #0
 8000494:	611a      	str	r2, [r3, #16]
  hadc3.Init.ContinuousConvMode = DISABLE;
 8000496:	f240 434c 	movw	r3, #1100	; 0x44c
 800049a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800049e:	2200      	movs	r2, #0
 80004a0:	619a      	str	r2, [r3, #24]
  hadc3.Init.DiscontinuousConvMode = DISABLE;
 80004a2:	f240 434c 	movw	r3, #1100	; 0x44c
 80004a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80004aa:	2200      	movs	r2, #0
 80004ac:	625a      	str	r2, [r3, #36]	; 0x24
  hadc3.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 80004ae:	f240 434c 	movw	r3, #1100	; 0x44c
 80004b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80004b6:	2200      	movs	r2, #0
 80004b8:	631a      	str	r2, [r3, #48]	; 0x30
  hadc3.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 80004ba:	f240 434c 	movw	r3, #1100	; 0x44c
 80004be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80004c2:	2200      	movs	r2, #0
 80004c4:	60da      	str	r2, [r3, #12]
  hadc3.Init.NbrOfConversion = 1;
 80004c6:	f240 434c 	movw	r3, #1100	; 0x44c
 80004ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80004ce:	2201      	movs	r2, #1
 80004d0:	621a      	str	r2, [r3, #32]
  hadc3.Init.DMAContinuousRequests = DISABLE;
 80004d2:	f240 434c 	movw	r3, #1100	; 0x44c
 80004d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80004da:	2200      	movs	r2, #0
 80004dc:	61da      	str	r2, [r3, #28]
  hadc3.Init.EOCSelection = EOC_SINGLE_CONV;
 80004de:	f240 434c 	movw	r3, #1100	; 0x44c
 80004e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80004e6:	2201      	movs	r2, #1
 80004e8:	615a      	str	r2, [r3, #20]
  HAL_ADC_Init(&hadc3);
 80004ea:	f240 404c 	movw	r0, #1100	; 0x44c
 80004ee:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80004f2:	f001 fb75 	bl	8001be0 <HAL_ADC_Init>

    /**Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time. 
    */
  sConfig.Channel = ADC_CHANNEL_10;
 80004f6:	230a      	movs	r3, #10
 80004f8:	603b      	str	r3, [r7, #0]
  sConfig.Rank = 1;
 80004fa:	2301      	movs	r3, #1
 80004fc:	607b      	str	r3, [r7, #4]
  sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
 80004fe:	2300      	movs	r3, #0
 8000500:	60bb      	str	r3, [r7, #8]
  HAL_ADC_ConfigChannel(&hadc3, &sConfig);
 8000502:	463b      	mov	r3, r7
 8000504:	f240 404c 	movw	r0, #1100	; 0x44c
 8000508:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800050c:	4619      	mov	r1, r3
 800050e:	f001 ffd3 	bl	80024b8 <HAL_ADC_ConfigChannel>

}
 8000512:	3710      	adds	r7, #16
 8000514:	46bd      	mov	sp, r7
 8000516:	bd80      	pop	{r7, pc}

08000518 <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 8000518:	b580      	push	{r7, lr}
 800051a:	b088      	sub	sp, #32
 800051c:	af00      	add	r7, sp, #0
 800051e:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hadc->Instance==ADC3)
 8000520:	687b      	ldr	r3, [r7, #4]
 8000522:	681a      	ldr	r2, [r3, #0]
 8000524:	f44f 5308 	mov.w	r3, #8704	; 0x2200
 8000528:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800052c:	429a      	cmp	r2, r3
 800052e:	f040 8089 	bne.w	8000644 <HAL_ADC_MspInit+0x12c>
  {
  /* USER CODE BEGIN ADC3_MspInit 0 */

  /* USER CODE END ADC3_MspInit 0 */
    /* Peripheral clock enable */
    __ADC3_CLK_ENABLE();
 8000532:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000536:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800053a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800053e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000542:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8000544:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000548:	645a      	str	r2, [r3, #68]	; 0x44
 800054a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800054e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000552:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000554:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8000558:	60bb      	str	r3, [r7, #8]
 800055a:	68bb      	ldr	r3, [r7, #8]
  
    /**ADC3 GPIO Configuration    
    PC0     ------> ADC3_IN10 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 800055c:	2301      	movs	r3, #1
 800055e:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8000560:	2303      	movs	r3, #3
 8000562:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000564:	2300      	movs	r3, #0
 8000566:	617b      	str	r3, [r7, #20]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000568:	f107 030c 	add.w	r3, r7, #12
 800056c:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8000570:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000574:	4619      	mov	r1, r3
 8000576:	f004 fb97 	bl	8004ca8 <HAL_GPIO_Init>

    /* Peripheral DMA init*/
  
    hdma_adc3.Instance = DMA2_Stream0;
 800057a:	f240 4390 	movw	r3, #1168	; 0x490
 800057e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000582:	f246 4210 	movw	r2, #25616	; 0x6410
 8000586:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800058a:	601a      	str	r2, [r3, #0]
    hdma_adc3.Init.Channel = DMA_CHANNEL_2;
 800058c:	f240 4390 	movw	r3, #1168	; 0x490
 8000590:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000594:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 8000598:	605a      	str	r2, [r3, #4]
    hdma_adc3.Init.Direction = DMA_PERIPH_TO_MEMORY;
 800059a:	f240 4390 	movw	r3, #1168	; 0x490
 800059e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80005a2:	2200      	movs	r2, #0
 80005a4:	609a      	str	r2, [r3, #8]
    hdma_adc3.Init.PeriphInc = DMA_PINC_DISABLE;
 80005a6:	f240 4390 	movw	r3, #1168	; 0x490
 80005aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80005ae:	2200      	movs	r2, #0
 80005b0:	60da      	str	r2, [r3, #12]
    hdma_adc3.Init.MemInc = DMA_MINC_ENABLE;
 80005b2:	f240 4390 	movw	r3, #1168	; 0x490
 80005b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80005ba:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80005be:	611a      	str	r2, [r3, #16]
    hdma_adc3.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 80005c0:	f240 4390 	movw	r3, #1168	; 0x490
 80005c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80005c8:	2200      	movs	r2, #0
 80005ca:	615a      	str	r2, [r3, #20]
    hdma_adc3.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 80005cc:	f240 4390 	movw	r3, #1168	; 0x490
 80005d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80005d4:	2200      	movs	r2, #0
 80005d6:	619a      	str	r2, [r3, #24]
    hdma_adc3.Init.Mode = DMA_NORMAL;
 80005d8:	f240 4390 	movw	r3, #1168	; 0x490
 80005dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80005e0:	2200      	movs	r2, #0
 80005e2:	61da      	str	r2, [r3, #28]
    hdma_adc3.Init.Priority = DMA_PRIORITY_LOW;
 80005e4:	f240 4390 	movw	r3, #1168	; 0x490
 80005e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80005ec:	2200      	movs	r2, #0
 80005ee:	621a      	str	r2, [r3, #32]
    hdma_adc3.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 80005f0:	f240 4390 	movw	r3, #1168	; 0x490
 80005f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80005f8:	2200      	movs	r2, #0
 80005fa:	625a      	str	r2, [r3, #36]	; 0x24
    hdma_adc3.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
 80005fc:	f240 4390 	movw	r3, #1168	; 0x490
 8000600:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000604:	2203      	movs	r2, #3
 8000606:	629a      	str	r2, [r3, #40]	; 0x28
    hdma_adc3.Init.MemBurst = DMA_MBURST_SINGLE;
 8000608:	f240 4390 	movw	r3, #1168	; 0x490
 800060c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000610:	2200      	movs	r2, #0
 8000612:	62da      	str	r2, [r3, #44]	; 0x2c
    hdma_adc3.Init.PeriphBurst = DMA_PBURST_SINGLE;
 8000614:	f240 4390 	movw	r3, #1168	; 0x490
 8000618:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800061c:	2200      	movs	r2, #0
 800061e:	631a      	str	r2, [r3, #48]	; 0x30
    HAL_DMA_Init(&hdma_adc3);
 8000620:	f240 4090 	movw	r0, #1168	; 0x490
 8000624:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000628:	f003 fed0 	bl	80043cc <HAL_DMA_Init>

    __HAL_LINKDMA(hadc,DMA_Handle,hdma_adc3);
 800062c:	687a      	ldr	r2, [r7, #4]
 800062e:	f240 4390 	movw	r3, #1168	; 0x490
 8000632:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000636:	6393      	str	r3, [r2, #56]	; 0x38
 8000638:	f240 4390 	movw	r3, #1168	; 0x490
 800063c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000640:	687a      	ldr	r2, [r7, #4]
 8000642:	639a      	str	r2, [r3, #56]	; 0x38

  /* USER CODE BEGIN ADC3_MspInit 1 */

  /* USER CODE END ADC3_MspInit 1 */
  }
}
 8000644:	3720      	adds	r7, #32
 8000646:	46bd      	mov	sp, r7
 8000648:	bd80      	pop	{r7, pc}
 800064a:	bf00      	nop

0800064c <HAL_ADC_MspDeInit>:

void HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc)
{
 800064c:	b580      	push	{r7, lr}
 800064e:	b082      	sub	sp, #8
 8000650:	af00      	add	r7, sp, #0
 8000652:	6078      	str	r0, [r7, #4]

  if(hadc->Instance==ADC3)
 8000654:	687b      	ldr	r3, [r7, #4]
 8000656:	681a      	ldr	r2, [r3, #0]
 8000658:	f44f 5308 	mov.w	r3, #8704	; 0x2200
 800065c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8000660:	429a      	cmp	r2, r3
 8000662:	d117      	bne.n	8000694 <HAL_ADC_MspDeInit+0x48>
  {
  /* USER CODE BEGIN ADC3_MspDeInit 0 */

  /* USER CODE END ADC3_MspDeInit 0 */
    /* Peripheral clock disable */
    __ADC3_CLK_DISABLE();
 8000664:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000668:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800066c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000670:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000674:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8000676:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800067a:	645a      	str	r2, [r3, #68]	; 0x44
  
    /**ADC3 GPIO Configuration    
    PC0     ------> ADC3_IN10 
    */
    HAL_GPIO_DeInit(GPIOC, GPIO_PIN_0);
 800067c:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8000680:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000684:	2101      	movs	r1, #1
 8000686:	f004 fcd7 	bl	8005038 <HAL_GPIO_DeInit>

    /* Peripheral DMA DeInit*/
    HAL_DMA_DeInit(hadc->DMA_Handle);
 800068a:	687b      	ldr	r3, [r7, #4]
 800068c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800068e:	4618      	mov	r0, r3
 8000690:	f003 ff0a 	bl	80044a8 <HAL_DMA_DeInit>
  }
  /* USER CODE BEGIN ADC3_MspDeInit 1 */

  /* USER CODE END ADC3_MspDeInit 1 */
} 
 8000694:	3708      	adds	r7, #8
 8000696:	46bd      	mov	sp, r7
 8000698:	bd80      	pop	{r7, pc}
 800069a:	bf00      	nop

0800069c <MX_DAC_Init>:

DAC_HandleTypeDef hdac;

/* DAC init function */
void MX_DAC_Init(void)
{
 800069c:	b580      	push	{r7, lr}
 800069e:	b082      	sub	sp, #8
 80006a0:	af00      	add	r7, sp, #0
  DAC_ChannelConfTypeDef sConfig;

    /**DAC Initialization 
    */
  hdac.Instance = DAC;
 80006a2:	f240 43e8 	movw	r3, #1256	; 0x4e8
 80006a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80006aa:	f44f 42e8 	mov.w	r2, #29696	; 0x7400
 80006ae:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80006b2:	601a      	str	r2, [r3, #0]
  HAL_DAC_Init(&hdac);
 80006b4:	f240 40e8 	movw	r0, #1256	; 0x4e8
 80006b8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80006bc:	f003 fa62 	bl	8003b84 <HAL_DAC_Init>

    /**DAC channel OUT1 config 
    */
  sConfig.DAC_Trigger = DAC_TRIGGER_NONE;
 80006c0:	2300      	movs	r3, #0
 80006c2:	603b      	str	r3, [r7, #0]
  sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_DISABLE;
 80006c4:	2302      	movs	r3, #2
 80006c6:	607b      	str	r3, [r7, #4]
  HAL_DAC_ConfigChannel(&hdac, &sConfig, DAC_CHANNEL_1);
 80006c8:	463b      	mov	r3, r7
 80006ca:	f240 40e8 	movw	r0, #1256	; 0x4e8
 80006ce:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80006d2:	4619      	mov	r1, r3
 80006d4:	2200      	movs	r2, #0
 80006d6:	f003 fcaf 	bl	8004038 <HAL_DAC_ConfigChannel>

    /**DAC channel OUT2 config 
    */
  HAL_DAC_ConfigChannel(&hdac, &sConfig, DAC_CHANNEL_2);
 80006da:	463b      	mov	r3, r7
 80006dc:	f240 40e8 	movw	r0, #1256	; 0x4e8
 80006e0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80006e4:	4619      	mov	r1, r3
 80006e6:	2210      	movs	r2, #16
 80006e8:	f003 fca6 	bl	8004038 <HAL_DAC_ConfigChannel>

}
 80006ec:	3708      	adds	r7, #8
 80006ee:	46bd      	mov	sp, r7
 80006f0:	bd80      	pop	{r7, pc}
 80006f2:	bf00      	nop

080006f4 <HAL_DAC_MspInit>:

void HAL_DAC_MspInit(DAC_HandleTypeDef* hdac)
{
 80006f4:	b580      	push	{r7, lr}
 80006f6:	b088      	sub	sp, #32
 80006f8:	af00      	add	r7, sp, #0
 80006fa:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hdac->Instance==DAC)
 80006fc:	687b      	ldr	r3, [r7, #4]
 80006fe:	681a      	ldr	r2, [r3, #0]
 8000700:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 8000704:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8000708:	429a      	cmp	r2, r3
 800070a:	d122      	bne.n	8000752 <HAL_DAC_MspInit+0x5e>
  {
  /* USER CODE BEGIN DAC_MspInit 0 */

  /* USER CODE END DAC_MspInit 0 */
    /* Peripheral clock enable */
    __DAC_CLK_ENABLE();
 800070c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000710:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000714:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000718:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800071c:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800071e:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8000722:	641a      	str	r2, [r3, #64]	; 0x40
 8000724:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000728:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800072c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800072e:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8000732:	60bb      	str	r3, [r7, #8]
 8000734:	68bb      	ldr	r3, [r7, #8]
  
    /**DAC GPIO Configuration    
    PA4     ------> DAC_OUT1
    PA5     ------> DAC_OUT2 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5;
 8000736:	2330      	movs	r3, #48	; 0x30
 8000738:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800073a:	2303      	movs	r3, #3
 800073c:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800073e:	2300      	movs	r3, #0
 8000740:	617b      	str	r3, [r7, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000742:	f107 030c 	add.w	r3, r7, #12
 8000746:	2000      	movs	r0, #0
 8000748:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800074c:	4619      	mov	r1, r3
 800074e:	f004 faab 	bl	8004ca8 <HAL_GPIO_Init>

  /* USER CODE BEGIN DAC_MspInit 1 */

  /* USER CODE END DAC_MspInit 1 */
  }
}
 8000752:	3720      	adds	r7, #32
 8000754:	46bd      	mov	sp, r7
 8000756:	bd80      	pop	{r7, pc}

08000758 <HAL_DAC_MspDeInit>:

void HAL_DAC_MspDeInit(DAC_HandleTypeDef* hdac)
{
 8000758:	b580      	push	{r7, lr}
 800075a:	b082      	sub	sp, #8
 800075c:	af00      	add	r7, sp, #0
 800075e:	6078      	str	r0, [r7, #4]

  if(hdac->Instance==DAC)
 8000760:	687b      	ldr	r3, [r7, #4]
 8000762:	681a      	ldr	r2, [r3, #0]
 8000764:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 8000768:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800076c:	429a      	cmp	r2, r3
 800076e:	d111      	bne.n	8000794 <HAL_DAC_MspDeInit+0x3c>
  {
  /* USER CODE BEGIN DAC_MspDeInit 0 */

  /* USER CODE END DAC_MspDeInit 0 */
    /* Peripheral clock disable */
    __DAC_CLK_DISABLE();
 8000770:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000774:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000778:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800077c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000780:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8000782:	f022 5200 	bic.w	r2, r2, #536870912	; 0x20000000
 8000786:	641a      	str	r2, [r3, #64]	; 0x40
  
    /**DAC GPIO Configuration    
    PA4     ------> DAC_OUT1
    PA5     ------> DAC_OUT2 
    */
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_4|GPIO_PIN_5);
 8000788:	2000      	movs	r0, #0
 800078a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800078e:	2130      	movs	r1, #48	; 0x30
 8000790:	f004 fc52 	bl	8005038 <HAL_GPIO_DeInit>

  }
  /* USER CODE BEGIN DAC_MspDeInit 1 */

  /* USER CODE END DAC_MspDeInit 1 */
} 
 8000794:	3708      	adds	r7, #8
 8000796:	46bd      	mov	sp, r7
 8000798:	bd80      	pop	{r7, pc}
 800079a:	bf00      	nop

0800079c <MX_DMA_Init>:

/** 
  * Enable DMA controller clock
  */
void MX_DMA_Init(void) 
{
 800079c:	b580      	push	{r7, lr}
 800079e:	b082      	sub	sp, #8
 80007a0:	af00      	add	r7, sp, #0
  /* DMA controller clock enable */
  __DMA1_CLK_ENABLE();
 80007a2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80007a6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80007aa:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80007ae:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80007b2:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80007b4:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80007b8:	631a      	str	r2, [r3, #48]	; 0x30
 80007ba:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80007be:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80007c2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80007c4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80007c8:	607b      	str	r3, [r7, #4]
 80007ca:	687b      	ldr	r3, [r7, #4]
  __DMA2_CLK_ENABLE();
 80007cc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80007d0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80007d4:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80007d8:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80007dc:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80007de:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 80007e2:	631a      	str	r2, [r3, #48]	; 0x30
 80007e4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80007e8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80007ec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80007ee:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80007f2:	603b      	str	r3, [r7, #0]
 80007f4:	683b      	ldr	r3, [r7, #0]

  /* DMA interrupt init */
  HAL_NVIC_SetPriority(DMA1_Stream0_IRQn, 0, 0);
 80007f6:	200b      	movs	r0, #11
 80007f8:	2100      	movs	r1, #0
 80007fa:	2200      	movs	r2, #0
 80007fc:	f003 f89a 	bl	8003934 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream0_IRQn);
 8000800:	200b      	movs	r0, #11
 8000802:	f003 f8b3 	bl	800396c <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA1_Stream5_IRQn, 0, 0);
 8000806:	2010      	movs	r0, #16
 8000808:	2100      	movs	r1, #0
 800080a:	2200      	movs	r2, #0
 800080c:	f003 f892 	bl	8003934 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream5_IRQn);
 8000810:	2010      	movs	r0, #16
 8000812:	f003 f8ab 	bl	800396c <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);
 8000816:	2038      	movs	r0, #56	; 0x38
 8000818:	2100      	movs	r1, #0
 800081a:	2200      	movs	r2, #0
 800081c:	f003 f88a 	bl	8003934 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
 8000820:	2038      	movs	r0, #56	; 0x38
 8000822:	f003 f8a3 	bl	800396c <HAL_NVIC_EnableIRQ>

}
 8000826:	3708      	adds	r7, #8
 8000828:	46bd      	mov	sp, r7
 800082a:	bd80      	pop	{r7, pc}

0800082c <MX_GPIO_Init>:
        * EXTI
     PA11   ------> USB_OTG_FS_DM
     PA12   ------> USB_OTG_FS_DP
*/
void MX_GPIO_Init(void)
{
 800082c:	b580      	push	{r7, lr}
 800082e:	b08c      	sub	sp, #48	; 0x30
 8000830:	af00      	add	r7, sp, #0

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOE_CLK_ENABLE();
 8000832:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000836:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800083a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800083e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000842:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8000844:	f042 0210 	orr.w	r2, r2, #16
 8000848:	631a      	str	r2, [r3, #48]	; 0x30
 800084a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800084e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000852:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000854:	f003 0310 	and.w	r3, r3, #16
 8000858:	61bb      	str	r3, [r7, #24]
 800085a:	69bb      	ldr	r3, [r7, #24]
  __GPIOC_CLK_ENABLE();
 800085c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000860:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000864:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000868:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800086c:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800086e:	f042 0204 	orr.w	r2, r2, #4
 8000872:	631a      	str	r2, [r3, #48]	; 0x30
 8000874:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000878:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800087c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800087e:	f003 0304 	and.w	r3, r3, #4
 8000882:	617b      	str	r3, [r7, #20]
 8000884:	697b      	ldr	r3, [r7, #20]
  __GPIOH_CLK_ENABLE();
 8000886:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800088a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800088e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000892:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000896:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8000898:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800089c:	631a      	str	r2, [r3, #48]	; 0x30
 800089e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80008a2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80008a6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80008a8:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80008ac:	613b      	str	r3, [r7, #16]
 80008ae:	693b      	ldr	r3, [r7, #16]
  __GPIOA_CLK_ENABLE();
 80008b0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80008b4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80008b8:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80008bc:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80008c0:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80008c2:	f042 0201 	orr.w	r2, r2, #1
 80008c6:	631a      	str	r2, [r3, #48]	; 0x30
 80008c8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80008cc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80008d0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80008d2:	f003 0301 	and.w	r3, r3, #1
 80008d6:	60fb      	str	r3, [r7, #12]
 80008d8:	68fb      	ldr	r3, [r7, #12]
  __GPIOB_CLK_ENABLE();
 80008da:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80008de:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80008e2:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80008e6:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80008ea:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80008ec:	f042 0202 	orr.w	r2, r2, #2
 80008f0:	631a      	str	r2, [r3, #48]	; 0x30
 80008f2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80008f6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80008fa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80008fc:	f003 0302 	and.w	r3, r3, #2
 8000900:	60bb      	str	r3, [r7, #8]
 8000902:	68bb      	ldr	r3, [r7, #8]
  __GPIOD_CLK_ENABLE();
 8000904:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000908:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800090c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000910:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000914:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8000916:	f042 0208 	orr.w	r2, r2, #8
 800091a:	631a      	str	r2, [r3, #48]	; 0x30
 800091c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000920:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000924:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000926:	f003 0308 	and.w	r3, r3, #8
 800092a:	607b      	str	r3, [r7, #4]
 800092c:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pins : PE2 PE6 */
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_6;
 800092e:	2344      	movs	r3, #68	; 0x44
 8000930:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8000932:	2300      	movs	r3, #0
 8000934:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000936:	2301      	movs	r3, #1
 8000938:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800093a:	f107 031c 	add.w	r3, r7, #28
 800093e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8000942:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000946:	4619      	mov	r1, r3
 8000948:	f004 f9ae 	bl	8004ca8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PE3 PE4 PE5 PE11 
                           PE0 PE1 */
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_11 
 800094c:	f640 033b 	movw	r3, #2107	; 0x83b
 8000950:	61fb      	str	r3, [r7, #28]
                          |GPIO_PIN_0|GPIO_PIN_1;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000952:	2301      	movs	r3, #1
 8000954:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000956:	2300      	movs	r3, #0
 8000958:	627b      	str	r3, [r7, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 800095a:	2300      	movs	r3, #0
 800095c:	62bb      	str	r3, [r7, #40]	; 0x28
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800095e:	f107 031c 	add.w	r3, r7, #28
 8000962:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8000966:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800096a:	4619      	mov	r1, r3
 800096c:	f004 f99c 	bl	8004ca8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PC13 PC15 PC2 */
  GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_15|GPIO_PIN_2;
 8000970:	f24a 0304 	movw	r3, #40964	; 0xa004
 8000974:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000976:	2301      	movs	r3, #1
 8000978:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800097a:	2300      	movs	r3, #0
 800097c:	627b      	str	r3, [r7, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 800097e:	2300      	movs	r3, #0
 8000980:	62bb      	str	r3, [r7, #40]	; 0x28
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000982:	f107 031c 	add.w	r3, r7, #28
 8000986:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800098a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800098e:	4619      	mov	r1, r3
 8000990:	f004 f98a 	bl	8004ca8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PC14 PC1 PC3 */
  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_1|GPIO_PIN_3;
 8000994:	f244 030a 	movw	r3, #16394	; 0x400a
 8000998:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800099a:	2300      	movs	r3, #0
 800099c:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 800099e:	2301      	movs	r3, #1
 80009a0:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80009a2:	f107 031c 	add.w	r3, r7, #28
 80009a6:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80009aa:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80009ae:	4619      	mov	r1, r3
 80009b0:	f004 f97a 	bl	8004ca8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PA0 PA2 */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2;
 80009b4:	2305      	movs	r3, #5
 80009b6:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80009b8:	2301      	movs	r3, #1
 80009ba:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80009bc:	2300      	movs	r3, #0
 80009be:	627b      	str	r3, [r7, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 80009c0:	2300      	movs	r3, #0
 80009c2:	62bb      	str	r3, [r7, #40]	; 0x28
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80009c4:	f107 031c 	add.w	r3, r7, #28
 80009c8:	2000      	movs	r0, #0
 80009ca:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80009ce:	4619      	mov	r1, r3
 80009d0:	f004 f96a 	bl	8004ca8 <HAL_GPIO_Init>

  /*Configure GPIO pin : PA1 */
  GPIO_InitStruct.Pin = GPIO_PIN_1;
 80009d4:	2302      	movs	r3, #2
 80009d6:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80009d8:	2300      	movs	r3, #0
 80009da:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 80009dc:	2301      	movs	r3, #1
 80009de:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80009e0:	f107 031c 	add.w	r3, r7, #28
 80009e4:	2000      	movs	r0, #0
 80009e6:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80009ea:	4619      	mov	r1, r3
 80009ec:	f004 f95c 	bl	8004ca8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PB11 PB9 */
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_9;
 80009f0:	f44f 6320 	mov.w	r3, #2560	; 0xa00
 80009f4:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80009f6:	2301      	movs	r3, #1
 80009f8:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80009fa:	2300      	movs	r3, #0
 80009fc:	627b      	str	r3, [r7, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 80009fe:	2300      	movs	r3, #0
 8000a00:	62bb      	str	r3, [r7, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000a02:	f107 031c 	add.w	r3, r7, #28
 8000a06:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8000a0a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000a0e:	4619      	mov	r1, r3
 8000a10:	f004 f94a 	bl	8004ca8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PA11 PA12 */
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 8000a14:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 8000a18:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000a1a:	2302      	movs	r3, #2
 8000a1c:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000a1e:	2300      	movs	r3, #0
 8000a20:	627b      	str	r3, [r7, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8000a22:	2303      	movs	r3, #3
 8000a24:	62bb      	str	r3, [r7, #40]	; 0x28
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 8000a26:	230a      	movs	r3, #10
 8000a28:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000a2a:	f107 031c 	add.w	r3, r7, #28
 8000a2e:	2000      	movs	r0, #0
 8000a30:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000a34:	4619      	mov	r1, r3
 8000a36:	f004 f937 	bl	8004ca8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PD4 PD5 */
  GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5;
 8000a3a:	2330      	movs	r3, #48	; 0x30
 8000a3c:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8000a3e:	2300      	movs	r3, #0
 8000a40:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000a42:	2301      	movs	r3, #1
 8000a44:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8000a46:	f107 031c 	add.w	r3, r7, #28
 8000a4a:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 8000a4e:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000a52:	4619      	mov	r1, r3
 8000a54:	f004 f928 	bl	8004ca8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PB7 PB8 */
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8;
 8000a58:	f44f 73c0 	mov.w	r3, #384	; 0x180
 8000a5c:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8000a5e:	2300      	movs	r3, #0
 8000a60:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000a62:	2301      	movs	r3, #1
 8000a64:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000a66:	f107 031c 	add.w	r3, r7, #28
 8000a6a:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8000a6e:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000a72:	4619      	mov	r1, r3
 8000a74:	f004 f918 	bl	8004ca8 <HAL_GPIO_Init>

}
 8000a78:	3730      	adds	r7, #48	; 0x30
 8000a7a:	46bd      	mov	sp, r7
 8000a7c:	bd80      	pop	{r7, pc}
 8000a7e:	bf00      	nop

08000a80 <MX_I2S3_Init>:
DMA_HandleTypeDef hdma_i2s3_ext_tx;
DMA_HandleTypeDef hdma_spi3_rx;

/* I2S3 init function */
void MX_I2S3_Init(void)
{
 8000a80:	b580      	push	{r7, lr}
 8000a82:	af00      	add	r7, sp, #0

  hi2s3.Instance = SPI3;
 8000a84:	f240 43fc 	movw	r3, #1276	; 0x4fc
 8000a88:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000a8c:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
 8000a90:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8000a94:	601a      	str	r2, [r3, #0]
  // hi2s3.Init.Mode = I2S_MODE_MASTER_TX;
    hi2s3.Init.Mode = I2S_MODE_MASTER_RX;
 8000a96:	f240 43fc 	movw	r3, #1276	; 0x4fc
 8000a9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000a9e:	f44f 7240 	mov.w	r2, #768	; 0x300
 8000aa2:	605a      	str	r2, [r3, #4]
  hi2s3.Init.Standard = I2S_STANDARD_PHILLIPS;
 8000aa4:	f240 43fc 	movw	r3, #1276	; 0x4fc
 8000aa8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000aac:	2200      	movs	r2, #0
 8000aae:	609a      	str	r2, [r3, #8]
  hi2s3.Init.DataFormat = I2S_DATAFORMAT_16B;
 8000ab0:	f240 43fc 	movw	r3, #1276	; 0x4fc
 8000ab4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ab8:	2200      	movs	r2, #0
 8000aba:	60da      	str	r2, [r3, #12]
  hi2s3.Init.MCLKOutput = I2S_MCLKOUTPUT_ENABLE;
 8000abc:	f240 43fc 	movw	r3, #1276	; 0x4fc
 8000ac0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ac4:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000ac8:	611a      	str	r2, [r3, #16]
  hi2s3.Init.AudioFreq = I2S_AUDIOFREQ_32K;
 8000aca:	f240 43fc 	movw	r3, #1276	; 0x4fc
 8000ace:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ad2:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
 8000ad6:	615a      	str	r2, [r3, #20]
  hi2s3.Init.CPOL = I2S_CPOL_HIGH;
 8000ad8:	f240 43fc 	movw	r3, #1276	; 0x4fc
 8000adc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ae0:	2208      	movs	r2, #8
 8000ae2:	619a      	str	r2, [r3, #24]
  hi2s3.Init.ClockSource = I2S_CLOCK_PLL;
 8000ae4:	f240 43fc 	movw	r3, #1276	; 0x4fc
 8000ae8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000aec:	2200      	movs	r2, #0
 8000aee:	61da      	str	r2, [r3, #28]
  hi2s3.Init.FullDuplexMode = I2S_FULLDUPLEXMODE_ENABLE;
 8000af0:	f240 43fc 	movw	r3, #1276	; 0x4fc
 8000af4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000af8:	2201      	movs	r2, #1
 8000afa:	621a      	str	r2, [r3, #32]
  HAL_I2S_Init(&hi2s3);
 8000afc:	f240 40fc 	movw	r0, #1276	; 0x4fc
 8000b00:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000b04:	f005 fbfc 	bl	8006300 <HAL_I2S_Init>

}
 8000b08:	bd80      	pop	{r7, pc}
 8000b0a:	bf00      	nop

08000b0c <HAL_I2S_MspInit>:

void HAL_I2S_MspInit(I2S_HandleTypeDef* hi2s)
{
 8000b0c:	b580      	push	{r7, lr}
 8000b0e:	b088      	sub	sp, #32
 8000b10:	af00      	add	r7, sp, #0
 8000b12:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hi2s->Instance==SPI3)
 8000b14:	687b      	ldr	r3, [r7, #4]
 8000b16:	681a      	ldr	r2, [r3, #0]
 8000b18:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8000b1c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8000b20:	429a      	cmp	r2, r3
 8000b22:	f040 80fb 	bne.w	8000d1c <HAL_I2S_MspInit+0x210>
  {
  /* USER CODE BEGIN SPI3_MspInit 0 */

  /* USER CODE END SPI3_MspInit 0 */
    /* Peripheral clock enable */
    __SPI3_CLK_ENABLE();
 8000b26:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000b2a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000b2e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000b32:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000b36:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8000b38:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8000b3c:	641a      	str	r2, [r3, #64]	; 0x40
 8000b3e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000b42:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000b46:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000b48:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8000b4c:	60bb      	str	r3, [r7, #8]
 8000b4e:	68bb      	ldr	r3, [r7, #8]
    PA15     ------> I2S3_WS
    PC10     ------> I2S3_CK
    PC11     ------> I2S3_ext_SD
    PC12     ------> I2S3_SD 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_10|GPIO_PIN_12;
 8000b50:	f44f 53a4 	mov.w	r3, #5248	; 0x1480
 8000b54:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000b56:	2302      	movs	r3, #2
 8000b58:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000b5a:	2300      	movs	r3, #0
 8000b5c:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 8000b5e:	2300      	movs	r3, #0
 8000b60:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 8000b62:	2306      	movs	r3, #6
 8000b64:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000b66:	f107 030c 	add.w	r3, r7, #12
 8000b6a:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8000b6e:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000b72:	4619      	mov	r1, r3
 8000b74:	f004 f898 	bl	8004ca8 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_15;
 8000b78:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8000b7c:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000b7e:	2302      	movs	r3, #2
 8000b80:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000b82:	2300      	movs	r3, #0
 8000b84:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 8000b86:	2300      	movs	r3, #0
 8000b88:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 8000b8a:	2306      	movs	r3, #6
 8000b8c:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000b8e:	f107 030c 	add.w	r3, r7, #12
 8000b92:	2000      	movs	r0, #0
 8000b94:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000b98:	4619      	mov	r1, r3
 8000b9a:	f004 f885 	bl	8004ca8 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_11;
 8000b9e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8000ba2:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000ba4:	2302      	movs	r3, #2
 8000ba6:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000ba8:	2300      	movs	r3, #0
 8000baa:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 8000bac:	2300      	movs	r3, #0
 8000bae:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF5_I2S3ext;
 8000bb0:	2305      	movs	r3, #5
 8000bb2:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000bb4:	f107 030c 	add.w	r3, r7, #12
 8000bb8:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8000bbc:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000bc0:	4619      	mov	r1, r3
 8000bc2:	f004 f871 	bl	8004ca8 <HAL_GPIO_Init>

    /* Peripheral DMA init*/
  
    hdma_i2s3_ext_tx.Instance = DMA1_Stream5;
 8000bc6:	f240 5340 	movw	r3, #1344	; 0x540
 8000bca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000bce:	f246 0288 	movw	r2, #24712	; 0x6088
 8000bd2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000bd6:	601a      	str	r2, [r3, #0]
    hdma_i2s3_ext_tx.Init.Channel = DMA_CHANNEL_2;
 8000bd8:	f240 5340 	movw	r3, #1344	; 0x540
 8000bdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000be0:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 8000be4:	605a      	str	r2, [r3, #4]
    hdma_i2s3_ext_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8000be6:	f240 5340 	movw	r3, #1344	; 0x540
 8000bea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000bee:	2240      	movs	r2, #64	; 0x40
 8000bf0:	609a      	str	r2, [r3, #8]
    hdma_i2s3_ext_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8000bf2:	f240 5340 	movw	r3, #1344	; 0x540
 8000bf6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000bfa:	2200      	movs	r2, #0
 8000bfc:	60da      	str	r2, [r3, #12]
    hdma_i2s3_ext_tx.Init.MemInc = DMA_MINC_ENABLE;
 8000bfe:	f240 5340 	movw	r3, #1344	; 0x540
 8000c02:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c06:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8000c0a:	611a      	str	r2, [r3, #16]
    hdma_i2s3_ext_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 8000c0c:	f240 5340 	movw	r3, #1344	; 0x540
 8000c10:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c14:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8000c18:	615a      	str	r2, [r3, #20]
    hdma_i2s3_ext_tx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 8000c1a:	f240 5340 	movw	r3, #1344	; 0x540
 8000c1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c22:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8000c26:	619a      	str	r2, [r3, #24]
    hdma_i2s3_ext_tx.Init.Mode = DMA_CIRCULAR;
 8000c28:	f240 5340 	movw	r3, #1344	; 0x540
 8000c2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c30:	f44f 7280 	mov.w	r2, #256	; 0x100
 8000c34:	61da      	str	r2, [r3, #28]
    hdma_i2s3_ext_tx.Init.Priority = DMA_PRIORITY_LOW;
 8000c36:	f240 5340 	movw	r3, #1344	; 0x540
 8000c3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c3e:	2200      	movs	r2, #0
 8000c40:	621a      	str	r2, [r3, #32]
    hdma_i2s3_ext_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8000c42:	f240 5340 	movw	r3, #1344	; 0x540
 8000c46:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c4a:	2200      	movs	r2, #0
 8000c4c:	625a      	str	r2, [r3, #36]	; 0x24
    HAL_DMA_Init(&hdma_i2s3_ext_tx);
 8000c4e:	f240 5040 	movw	r0, #1344	; 0x540
 8000c52:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000c56:	f003 fbb9 	bl	80043cc <HAL_DMA_Init>

    __HAL_LINKDMA(hi2s,hdmatx,hdma_i2s3_ext_tx);
 8000c5a:	687a      	ldr	r2, [r7, #4]
 8000c5c:	f240 5340 	movw	r3, #1344	; 0x540
 8000c60:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c64:	6353      	str	r3, [r2, #52]	; 0x34
 8000c66:	f240 5340 	movw	r3, #1344	; 0x540
 8000c6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c6e:	687a      	ldr	r2, [r7, #4]
 8000c70:	639a      	str	r2, [r3, #56]	; 0x38

    hdma_spi3_rx.Instance = DMA1_Stream0;
 8000c72:	f240 5398 	movw	r3, #1432	; 0x598
 8000c76:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c7a:	f246 0210 	movw	r2, #24592	; 0x6010
 8000c7e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000c82:	601a      	str	r2, [r3, #0]
    hdma_spi3_rx.Init.Channel = DMA_CHANNEL_0;
 8000c84:	f240 5398 	movw	r3, #1432	; 0x598
 8000c88:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c8c:	2200      	movs	r2, #0
 8000c8e:	605a      	str	r2, [r3, #4]
    hdma_spi3_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8000c90:	f240 5398 	movw	r3, #1432	; 0x598
 8000c94:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c98:	2200      	movs	r2, #0
 8000c9a:	609a      	str	r2, [r3, #8]
    hdma_spi3_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8000c9c:	f240 5398 	movw	r3, #1432	; 0x598
 8000ca0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ca4:	2200      	movs	r2, #0
 8000ca6:	60da      	str	r2, [r3, #12]
    hdma_spi3_rx.Init.MemInc = DMA_MINC_ENABLE;
 8000ca8:	f240 5398 	movw	r3, #1432	; 0x598
 8000cac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000cb0:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8000cb4:	611a      	str	r2, [r3, #16]
    hdma_spi3_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 8000cb6:	f240 5398 	movw	r3, #1432	; 0x598
 8000cba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000cbe:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8000cc2:	615a      	str	r2, [r3, #20]
    hdma_spi3_rx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 8000cc4:	f240 5398 	movw	r3, #1432	; 0x598
 8000cc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ccc:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8000cd0:	619a      	str	r2, [r3, #24]
    hdma_spi3_rx.Init.Mode = DMA_CIRCULAR;
 8000cd2:	f240 5398 	movw	r3, #1432	; 0x598
 8000cd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000cda:	f44f 7280 	mov.w	r2, #256	; 0x100
 8000cde:	61da      	str	r2, [r3, #28]
    hdma_spi3_rx.Init.Priority = DMA_PRIORITY_LOW;
 8000ce0:	f240 5398 	movw	r3, #1432	; 0x598
 8000ce4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ce8:	2200      	movs	r2, #0
 8000cea:	621a      	str	r2, [r3, #32]
    hdma_spi3_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8000cec:	f240 5398 	movw	r3, #1432	; 0x598
 8000cf0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000cf4:	2200      	movs	r2, #0
 8000cf6:	625a      	str	r2, [r3, #36]	; 0x24
    HAL_DMA_Init(&hdma_spi3_rx);
 8000cf8:	f240 5098 	movw	r0, #1432	; 0x598
 8000cfc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000d00:	f003 fb64 	bl	80043cc <HAL_DMA_Init>

    __HAL_LINKDMA(hi2s,hdmarx,hdma_spi3_rx);
 8000d04:	687a      	ldr	r2, [r7, #4]
 8000d06:	f240 5398 	movw	r3, #1432	; 0x598
 8000d0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000d0e:	6393      	str	r3, [r2, #56]	; 0x38
 8000d10:	f240 5398 	movw	r3, #1432	; 0x598
 8000d14:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000d18:	687a      	ldr	r2, [r7, #4]
 8000d1a:	639a      	str	r2, [r3, #56]	; 0x38

  /* USER CODE BEGIN SPI3_MspInit 1 */

  /* USER CODE END SPI3_MspInit 1 */
  }
}
 8000d1c:	3720      	adds	r7, #32
 8000d1e:	46bd      	mov	sp, r7
 8000d20:	bd80      	pop	{r7, pc}
 8000d22:	bf00      	nop

08000d24 <HAL_I2S_MspDeInit>:

void HAL_I2S_MspDeInit(I2S_HandleTypeDef* hi2s)
{
 8000d24:	b580      	push	{r7, lr}
 8000d26:	b082      	sub	sp, #8
 8000d28:	af00      	add	r7, sp, #0
 8000d2a:	6078      	str	r0, [r7, #4]

  if(hi2s->Instance==SPI3)
 8000d2c:	687b      	ldr	r3, [r7, #4]
 8000d2e:	681a      	ldr	r2, [r3, #0]
 8000d30:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8000d34:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8000d38:	429a      	cmp	r2, r3
 8000d3a:	d124      	bne.n	8000d86 <HAL_I2S_MspDeInit+0x62>
  {
  /* USER CODE BEGIN SPI3_MspDeInit 0 */

  /* USER CODE END SPI3_MspDeInit 0 */
    /* Peripheral clock disable */
    __SPI3_CLK_DISABLE();
 8000d3c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000d40:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000d44:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000d48:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000d4c:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8000d4e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8000d52:	641a      	str	r2, [r3, #64]	; 0x40
    PA15     ------> I2S3_WS
    PC10     ------> I2S3_CK
    PC11     ------> I2S3_ext_SD
    PC12     ------> I2S3_SD 
    */
    HAL_GPIO_DeInit(GPIOC, GPIO_PIN_7|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12);
 8000d54:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8000d58:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000d5c:	f44f 51e4 	mov.w	r1, #7296	; 0x1c80
 8000d60:	f004 f96a 	bl	8005038 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_15);
 8000d64:	2000      	movs	r0, #0
 8000d66:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000d6a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8000d6e:	f004 f963 	bl	8005038 <HAL_GPIO_DeInit>

    /* Peripheral DMA DeInit*/
    HAL_DMA_DeInit(hi2s->hdmatx);
 8000d72:	687b      	ldr	r3, [r7, #4]
 8000d74:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8000d76:	4618      	mov	r0, r3
 8000d78:	f003 fb96 	bl	80044a8 <HAL_DMA_DeInit>
    HAL_DMA_DeInit(hi2s->hdmarx);
 8000d7c:	687b      	ldr	r3, [r7, #4]
 8000d7e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000d80:	4618      	mov	r0, r3
 8000d82:	f003 fb91 	bl	80044a8 <HAL_DMA_DeInit>
  }
  /* USER CODE BEGIN SPI3_MspDeInit 1 */

  /* USER CODE END SPI3_MspDeInit 1 */
} 
 8000d86:	3708      	adds	r7, #8
 8000d88:	46bd      	mov	sp, r7
 8000d8a:	bd80      	pop	{r7, pc}

08000d8c <HardFault_Handler>:
static void HardFault_Handler( void ) __attribute__( ( naked ) );
void prvGetRegistersFromStack( uint32_t * );

static void HardFault_Handler(void)
{
    __asm volatile
 8000d8c:	f01e 0f04 	tst.w	lr, #4
 8000d90:	bf0c      	ite	eq
 8000d92:	f3ef 8008 	mrseq	r0, MSP
 8000d96:	f3ef 8009 	mrsne	r0, PSP
 8000d9a:	6981      	ldr	r1, [r0, #24]
 8000d9c:	4a00      	ldr	r2, [pc, #0]	; (8000da0 <handler2_address_const>)
 8000d9e:	4710      	bx	r2

08000da0 <handler2_address_const>:
 8000da0:	08000da5 	.word	0x08000da5

08000da4 <prvGetRegistersFromStack>:
        " handler2_address_const: .word prvGetRegistersFromStack    \n"
    );
}

void prvGetRegistersFromStack( uint32_t *pulFaultStackAddress )
{
 8000da4:	b480      	push	{r7}
 8000da6:	b08b      	sub	sp, #44	; 0x2c
 8000da8:	af00      	add	r7, sp, #0
 8000daa:	6078      	str	r0, [r7, #4]
volatile uint32_t r12;
volatile uint32_t lr; /* Link register. */
volatile uint32_t pc; /* Program counter. */
volatile uint32_t psr;/* Program status register. */

    r0 = pulFaultStackAddress[ 0 ];
 8000dac:	687b      	ldr	r3, [r7, #4]
 8000dae:	681b      	ldr	r3, [r3, #0]
 8000db0:	627b      	str	r3, [r7, #36]	; 0x24
    r1 = pulFaultStackAddress[ 1 ];
 8000db2:	687b      	ldr	r3, [r7, #4]
 8000db4:	685b      	ldr	r3, [r3, #4]
 8000db6:	623b      	str	r3, [r7, #32]
    r2 = pulFaultStackAddress[ 2 ];
 8000db8:	687b      	ldr	r3, [r7, #4]
 8000dba:	689b      	ldr	r3, [r3, #8]
 8000dbc:	61fb      	str	r3, [r7, #28]
    r3 = pulFaultStackAddress[ 3 ];
 8000dbe:	687b      	ldr	r3, [r7, #4]
 8000dc0:	68db      	ldr	r3, [r3, #12]
 8000dc2:	61bb      	str	r3, [r7, #24]

    r12 = pulFaultStackAddress[ 4 ];
 8000dc4:	687b      	ldr	r3, [r7, #4]
 8000dc6:	691b      	ldr	r3, [r3, #16]
 8000dc8:	617b      	str	r3, [r7, #20]
    lr = pulFaultStackAddress[ 5 ];
 8000dca:	687b      	ldr	r3, [r7, #4]
 8000dcc:	695b      	ldr	r3, [r3, #20]
 8000dce:	613b      	str	r3, [r7, #16]
    pc = pulFaultStackAddress[ 6 ];
 8000dd0:	687b      	ldr	r3, [r7, #4]
 8000dd2:	699b      	ldr	r3, [r3, #24]
 8000dd4:	60fb      	str	r3, [r7, #12]
    psr = pulFaultStackAddress[ 7 ];
 8000dd6:	687b      	ldr	r3, [r7, #4]
 8000dd8:	69db      	ldr	r3, [r3, #28]
 8000dda:	60bb      	str	r3, [r7, #8]

    /* When the following line is hit, the variables contain the register values. */
    for( ;; );
 8000ddc:	e7fe      	b.n	8000ddc <prvGetRegistersFromStack+0x38>
 8000dde:	bf00      	nop

08000de0 <main>:
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

int main(void)
{
 8000de0:	b580      	push	{r7, lr}
 8000de2:	f6ad 0d28 	subw	sp, sp, #2088	; 0x828
 8000de6:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN 1 */
  //clear the DMA buffers
  uint32_t j = 0;
 8000de8:	2300      	movs	r3, #0
 8000dea:	f8c7 3824 	str.w	r3, [r7, #2084]	; 0x824
  for(j = 0; j < AUDIO_BLOCK_SIZE*2; j++){
 8000dee:	2300      	movs	r3, #0
 8000df0:	f8c7 3824 	str.w	r3, [r7, #2084]	; 0x824
 8000df4:	e016      	b.n	8000e24 <main+0x44>
    codec_tx_buffer_a[j] = 0;
 8000df6:	f640 13f0 	movw	r3, #2544	; 0x9f0
 8000dfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000dfe:	f8d7 2824 	ldr.w	r2, [r7, #2084]	; 0x824
 8000e02:	2100      	movs	r1, #0
 8000e04:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
    codec_rx_buffer_a[j] = 0;
 8000e08:	f240 53f0 	movw	r3, #1520	; 0x5f0
 8000e0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000e10:	f8d7 2824 	ldr.w	r2, [r7, #2084]	; 0x824
 8000e14:	2100      	movs	r1, #0
 8000e16:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
{

  /* USER CODE BEGIN 1 */
  //clear the DMA buffers
  uint32_t j = 0;
  for(j = 0; j < AUDIO_BLOCK_SIZE*2; j++){
 8000e1a:	f8d7 3824 	ldr.w	r3, [r7, #2084]	; 0x824
 8000e1e:	3301      	adds	r3, #1
 8000e20:	f8c7 3824 	str.w	r3, [r7, #2084]	; 0x824
 8000e24:	f8d7 3824 	ldr.w	r3, [r7, #2084]	; 0x824
 8000e28:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8000e2c:	d3e3      	bcc.n	8000df6 <main+0x16>
  /* USER CODE END 1 */

  /* MCU Configuration----------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8000e2e:	f000 fd17 	bl	8001860 <HAL_Init>

  /* Configure the system clock */
  SystemClock_Config();
 8000e32:	f000 f925 	bl	8001080 <SystemClock_Config>


  
  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8000e36:	f7ff fcf9 	bl	800082c <MX_GPIO_Init>
  MX_DMA_Init();  //
 8000e3a:	f7ff fcaf 	bl	800079c <MX_DMA_Init>
  MX_ADC3_Init(); //wah pot input
 8000e3e:	f7ff fb0b 	bl	8000458 <MX_ADC3_Init>
  MX_DAC_Init();  //cv outs
 8000e42:	f7ff fc2b 	bl	800069c <MX_DAC_Init>
  MX_I2S3_Init(); //i2s codec
 8000e46:	f7ff fe1b 	bl	8000a80 <MX_I2S3_Init>
  MX_SPI2_Init(); //spi codec
 8000e4a:	f000 f9fb 	bl	8001244 <MX_SPI2_Init>

  /* USER CODE BEGIN 2 */
  codec_init( & hspi2 );  
 8000e4e:	f640 601c 	movw	r0, #3612	; 0xe1c
 8000e52:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000e56:	f000 fb95 	bl	8001584 <codec_init>
  HAL_SuspendTick(); 
 8000e5a:	f000 fdd7 	bl	8001a0c <HAL_SuspendTick>
  HAL_I2SEx_TransmitReceive_DMA(&hi2s3, (uint16_t *)codec_tx_buffer_a, (uint16_t *)codec_rx_buffer_a, AUDIO_BLOCK_SIZE * 2);
 8000e5e:	f240 40fc 	movw	r0, #1276	; 0x4fc
 8000e62:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000e66:	f640 11f0 	movw	r1, #2544	; 0x9f0
 8000e6a:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000e6e:	f240 52f0 	movw	r2, #1520	; 0x5f0
 8000e72:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8000e76:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000e7a:	f005 fed3 	bl	8006c24 <HAL_I2SEx_TransmitReceive_DMA>

  float input_block[AUDIO_BLOCK_SIZE];
  float output_block[AUDIO_BLOCK_SIZE];
  uint32_t start_a, end_a = 0;
 8000e7e:	2300      	movs	r3, #0
 8000e80:	f8c7 381c 	str.w	r3, [r7, #2076]	; 0x81c
  uint32_t frame_number = 0;
 8000e84:	2300      	movs	r3, #0
 8000e86:	f8c7 3820 	str.w	r3, [r7, #2080]	; 0x820

  float amplitude = 0;
 8000e8a:	f04f 0300 	mov.w	r3, #0
 8000e8e:	f607 0218 	addw	r2, r7, #2072	; 0x818
 8000e92:	6013      	str	r3, [r2, #0]
  float amplitude_delta = .1;
 8000e94:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 8000e98:	f6c3 53cc 	movt	r3, #15820	; 0x3dcc
 8000e9c:	f607 0214 	addw	r2, r7, #2068	; 0x814
 8000ea0:	6013      	str	r3, [r2, #0]
  float amplitude_max = 1;
 8000ea2:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8000ea6:	f507 6201 	add.w	r2, r7, #2064	; 0x810
 8000eaa:	6013      	str	r3, [r2, #0]
  uint32_t lfo_t = 0;
 8000eac:	2300      	movs	r3, #0
 8000eae:	f8c7 380c 	str.w	r3, [r7, #2060]	; 0x80c
  uint32_t lfo_T = 100;
 8000eb2:	2364      	movs	r3, #100	; 0x64
 8000eb4:	f8c7 3808 	str.w	r3, [r7, #2056]	; 0x808


  /* USER CODE END 2 */


  patch = tremolo_one;
 8000eb8:	f640 6308 	movw	r3, #3592	; 0xe08
 8000ebc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ec0:	f241 4211 	movw	r2, #5137	; 0x1411
 8000ec4:	f6c0 0200 	movt	r2, #2048	; 0x800
 8000ec8:	601a      	str	r2, [r3, #0]
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    while(block_tick){};
 8000eca:	bf00      	nop
 8000ecc:	f640 6300 	movw	r3, #3584	; 0xe00
 8000ed0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ed4:	681b      	ldr	r3, [r3, #0]
 8000ed6:	2b00      	cmp	r3, #0
 8000ed8:	d1f8      	bne.n	8000ecc <main+0xec>
    block_tick = 1;
 8000eda:	f640 6300 	movw	r3, #3584	; 0xe00
 8000ede:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ee2:	2201      	movs	r2, #1
 8000ee4:	601a      	str	r2, [r3, #0]
    if(block_half){//use second half 
 8000ee6:	f640 6304 	movw	r3, #3588	; 0xe04
 8000eea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000eee:	681b      	ldr	r3, [r3, #0]
 8000ef0:	2b00      	cmp	r3, #0
 8000ef2:	d05a      	beq.n	8000faa <main+0x1ca>
      start_a = AUDIO_BLOCK_SIZE;
 8000ef4:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000ef8:	f8c7 3804 	str.w	r3, [r7, #2052]	; 0x804
      end_a = AUDIO_BLOCK_SIZE * 2;
 8000efc:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000f00:	f8c7 381c 	str.w	r3, [r7, #2076]	; 0x81c
      for(j= start_a; j < end_a; j++){
 8000f04:	f8d7 3804 	ldr.w	r3, [r7, #2052]	; 0x804
 8000f08:	f8c7 3824 	str.w	r3, [r7, #2084]	; 0x824
 8000f0c:	e046      	b.n	8000f9c <main+0x1bc>
        input_block[j - AUDIO_BLOCK_SIZE] = (float)codec_rx_buffer_a[j] / 32768.0;
 8000f0e:	f8d7 3824 	ldr.w	r3, [r7, #2084]	; 0x824
 8000f12:	f5a3 7180 	sub.w	r1, r3, #256	; 0x100
 8000f16:	f240 53f0 	movw	r3, #1520	; 0x5f0
 8000f1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000f1e:	f8d7 2824 	ldr.w	r2, [r7, #2084]	; 0x824
 8000f22:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8000f26:	b21b      	sxth	r3, r3
 8000f28:	ee07 3a90 	vmov	s15, r3
 8000f2c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8000f30:	eddf 7a52 	vldr	s15, [pc, #328]	; 800107c <main+0x29c>
 8000f34:	eec7 7a27 	vdiv.f32	s15, s14, s15
 8000f38:	f207 4204 	addw	r2, r7, #1028	; 0x404
 8000f3c:	008b      	lsls	r3, r1, #2
 8000f3e:	4413      	add	r3, r2
 8000f40:	edc3 7a00 	vstr	s15, [r3]
        codec_tx_buffer_a[j] = (int16_t)(output_block[j - AUDIO_BLOCK_SIZE] * 32768.0); 
 8000f44:	f8d7 3824 	ldr.w	r3, [r7, #2084]	; 0x824
 8000f48:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 8000f4c:	1d3a      	adds	r2, r7, #4
 8000f4e:	009b      	lsls	r3, r3, #2
 8000f50:	4413      	add	r3, r2
 8000f52:	681b      	ldr	r3, [r3, #0]
 8000f54:	4618      	mov	r0, r3
 8000f56:	f00a f9c7 	bl	800b2e8 <__aeabi_f2d>
 8000f5a:	4602      	mov	r2, r0
 8000f5c:	460b      	mov	r3, r1
 8000f5e:	4610      	mov	r0, r2
 8000f60:	4619      	mov	r1, r3
 8000f62:	f04f 0200 	mov.w	r2, #0
 8000f66:	f04f 0300 	mov.w	r3, #0
 8000f6a:	f2c4 03e0 	movt	r3, #16608	; 0x40e0
 8000f6e:	f00a fa0f 	bl	800b390 <__aeabi_dmul>
 8000f72:	4602      	mov	r2, r0
 8000f74:	460b      	mov	r3, r1
 8000f76:	4610      	mov	r0, r2
 8000f78:	4619      	mov	r1, r3
 8000f7a:	f00a fc1b 	bl	800b7b4 <__aeabi_d2iz>
 8000f7e:	4603      	mov	r3, r0
 8000f80:	b299      	uxth	r1, r3
 8000f82:	f640 13f0 	movw	r3, #2544	; 0x9f0
 8000f86:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000f8a:	f8d7 2824 	ldr.w	r2, [r7, #2084]	; 0x824
 8000f8e:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
    while(block_tick){};
    block_tick = 1;
    if(block_half){//use second half 
      start_a = AUDIO_BLOCK_SIZE;
      end_a = AUDIO_BLOCK_SIZE * 2;
      for(j= start_a; j < end_a; j++){
 8000f92:	f8d7 3824 	ldr.w	r3, [r7, #2084]	; 0x824
 8000f96:	3301      	adds	r3, #1
 8000f98:	f8c7 3824 	str.w	r3, [r7, #2084]	; 0x824
 8000f9c:	f8d7 2824 	ldr.w	r2, [r7, #2084]	; 0x824
 8000fa0:	f8d7 381c 	ldr.w	r3, [r7, #2076]	; 0x81c
 8000fa4:	429a      	cmp	r2, r3
 8000fa6:	d3b2      	bcc.n	8000f0e <main+0x12e>
 8000fa8:	e054      	b.n	8001054 <main+0x274>
        input_block[j - AUDIO_BLOCK_SIZE] = (float)codec_rx_buffer_a[j] / 32768.0;
        codec_tx_buffer_a[j] = (int16_t)(output_block[j - AUDIO_BLOCK_SIZE] * 32768.0); 
      }
    }else{//use first half
      start_a = 0;
 8000faa:	2300      	movs	r3, #0
 8000fac:	f8c7 3804 	str.w	r3, [r7, #2052]	; 0x804
      end_a = AUDIO_BLOCK_SIZE;
 8000fb0:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000fb4:	f8c7 381c 	str.w	r3, [r7, #2076]	; 0x81c
      for(j= start_a; j < end_a; j++){
 8000fb8:	f8d7 3804 	ldr.w	r3, [r7, #2052]	; 0x804
 8000fbc:	f8c7 3824 	str.w	r3, [r7, #2084]	; 0x824
 8000fc0:	e042      	b.n	8001048 <main+0x268>
        input_block[j] = (float)codec_rx_buffer_a[j] / 32768.0;
 8000fc2:	f240 53f0 	movw	r3, #1520	; 0x5f0
 8000fc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000fca:	f8d7 2824 	ldr.w	r2, [r7, #2084]	; 0x824
 8000fce:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8000fd2:	b21b      	sxth	r3, r3
 8000fd4:	ee07 3a90 	vmov	s15, r3
 8000fd8:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8000fdc:	eddf 7a27 	vldr	s15, [pc, #156]	; 800107c <main+0x29c>
 8000fe0:	eec7 7a27 	vdiv.f32	s15, s14, s15
 8000fe4:	f207 4204 	addw	r2, r7, #1028	; 0x404
 8000fe8:	f8d7 3824 	ldr.w	r3, [r7, #2084]	; 0x824
 8000fec:	009b      	lsls	r3, r3, #2
 8000fee:	4413      	add	r3, r2
 8000ff0:	edc3 7a00 	vstr	s15, [r3]
        codec_tx_buffer_a[j] = (int16_t)(output_block[j] * 32768.0); 
 8000ff4:	1d3a      	adds	r2, r7, #4
 8000ff6:	f8d7 3824 	ldr.w	r3, [r7, #2084]	; 0x824
 8000ffa:	009b      	lsls	r3, r3, #2
 8000ffc:	4413      	add	r3, r2
 8000ffe:	681b      	ldr	r3, [r3, #0]
 8001000:	4618      	mov	r0, r3
 8001002:	f00a f971 	bl	800b2e8 <__aeabi_f2d>
 8001006:	4602      	mov	r2, r0
 8001008:	460b      	mov	r3, r1
 800100a:	4610      	mov	r0, r2
 800100c:	4619      	mov	r1, r3
 800100e:	f04f 0200 	mov.w	r2, #0
 8001012:	f04f 0300 	mov.w	r3, #0
 8001016:	f2c4 03e0 	movt	r3, #16608	; 0x40e0
 800101a:	f00a f9b9 	bl	800b390 <__aeabi_dmul>
 800101e:	4602      	mov	r2, r0
 8001020:	460b      	mov	r3, r1
 8001022:	4610      	mov	r0, r2
 8001024:	4619      	mov	r1, r3
 8001026:	f00a fbc5 	bl	800b7b4 <__aeabi_d2iz>
 800102a:	4603      	mov	r3, r0
 800102c:	b299      	uxth	r1, r3
 800102e:	f640 13f0 	movw	r3, #2544	; 0x9f0
 8001032:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001036:	f8d7 2824 	ldr.w	r2, [r7, #2084]	; 0x824
 800103a:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        codec_tx_buffer_a[j] = (int16_t)(output_block[j - AUDIO_BLOCK_SIZE] * 32768.0); 
      }
    }else{//use first half
      start_a = 0;
      end_a = AUDIO_BLOCK_SIZE;
      for(j= start_a; j < end_a; j++){
 800103e:	f8d7 3824 	ldr.w	r3, [r7, #2084]	; 0x824
 8001042:	3301      	adds	r3, #1
 8001044:	f8c7 3824 	str.w	r3, [r7, #2084]	; 0x824
 8001048:	f8d7 2824 	ldr.w	r2, [r7, #2084]	; 0x824
 800104c:	f8d7 381c 	ldr.w	r3, [r7, #2076]	; 0x81c
 8001050:	429a      	cmp	r2, r3
 8001052:	d3b6      	bcc.n	8000fc2 <main+0x1e2>
    //simple loop through
    // for( j = 0; j < AUDIO_BLOCK_SIZE; j++){
    //   output_block[j] = input_block[j];
    // }

    patch(input_block,output_block, AUDIO_BLOCK_SIZE);
 8001054:	f640 6308 	movw	r3, #3592	; 0xe08
 8001058:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800105c:	681b      	ldr	r3, [r3, #0]
 800105e:	f207 4104 	addw	r1, r7, #1028	; 0x404
 8001062:	1d3a      	adds	r2, r7, #4
 8001064:	4608      	mov	r0, r1
 8001066:	4611      	mov	r1, r2
 8001068:	f44f 7280 	mov.w	r2, #256	; 0x100
 800106c:	4798      	blx	r3

    frame_number++;
 800106e:	f8d7 3820 	ldr.w	r3, [r7, #2080]	; 0x820
 8001072:	3301      	adds	r3, #1
 8001074:	f8c7 3820 	str.w	r3, [r7, #2080]	; 0x820

  }
 8001078:	bf00      	nop
  patch = tremolo_one;
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    while(block_tick){};
 800107a:	e726      	b.n	8000eca <main+0xea>
 800107c:	47000000 	.word	0x47000000

08001080 <SystemClock_Config>:
}

/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 8001080:	b580      	push	{r7, lr}
 8001082:	b098      	sub	sp, #96	; 0x60
 8001084:	af00      	add	r7, sp, #0

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;

  __PWR_CLK_ENABLE();
 8001086:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800108a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800108e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001092:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001096:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8001098:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800109c:	641a      	str	r2, [r3, #64]	; 0x40
 800109e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80010a2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80010a6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80010a8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80010ac:	60bb      	str	r3, [r7, #8]
 80010ae:	68bb      	ldr	r3, [r7, #8]

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80010b0:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 80010b4:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80010b8:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 80010bc:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80010c0:	6812      	ldr	r2, [r2, #0]
 80010c2:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80010c6:	601a      	str	r2, [r3, #0]
 80010c8:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 80010cc:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80010d0:	681b      	ldr	r3, [r3, #0]
 80010d2:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80010d6:	607b      	str	r3, [r7, #4]
 80010d8:	687b      	ldr	r3, [r7, #4]

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80010da:	2301      	movs	r3, #1
 80010dc:	633b      	str	r3, [r7, #48]	; 0x30
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 80010de:	2301      	movs	r3, #1
 80010e0:	637b      	str	r3, [r7, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80010e2:	2302      	movs	r3, #2
 80010e4:	64bb      	str	r3, [r7, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80010e6:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 80010ea:	64fb      	str	r3, [r7, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLM = 8;
 80010ec:	2308      	movs	r3, #8
 80010ee:	653b      	str	r3, [r7, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLN = 336;
 80010f0:	f44f 73a8 	mov.w	r3, #336	; 0x150
 80010f4:	657b      	str	r3, [r7, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 80010f6:	2302      	movs	r3, #2
 80010f8:	65bb      	str	r3, [r7, #88]	; 0x58
  RCC_OscInitStruct.PLL.PLLQ = 4;
 80010fa:	2304      	movs	r3, #4
 80010fc:	65fb      	str	r3, [r7, #92]	; 0x5c
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 80010fe:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8001102:	4618      	mov	r0, r3
 8001104:	f006 feb0 	bl	8007e68 <HAL_RCC_OscConfig>

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
 8001108:	230d      	movs	r3, #13
 800110a:	61fb      	str	r3, [r7, #28]
                              |RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800110c:	2302      	movs	r3, #2
 800110e:	623b      	str	r3, [r7, #32]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8001110:	2300      	movs	r3, #0
 8001112:	627b      	str	r3, [r7, #36]	; 0x24
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8001114:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8001118:	62bb      	str	r3, [r7, #40]	; 0x28
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 800111a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800111e:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
 8001120:	f107 031c 	add.w	r3, r7, #28
 8001124:	4618      	mov	r0, r3
 8001126:	2105      	movs	r1, #5
 8001128:	f007 f954 	bl	80083d4 <HAL_RCC_ClockConfig>

  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2S;
 800112c:	2301      	movs	r3, #1
 800112e:	60fb      	str	r3, [r7, #12]
  PeriphClkInitStruct.PLLI2S.PLLI2SN = 192;
 8001130:	23c0      	movs	r3, #192	; 0xc0
 8001132:	613b      	str	r3, [r7, #16]
  PeriphClkInitStruct.PLLI2S.PLLI2SR = 2;
 8001134:	2302      	movs	r3, #2
 8001136:	617b      	str	r3, [r7, #20]
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
 8001138:	f107 030c 	add.w	r3, r7, #12
 800113c:	4618      	mov	r0, r3
 800113e:	f007 fe67 	bl	8008e10 <HAL_RCCEx_PeriphCLKConfig>

  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8001142:	f007 fc5b 	bl	80089fc <HAL_RCC_GetHCLKFreq>
 8001146:	4602      	mov	r2, r0
 8001148:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 800114c:	f2c1 0362 	movt	r3, #4194	; 0x1062
 8001150:	fba3 1302 	umull	r1, r3, r3, r2
 8001154:	099b      	lsrs	r3, r3, #6
 8001156:	4618      	mov	r0, r3
 8001158:	f002 fc2a 	bl	80039b0 <HAL_SYSTICK_Config>

  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 800115c:	2004      	movs	r0, #4
 800115e:	f002 fcdf 	bl	8003b20 <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8001162:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001166:	2100      	movs	r1, #0
 8001168:	2200      	movs	r2, #0
 800116a:	f002 fbe3 	bl	8003934 <HAL_NVIC_SetPriority>
}
 800116e:	3760      	adds	r7, #96	; 0x60
 8001170:	46bd      	mov	sp, r7
 8001172:	bd80      	pop	{r7, pc}

08001174 <HAL_I2S_TxCpltCallback>:

/* USER CODE BEGIN 4 */
uint32_t nt = 0;
void HAL_I2S_TxCpltCallback ( I2S_HandleTypeDef * hi2s){
 8001174:	b480      	push	{r7}
 8001176:	b083      	sub	sp, #12
 8001178:	af00      	add	r7, sp, #0
 800117a:	6078      	str	r0, [r7, #4]
 nt++;
 800117c:	f640 630c 	movw	r3, #3596	; 0xe0c
 8001180:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001184:	681b      	ldr	r3, [r3, #0]
 8001186:	1c5a      	adds	r2, r3, #1
 8001188:	f640 630c 	movw	r3, #3596	; 0xe0c
 800118c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001190:	601a      	str	r2, [r3, #0]

}
 8001192:	370c      	adds	r7, #12
 8001194:	46bd      	mov	sp, r7
 8001196:	f85d 7b04 	ldr.w	r7, [sp], #4
 800119a:	4770      	bx	lr

0800119c <HAL_I2S_RxCpltCallback>:
uint32_t nr = 0;
void HAL_I2S_RxCpltCallback ( I2S_HandleTypeDef * hi2s){ 
 800119c:	b480      	push	{r7}
 800119e:	b083      	sub	sp, #12
 80011a0:	af00      	add	r7, sp, #0
 80011a2:	6078      	str	r0, [r7, #4]
 nr++;
 80011a4:	f640 6310 	movw	r3, #3600	; 0xe10
 80011a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80011ac:	681b      	ldr	r3, [r3, #0]
 80011ae:	1c5a      	adds	r2, r3, #1
 80011b0:	f640 6310 	movw	r3, #3600	; 0xe10
 80011b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80011b8:	601a      	str	r2, [r3, #0]
  block_tick = 0;
 80011ba:	f640 6300 	movw	r3, #3584	; 0xe00
 80011be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80011c2:	2200      	movs	r2, #0
 80011c4:	601a      	str	r2, [r3, #0]
  block_half = 1;
 80011c6:	f640 6304 	movw	r3, #3588	; 0xe04
 80011ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80011ce:	2201      	movs	r2, #1
 80011d0:	601a      	str	r2, [r3, #0]
}
 80011d2:	370c      	adds	r7, #12
 80011d4:	46bd      	mov	sp, r7
 80011d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80011da:	4770      	bx	lr

080011dc <HAL_I2S_TxHalfCpltCallback>:

uint32_t nth = 0;
void HAL_I2S_TxHalfCpltCallback ( I2S_HandleTypeDef * hi2s){  
 80011dc:	b480      	push	{r7}
 80011de:	b083      	sub	sp, #12
 80011e0:	af00      	add	r7, sp, #0
 80011e2:	6078      	str	r0, [r7, #4]
  nth++;
 80011e4:	f640 6314 	movw	r3, #3604	; 0xe14
 80011e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80011ec:	681b      	ldr	r3, [r3, #0]
 80011ee:	1c5a      	adds	r2, r3, #1
 80011f0:	f640 6314 	movw	r3, #3604	; 0xe14
 80011f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80011f8:	601a      	str	r2, [r3, #0]

} 
 80011fa:	370c      	adds	r7, #12
 80011fc:	46bd      	mov	sp, r7
 80011fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001202:	4770      	bx	lr

08001204 <HAL_I2S_RxHalfCpltCallback>:

uint32_t nrh = 0;
void HAL_I2S_RxHalfCpltCallback ( I2S_HandleTypeDef * hi2s){
 8001204:	b480      	push	{r7}
 8001206:	b083      	sub	sp, #12
 8001208:	af00      	add	r7, sp, #0
 800120a:	6078      	str	r0, [r7, #4]
  nrh++;
 800120c:	f640 6318 	movw	r3, #3608	; 0xe18
 8001210:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001214:	681b      	ldr	r3, [r3, #0]
 8001216:	1c5a      	adds	r2, r3, #1
 8001218:	f640 6318 	movw	r3, #3608	; 0xe18
 800121c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001220:	601a      	str	r2, [r3, #0]
  block_tick = 0;
 8001222:	f640 6300 	movw	r3, #3584	; 0xe00
 8001226:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800122a:	2200      	movs	r2, #0
 800122c:	601a      	str	r2, [r3, #0]
  block_half = 0;
 800122e:	f640 6304 	movw	r3, #3588	; 0xe04
 8001232:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001236:	2200      	movs	r2, #0
 8001238:	601a      	str	r2, [r3, #0]
} 
 800123a:	370c      	adds	r7, #12
 800123c:	46bd      	mov	sp, r7
 800123e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001242:	4770      	bx	lr

08001244 <MX_SPI2_Init>:

SPI_HandleTypeDef hspi2;

/* SPI2 init function */
void MX_SPI2_Init(void)
{
 8001244:	b580      	push	{r7, lr}
 8001246:	af00      	add	r7, sp, #0

  hspi2.Instance = SPI2;
 8001248:	f640 631c 	movw	r3, #3612	; 0xe1c
 800124c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001250:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001254:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8001258:	601a      	str	r2, [r3, #0]
  hspi2.Init.Mode = SPI_MODE_MASTER;
 800125a:	f640 631c 	movw	r3, #3612	; 0xe1c
 800125e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001262:	f44f 7282 	mov.w	r2, #260	; 0x104
 8001266:	605a      	str	r2, [r3, #4]
  hspi2.Init.Direction = SPI_DIRECTION_1LINE;
 8001268:	f640 631c 	movw	r3, #3612	; 0xe1c
 800126c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001270:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8001274:	609a      	str	r2, [r3, #8]
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
 8001276:	f640 631c 	movw	r3, #3612	; 0xe1c
 800127a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800127e:	2200      	movs	r2, #0
 8001280:	60da      	str	r2, [r3, #12]
  hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
 8001282:	f640 631c 	movw	r3, #3612	; 0xe1c
 8001286:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800128a:	2200      	movs	r2, #0
 800128c:	611a      	str	r2, [r3, #16]
  hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
 800128e:	f640 631c 	movw	r3, #3612	; 0xe1c
 8001292:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001296:	2200      	movs	r2, #0
 8001298:	615a      	str	r2, [r3, #20]
  hspi2.Init.NSS = SPI_NSS_SOFT;
 800129a:	f640 631c 	movw	r3, #3612	; 0xe1c
 800129e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80012a2:	f44f 7200 	mov.w	r2, #512	; 0x200
 80012a6:	619a      	str	r2, [r3, #24]
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
 80012a8:	f640 631c 	movw	r3, #3612	; 0xe1c
 80012ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80012b0:	2210      	movs	r2, #16
 80012b2:	61da      	str	r2, [r3, #28]
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
 80012b4:	f640 631c 	movw	r3, #3612	; 0xe1c
 80012b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80012bc:	2200      	movs	r2, #0
 80012be:	621a      	str	r2, [r3, #32]
  hspi2.Init.TIMode = SPI_TIMODE_DISABLED;
 80012c0:	f640 631c 	movw	r3, #3612	; 0xe1c
 80012c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80012c8:	2200      	movs	r2, #0
 80012ca:	625a      	str	r2, [r3, #36]	; 0x24
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
 80012cc:	f640 631c 	movw	r3, #3612	; 0xe1c
 80012d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80012d4:	2200      	movs	r2, #0
 80012d6:	629a      	str	r2, [r3, #40]	; 0x28
  hspi2.Init.CRCPolynomial = 10;
 80012d8:	f640 631c 	movw	r3, #3612	; 0xe1c
 80012dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80012e0:	220a      	movs	r2, #10
 80012e2:	62da      	str	r2, [r3, #44]	; 0x2c
  HAL_SPI_Init(&hspi2);
 80012e4:	f640 601c 	movw	r0, #3612	; 0xe1c
 80012e8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80012ec:	f007 fefe 	bl	80090ec <HAL_SPI_Init>

}
 80012f0:	bd80      	pop	{r7, pc}
 80012f2:	bf00      	nop

080012f4 <HAL_SPI_MspInit>:

void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 80012f4:	b580      	push	{r7, lr}
 80012f6:	b088      	sub	sp, #32
 80012f8:	af00      	add	r7, sp, #0
 80012fa:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hspi->Instance==SPI2)
 80012fc:	687b      	ldr	r3, [r7, #4]
 80012fe:	681a      	ldr	r2, [r3, #0]
 8001300:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001304:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8001308:	429a      	cmp	r2, r3
 800130a:	d128      	bne.n	800135e <HAL_SPI_MspInit+0x6a>
  {
  /* USER CODE BEGIN SPI2_MspInit 0 */

  /* USER CODE END SPI2_MspInit 0 */
    /* Peripheral clock enable */
    __SPI2_CLK_ENABLE();
 800130c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001310:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001314:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001318:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800131c:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800131e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001322:	641a      	str	r2, [r3, #64]	; 0x40
 8001324:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001328:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800132c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800132e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8001332:	60bb      	str	r3, [r7, #8]
 8001334:	68bb      	ldr	r3, [r7, #8]
  
    /**SPI2 GPIO Configuration    
    PB10     ------> SPI2_SCK
    PB15     ------> SPI2_MOSI 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_15;
 8001336:	f44f 4304 	mov.w	r3, #33792	; 0x8400
 800133a:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800133c:	2302      	movs	r3, #2
 800133e:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001340:	2300      	movs	r3, #0
 8001342:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8001344:	2303      	movs	r3, #3
 8001346:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 8001348:	2305      	movs	r3, #5
 800134a:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800134c:	f107 030c 	add.w	r3, r7, #12
 8001350:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8001354:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8001358:	4619      	mov	r1, r3
 800135a:	f003 fca5 	bl	8004ca8 <HAL_GPIO_Init>

  /* USER CODE BEGIN SPI2_MspInit 1 */

  /* USER CODE END SPI2_MspInit 1 */
  }
}
 800135e:	3720      	adds	r7, #32
 8001360:	46bd      	mov	sp, r7
 8001362:	bd80      	pop	{r7, pc}

08001364 <HAL_SPI_MspDeInit>:

void HAL_SPI_MspDeInit(SPI_HandleTypeDef* hspi)
{
 8001364:	b580      	push	{r7, lr}
 8001366:	b082      	sub	sp, #8
 8001368:	af00      	add	r7, sp, #0
 800136a:	6078      	str	r0, [r7, #4]

  if(hspi->Instance==SPI2)
 800136c:	687b      	ldr	r3, [r7, #4]
 800136e:	681a      	ldr	r2, [r3, #0]
 8001370:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001374:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8001378:	429a      	cmp	r2, r3
 800137a:	d113      	bne.n	80013a4 <HAL_SPI_MspDeInit+0x40>
  {
  /* USER CODE BEGIN SPI2_MspDeInit 0 */

  /* USER CODE END SPI2_MspDeInit 0 */
    /* Peripheral clock disable */
    __SPI2_CLK_DISABLE();
 800137c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001380:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001384:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001388:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800138c:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800138e:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8001392:	641a      	str	r2, [r3, #64]	; 0x40
  
    /**SPI2 GPIO Configuration    
    PB10     ------> SPI2_SCK
    PB15     ------> SPI2_MOSI 
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10|GPIO_PIN_15);
 8001394:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8001398:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800139c:	f44f 4104 	mov.w	r1, #33792	; 0x8400
 80013a0:	f003 fe4a 	bl	8005038 <HAL_GPIO_DeInit>

  }
  /* USER CODE BEGIN SPI2_MspDeInit 1 */

  /* USER CODE END SPI2_MspDeInit 1 */
} 
 80013a4:	3708      	adds	r7, #8
 80013a6:	46bd      	mov	sp, r7
 80013a8:	bd80      	pop	{r7, pc}
 80013aa:	bf00      	nop

080013ac <HAL_MspInit>:

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80013ac:	b580      	push	{r7, lr}
 80013ae:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80013b0:	2003      	movs	r0, #3
 80013b2:	f002 fab5 	bl	8003920 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 80013b6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80013ba:	2100      	movs	r1, #0
 80013bc:	2200      	movs	r2, #0
 80013be:	f002 fab9 	bl	8003934 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80013c2:	bd80      	pop	{r7, pc}

080013c4 <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 80013c4:	b580      	push	{r7, lr}
 80013c6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 80013c8:	f000 faec 	bl	80019a4 <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
 80013cc:	f002 fbce 	bl	8003b6c <HAL_SYSTICK_IRQHandler>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 80013d0:	bd80      	pop	{r7, pc}
 80013d2:	bf00      	nop

080013d4 <DMA1_Stream0_IRQHandler>:

/**
* @brief This function handles DMA1 stream0 global interrupt.
*/
void DMA1_Stream0_IRQHandler(void)
{
 80013d4:	b580      	push	{r7, lr}
 80013d6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Stream0_IRQn 0 */

  /* USER CODE END DMA1_Stream0_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi3_rx);
 80013d8:	f240 5098 	movw	r0, #1432	; 0x598
 80013dc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80013e0:	f003 fa6e 	bl	80048c0 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Stream0_IRQn 1 */

  /* USER CODE END DMA1_Stream0_IRQn 1 */
}
 80013e4:	bd80      	pop	{r7, pc}
 80013e6:	bf00      	nop

080013e8 <DMA1_Stream5_IRQHandler>:

/**
* @brief This function handles DMA1 stream5 global interrupt.
*/
void DMA1_Stream5_IRQHandler(void)
{
 80013e8:	b580      	push	{r7, lr}
 80013ea:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Stream5_IRQn 0 */

  /* USER CODE END DMA1_Stream5_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_i2s3_ext_tx);
 80013ec:	f240 5040 	movw	r0, #1344	; 0x540
 80013f0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80013f4:	f003 fa64 	bl	80048c0 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Stream5_IRQn 1 */

  /* USER CODE END DMA1_Stream5_IRQn 1 */
}
 80013f8:	bd80      	pop	{r7, pc}
 80013fa:	bf00      	nop

080013fc <DMA2_Stream0_IRQHandler>:

/**
* @brief This function handles DMA2 stream0 global interrupt.
*/
void DMA2_Stream0_IRQHandler(void)
{
 80013fc:	b580      	push	{r7, lr}
 80013fe:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA2_Stream0_IRQn 0 */

  /* USER CODE END DMA2_Stream0_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc3);
 8001400:	f240 4090 	movw	r0, #1168	; 0x490
 8001404:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001408:	f003 fa5a 	bl	80048c0 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA2_Stream0_IRQn 1 */

  /* USER CODE END DMA2_Stream0_IRQn 1 */
}
 800140c:	bd80      	pop	{r7, pc}
 800140e:	bf00      	nop

08001410 <tremolo_one>:



static struct tremolo_one_lfo tremolo_lfo = {0,0,0};

int32_t  tremolo_one( float * input_buffer, float  * output_buffer, int32_t buffer_length){
 8001410:	b480      	push	{r7}
 8001412:	b08b      	sub	sp, #44	; 0x2c
 8001414:	af00      	add	r7, sp, #0
 8001416:	60f8      	str	r0, [r7, #12]
 8001418:	60b9      	str	r1, [r7, #8]
 800141a:	607a      	str	r2, [r7, #4]

	//init the lfo
	static struct tremolo_one_lfo  * my_lfo =  & tremolo_lfo;
	if(my_lfo->is_active != 1){
 800141c:	f240 0304 	movw	r3, #4
 8001420:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001424:	681b      	ldr	r3, [r3, #0]
 8001426:	681b      	ldr	r3, [r3, #0]
 8001428:	2b01      	cmp	r3, #1
 800142a:	d018      	beq.n	800145e <tremolo_one+0x4e>
		my_lfo->T = 5;
 800142c:	f240 0304 	movw	r3, #4
 8001430:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001434:	681b      	ldr	r3, [r3, #0]
 8001436:	f04f 0200 	mov.w	r2, #0
 800143a:	f2c4 02a0 	movt	r2, #16544	; 0x40a0
 800143e:	609a      	str	r2, [r3, #8]
		my_lfo->t = 0;
 8001440:	f240 0304 	movw	r3, #4
 8001444:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001448:	681b      	ldr	r3, [r3, #0]
 800144a:	f04f 0200 	mov.w	r2, #0
 800144e:	605a      	str	r2, [r3, #4]
		my_lfo->is_active = 1;
 8001450:	f240 0304 	movw	r3, #4
 8001454:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001458:	681b      	ldr	r3, [r3, #0]
 800145a:	2201      	movs	r2, #1
 800145c:	601a      	str	r2, [r3, #0]
	}


	float t_increment = 1.0/SAMPLING_RATE;
 800145e:	f241 236f 	movw	r3, #4719	; 0x126f
 8001462:	f6c3 0303 	movt	r3, #14339	; 0x3803
 8001466:	623b      	str	r3, [r7, #32]
	float amplitude_left, amplitude_right  = 0;
 8001468:	f04f 0300 	mov.w	r3, #0
 800146c:	61fb      	str	r3, [r7, #28]
	int32_t l, r;
	for( l = 0; l < buffer_length; l+=2){
 800146e:	2300      	movs	r3, #0
 8001470:	627b      	str	r3, [r7, #36]	; 0x24
 8001472:	e07b      	b.n	800156c <tremolo_one+0x15c>

		//left and right index
		r = l + 1;
 8001474:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001476:	3301      	adds	r3, #1
 8001478:	61bb      	str	r3, [r7, #24]

		//increment the lfo
		my_lfo->t += t_increment;
 800147a:	f240 0304 	movw	r3, #4
 800147e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001482:	681a      	ldr	r2, [r3, #0]
 8001484:	f240 0304 	movw	r3, #4
 8001488:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800148c:	681b      	ldr	r3, [r3, #0]
 800148e:	ed93 7a01 	vldr	s14, [r3, #4]
 8001492:	edd7 7a08 	vldr	s15, [r7, #32]
 8001496:	ee77 7a27 	vadd.f32	s15, s14, s15
 800149a:	edc2 7a01 	vstr	s15, [r2, #4]

		//check if time has expired
		if(my_lfo->t >= my_lfo->T){
 800149e:	f240 0304 	movw	r3, #4
 80014a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80014a6:	681b      	ldr	r3, [r3, #0]
 80014a8:	ed93 7a01 	vldr	s14, [r3, #4]
 80014ac:	f240 0304 	movw	r3, #4
 80014b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80014b4:	681b      	ldr	r3, [r3, #0]
 80014b6:	edd3 7a02 	vldr	s15, [r3, #8]
 80014ba:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80014be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80014c2:	db16      	blt.n	80014f2 <tremolo_one+0xe2>
			my_lfo->t -= my_lfo->T;
 80014c4:	f240 0304 	movw	r3, #4
 80014c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80014cc:	681a      	ldr	r2, [r3, #0]
 80014ce:	f240 0304 	movw	r3, #4
 80014d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80014d6:	681b      	ldr	r3, [r3, #0]
 80014d8:	ed93 7a01 	vldr	s14, [r3, #4]
 80014dc:	f240 0304 	movw	r3, #4
 80014e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80014e4:	681b      	ldr	r3, [r3, #0]
 80014e6:	edd3 7a02 	vldr	s15, [r3, #8]
 80014ea:	ee77 7a67 	vsub.f32	s15, s14, s15
 80014ee:	edc2 7a01 	vstr	s15, [r2, #4]
		}

		//now convert the lfo postion to an amplitude via some function. here is a boring one
		amplitude_left = my_lfo->t/my_lfo->T;
 80014f2:	f240 0304 	movw	r3, #4
 80014f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80014fa:	681b      	ldr	r3, [r3, #0]
 80014fc:	ed93 7a01 	vldr	s14, [r3, #4]
 8001500:	f240 0304 	movw	r3, #4
 8001504:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001508:	681b      	ldr	r3, [r3, #0]
 800150a:	edd3 7a02 	vldr	s15, [r3, #8]
 800150e:	eec7 7a27 	vdiv.f32	s15, s14, s15
 8001512:	edc7 7a05 	vstr	s15, [r7, #20]
		amplitude_right = 1.0 - amplitude_left;
 8001516:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 800151a:	edd7 7a05 	vldr	s15, [r7, #20]
 800151e:	ee77 7a67 	vsub.f32	s15, s14, s15
 8001522:	edc7 7a07 	vstr	s15, [r7, #28]

		//now scale the data
		output_buffer[l] = input_buffer[l] * amplitude_left;
 8001526:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001528:	009b      	lsls	r3, r3, #2
 800152a:	68ba      	ldr	r2, [r7, #8]
 800152c:	4413      	add	r3, r2
 800152e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8001530:	0092      	lsls	r2, r2, #2
 8001532:	68f9      	ldr	r1, [r7, #12]
 8001534:	440a      	add	r2, r1
 8001536:	ed92 7a00 	vldr	s14, [r2]
 800153a:	edd7 7a05 	vldr	s15, [r7, #20]
 800153e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8001542:	edc3 7a00 	vstr	s15, [r3]
		output_buffer[r] = input_buffer[r] * amplitude_right;
 8001546:	69bb      	ldr	r3, [r7, #24]
 8001548:	009b      	lsls	r3, r3, #2
 800154a:	68ba      	ldr	r2, [r7, #8]
 800154c:	4413      	add	r3, r2
 800154e:	69ba      	ldr	r2, [r7, #24]
 8001550:	0092      	lsls	r2, r2, #2
 8001552:	68f9      	ldr	r1, [r7, #12]
 8001554:	440a      	add	r2, r1
 8001556:	ed92 7a00 	vldr	s14, [r2]
 800155a:	edd7 7a07 	vldr	s15, [r7, #28]
 800155e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8001562:	edc3 7a00 	vstr	s15, [r3]


	float t_increment = 1.0/SAMPLING_RATE;
	float amplitude_left, amplitude_right  = 0;
	int32_t l, r;
	for( l = 0; l < buffer_length; l+=2){
 8001566:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001568:	3302      	adds	r3, #2
 800156a:	627b      	str	r3, [r7, #36]	; 0x24
 800156c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800156e:	687b      	ldr	r3, [r7, #4]
 8001570:	429a      	cmp	r2, r3
 8001572:	f6ff af7f 	blt.w	8001474 <tremolo_one+0x64>


	}


	return 0;
 8001576:	2300      	movs	r3, #0


}
 8001578:	4618      	mov	r0, r3
 800157a:	372c      	adds	r7, #44	; 0x2c
 800157c:	46bd      	mov	sp, r7
 800157e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001582:	4770      	bx	lr

08001584 <codec_init>:
#include "stm32f4xx_hal.h"
#include "stm32f4xx.h"
#include "stm32f4xx_hal_def.h"
#include "wm8731.h"

void codec_init(SPI_HandleTypeDef* hspi){
 8001584:	b580      	push	{r7, lr}
 8001586:	b086      	sub	sp, #24
 8001588:	af00      	add	r7, sp, #0
 800158a:	6078      	str	r0, [r7, #4]
     uint8_t pData[2] = { 0x10, 0x0f}; 
 800158c:	f64b 2308 	movw	r3, #47624	; 0xba08
 8001590:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001594:	f107 020c 	add.w	r2, r7, #12
 8001598:	881b      	ldrh	r3, [r3, #0]
 800159a:	8013      	strh	r3, [r2, #0]
    uint16_t temp = 0;
 800159c:	2300      	movs	r3, #0
 800159e:	82fb      	strh	r3, [r7, #22]
    // HAL_Delay(25);


    //power down register

    int32_t spi_delay = 100;
 80015a0:	2364      	movs	r3, #100	; 0x64
 80015a2:	613b      	str	r3, [r7, #16]
    temp = 0x0c << 8;
 80015a4:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 80015a8:	82fb      	strh	r3, [r7, #22]
    temp |= 0x00;

    pData[0] = temp >> 8;
 80015aa:	8afb      	ldrh	r3, [r7, #22]
 80015ac:	0a1b      	lsrs	r3, r3, #8
 80015ae:	b29b      	uxth	r3, r3
 80015b0:	b2db      	uxtb	r3, r3
 80015b2:	733b      	strb	r3, [r7, #12]
    pData[1] = temp;
 80015b4:	8afb      	ldrh	r3, [r7, #22]
 80015b6:	b2db      	uxtb	r3, r3
 80015b8:	737b      	strb	r3, [r7, #13]

    HAL_GPIO_WritePin(WM8731_NSS_PORT, WM8731_NSS_PIN, 0 );
 80015ba:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80015be:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80015c2:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80015c6:	2200      	movs	r2, #0
 80015c8:	f003 fe76 	bl	80052b8 <HAL_GPIO_WritePin>
    HAL_SPI_Transmit( hspi, pData, 2, 100);
 80015cc:	f107 030c 	add.w	r3, r7, #12
 80015d0:	6878      	ldr	r0, [r7, #4]
 80015d2:	4619      	mov	r1, r3
 80015d4:	2202      	movs	r2, #2
 80015d6:	2364      	movs	r3, #100	; 0x64
 80015d8:	f007 fe26 	bl	8009228 <HAL_SPI_Transmit>
    HAL_GPIO_WritePin(WM8731_NSS_PORT, WM8731_NSS_PIN, 1 );
 80015dc:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80015e0:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80015e4:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80015e8:	2201      	movs	r2, #1
 80015ea:	f003 fe65 	bl	80052b8 <HAL_GPIO_WritePin>
    HAL_Delay(spi_delay);
 80015ee:	693b      	ldr	r3, [r7, #16]
 80015f0:	4618      	mov	r0, r3
 80015f2:	f000 f9f5 	bl	80019e0 <HAL_Delay>


    // Left line in register
    temp = 0x00 << 8;
 80015f6:	2300      	movs	r3, #0
 80015f8:	82fb      	strh	r3, [r7, #22]
    temp |= 0x17; //0db gain
 80015fa:	8afb      	ldrh	r3, [r7, #22]
 80015fc:	f043 0317 	orr.w	r3, r3, #23
 8001600:	82fb      	strh	r3, [r7, #22]

    pData[0] = temp >> 8;
 8001602:	8afb      	ldrh	r3, [r7, #22]
 8001604:	0a1b      	lsrs	r3, r3, #8
 8001606:	b29b      	uxth	r3, r3
 8001608:	b2db      	uxtb	r3, r3
 800160a:	733b      	strb	r3, [r7, #12]
    pData[1] = temp;
 800160c:	8afb      	ldrh	r3, [r7, #22]
 800160e:	b2db      	uxtb	r3, r3
 8001610:	737b      	strb	r3, [r7, #13]

    HAL_GPIO_WritePin(WM8731_NSS_PORT, WM8731_NSS_PIN, 0 );
 8001612:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8001616:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800161a:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800161e:	2200      	movs	r2, #0
 8001620:	f003 fe4a 	bl	80052b8 <HAL_GPIO_WritePin>
    HAL_SPI_Transmit( hspi, pData, 2, 100);
 8001624:	f107 030c 	add.w	r3, r7, #12
 8001628:	6878      	ldr	r0, [r7, #4]
 800162a:	4619      	mov	r1, r3
 800162c:	2202      	movs	r2, #2
 800162e:	2364      	movs	r3, #100	; 0x64
 8001630:	f007 fdfa 	bl	8009228 <HAL_SPI_Transmit>
    HAL_GPIO_WritePin(WM8731_NSS_PORT, WM8731_NSS_PIN, 1 );
 8001634:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8001638:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800163c:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8001640:	2201      	movs	r2, #1
 8001642:	f003 fe39 	bl	80052b8 <HAL_GPIO_WritePin>
    HAL_Delay(spi_delay);
 8001646:	693b      	ldr	r3, [r7, #16]
 8001648:	4618      	mov	r0, r3
 800164a:	f000 f9c9 	bl	80019e0 <HAL_Delay>
    // Right line in register
    temp = 0x02 << 8;
 800164e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001652:	82fb      	strh	r3, [r7, #22]
    temp |= 0x17; //0db gain
 8001654:	8afb      	ldrh	r3, [r7, #22]
 8001656:	f043 0317 	orr.w	r3, r3, #23
 800165a:	82fb      	strh	r3, [r7, #22]

    pData[0] = temp >> 8;
 800165c:	8afb      	ldrh	r3, [r7, #22]
 800165e:	0a1b      	lsrs	r3, r3, #8
 8001660:	b29b      	uxth	r3, r3
 8001662:	b2db      	uxtb	r3, r3
 8001664:	733b      	strb	r3, [r7, #12]
    pData[1] = temp;
 8001666:	8afb      	ldrh	r3, [r7, #22]
 8001668:	b2db      	uxtb	r3, r3
 800166a:	737b      	strb	r3, [r7, #13]

    HAL_GPIO_WritePin(WM8731_NSS_PORT, WM8731_NSS_PIN, 0 );
 800166c:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8001670:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8001674:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8001678:	2200      	movs	r2, #0
 800167a:	f003 fe1d 	bl	80052b8 <HAL_GPIO_WritePin>
    HAL_SPI_Transmit( hspi, pData, 2, 100);
 800167e:	f107 030c 	add.w	r3, r7, #12
 8001682:	6878      	ldr	r0, [r7, #4]
 8001684:	4619      	mov	r1, r3
 8001686:	2202      	movs	r2, #2
 8001688:	2364      	movs	r3, #100	; 0x64
 800168a:	f007 fdcd 	bl	8009228 <HAL_SPI_Transmit>
    HAL_GPIO_WritePin(WM8731_NSS_PORT, WM8731_NSS_PIN, 1 );
 800168e:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8001692:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8001696:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800169a:	2201      	movs	r2, #1
 800169c:	f003 fe0c 	bl	80052b8 <HAL_GPIO_WritePin>
    HAL_Delay(spi_delay);
 80016a0:	693b      	ldr	r3, [r7, #16]
 80016a2:	4618      	mov	r0, r3
 80016a4:	f000 f99c 	bl	80019e0 <HAL_Delay>

    //left hp and right hp out dont matter

    //analog audio path control
    temp = 0x08 << 8;
 80016a8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80016ac:	82fb      	strh	r3, [r7, #22]
    temp |= 0x12; //Dac selected, mute mic input, no sidetone
 80016ae:	8afb      	ldrh	r3, [r7, #22]
 80016b0:	f043 0312 	orr.w	r3, r3, #18
 80016b4:	82fb      	strh	r3, [r7, #22]

    pData[0] = temp >> 8;
 80016b6:	8afb      	ldrh	r3, [r7, #22]
 80016b8:	0a1b      	lsrs	r3, r3, #8
 80016ba:	b29b      	uxth	r3, r3
 80016bc:	b2db      	uxtb	r3, r3
 80016be:	733b      	strb	r3, [r7, #12]
    pData[1] = temp;
 80016c0:	8afb      	ldrh	r3, [r7, #22]
 80016c2:	b2db      	uxtb	r3, r3
 80016c4:	737b      	strb	r3, [r7, #13]

    HAL_GPIO_WritePin(WM8731_NSS_PORT, WM8731_NSS_PIN, 0 );
 80016c6:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80016ca:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80016ce:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80016d2:	2200      	movs	r2, #0
 80016d4:	f003 fdf0 	bl	80052b8 <HAL_GPIO_WritePin>
    HAL_SPI_Transmit( hspi, pData, 2, 100);
 80016d8:	f107 030c 	add.w	r3, r7, #12
 80016dc:	6878      	ldr	r0, [r7, #4]
 80016de:	4619      	mov	r1, r3
 80016e0:	2202      	movs	r2, #2
 80016e2:	2364      	movs	r3, #100	; 0x64
 80016e4:	f007 fda0 	bl	8009228 <HAL_SPI_Transmit>
    HAL_GPIO_WritePin(WM8731_NSS_PORT, WM8731_NSS_PIN, 1 );
 80016e8:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80016ec:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80016f0:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80016f4:	2201      	movs	r2, #1
 80016f6:	f003 fddf 	bl	80052b8 <HAL_GPIO_WritePin>
    HAL_Delay(spi_delay);
 80016fa:	693b      	ldr	r3, [r7, #16]
 80016fc:	4618      	mov	r0, r3
 80016fe:	f000 f96f 	bl	80019e0 <HAL_Delay>

    //digital audio path control
    temp = 0x0A << 8;
 8001702:	f44f 6320 	mov.w	r3, #2560	; 0xa00
 8001706:	82fb      	strh	r3, [r7, #22]
    temp |= 0x00; //mute disabled

    pData[0] = temp >> 8;
 8001708:	8afb      	ldrh	r3, [r7, #22]
 800170a:	0a1b      	lsrs	r3, r3, #8
 800170c:	b29b      	uxth	r3, r3
 800170e:	b2db      	uxtb	r3, r3
 8001710:	733b      	strb	r3, [r7, #12]
    pData[1] = temp;
 8001712:	8afb      	ldrh	r3, [r7, #22]
 8001714:	b2db      	uxtb	r3, r3
 8001716:	737b      	strb	r3, [r7, #13]

    HAL_GPIO_WritePin(WM8731_NSS_PORT, WM8731_NSS_PIN, 0 );
 8001718:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800171c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8001720:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8001724:	2200      	movs	r2, #0
 8001726:	f003 fdc7 	bl	80052b8 <HAL_GPIO_WritePin>
    HAL_SPI_Transmit( hspi, pData, 2, 100);
 800172a:	f107 030c 	add.w	r3, r7, #12
 800172e:	6878      	ldr	r0, [r7, #4]
 8001730:	4619      	mov	r1, r3
 8001732:	2202      	movs	r2, #2
 8001734:	2364      	movs	r3, #100	; 0x64
 8001736:	f007 fd77 	bl	8009228 <HAL_SPI_Transmit>
    HAL_GPIO_WritePin(WM8731_NSS_PORT, WM8731_NSS_PIN, 1 );
 800173a:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800173e:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8001742:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8001746:	2201      	movs	r2, #1
 8001748:	f003 fdb6 	bl	80052b8 <HAL_GPIO_WritePin>
    HAL_Delay(spi_delay);
 800174c:	693b      	ldr	r3, [r7, #16]
 800174e:	4618      	mov	r0, r3
 8001750:	f000 f946 	bl	80019e0 <HAL_Delay>

    //Digital audio interface format
    temp = 0x0E << 8;
 8001754:	f44f 6360 	mov.w	r3, #3584	; 0xe00
 8001758:	82fb      	strh	r3, [r7, #22]
    temp |= 0x02; //16 bit input word, I2S format
 800175a:	8afb      	ldrh	r3, [r7, #22]
 800175c:	f043 0302 	orr.w	r3, r3, #2
 8001760:	82fb      	strh	r3, [r7, #22]
    pData[0] = temp >> 8;
 8001762:	8afb      	ldrh	r3, [r7, #22]
 8001764:	0a1b      	lsrs	r3, r3, #8
 8001766:	b29b      	uxth	r3, r3
 8001768:	b2db      	uxtb	r3, r3
 800176a:	733b      	strb	r3, [r7, #12]
    pData[1] = temp;
 800176c:	8afb      	ldrh	r3, [r7, #22]
 800176e:	b2db      	uxtb	r3, r3
 8001770:	737b      	strb	r3, [r7, #13]

    HAL_GPIO_WritePin(WM8731_NSS_PORT, WM8731_NSS_PIN, 0 );
 8001772:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8001776:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800177a:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800177e:	2200      	movs	r2, #0
 8001780:	f003 fd9a 	bl	80052b8 <HAL_GPIO_WritePin>
    HAL_SPI_Transmit( hspi, pData, 2, 100);
 8001784:	f107 030c 	add.w	r3, r7, #12
 8001788:	6878      	ldr	r0, [r7, #4]
 800178a:	4619      	mov	r1, r3
 800178c:	2202      	movs	r2, #2
 800178e:	2364      	movs	r3, #100	; 0x64
 8001790:	f007 fd4a 	bl	8009228 <HAL_SPI_Transmit>
    HAL_GPIO_WritePin(WM8731_NSS_PORT, WM8731_NSS_PIN, 1 );
 8001794:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8001798:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800179c:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80017a0:	2201      	movs	r2, #1
 80017a2:	f003 fd89 	bl	80052b8 <HAL_GPIO_WritePin>
    HAL_Delay(spi_delay);
 80017a6:	693b      	ldr	r3, [r7, #16]
 80017a8:	4618      	mov	r0, r3
 80017aa:	f000 f919 	bl	80019e0 <HAL_Delay>
  
    //Sampling control
    temp = 0x10 << 8;
 80017ae:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80017b2:	82fb      	strh	r3, [r7, #22]
    temp |= 0x00; //
    pData[0] = temp >> 8;
 80017b4:	8afb      	ldrh	r3, [r7, #22]
 80017b6:	0a1b      	lsrs	r3, r3, #8
 80017b8:	b29b      	uxth	r3, r3
 80017ba:	b2db      	uxtb	r3, r3
 80017bc:	733b      	strb	r3, [r7, #12]
    pData[1] = temp;
 80017be:	8afb      	ldrh	r3, [r7, #22]
 80017c0:	b2db      	uxtb	r3, r3
 80017c2:	737b      	strb	r3, [r7, #13]

    HAL_GPIO_WritePin(WM8731_NSS_PORT, WM8731_NSS_PIN, 0 );
 80017c4:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80017c8:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80017cc:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80017d0:	2200      	movs	r2, #0
 80017d2:	f003 fd71 	bl	80052b8 <HAL_GPIO_WritePin>
    HAL_SPI_Transmit( hspi, pData, 2, 100);
 80017d6:	f107 030c 	add.w	r3, r7, #12
 80017da:	6878      	ldr	r0, [r7, #4]
 80017dc:	4619      	mov	r1, r3
 80017de:	2202      	movs	r2, #2
 80017e0:	2364      	movs	r3, #100	; 0x64
 80017e2:	f007 fd21 	bl	8009228 <HAL_SPI_Transmit>
    HAL_GPIO_WritePin(WM8731_NSS_PORT, WM8731_NSS_PIN, 1 );
 80017e6:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80017ea:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80017ee:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80017f2:	2201      	movs	r2, #1
 80017f4:	f003 fd60 	bl	80052b8 <HAL_GPIO_WritePin>
    HAL_Delay(spi_delay);
 80017f8:	693b      	ldr	r3, [r7, #16]
 80017fa:	4618      	mov	r0, r3
 80017fc:	f000 f8f0 	bl	80019e0 <HAL_Delay>

    //Active control
    temp = 0x12 << 8;
 8001800:	f44f 5390 	mov.w	r3, #4608	; 0x1200
 8001804:	82fb      	strh	r3, [r7, #22]
    temp |= 0x01; //
 8001806:	8afb      	ldrh	r3, [r7, #22]
 8001808:	f043 0301 	orr.w	r3, r3, #1
 800180c:	82fb      	strh	r3, [r7, #22]
    pData[0] = temp >> 8;
 800180e:	8afb      	ldrh	r3, [r7, #22]
 8001810:	0a1b      	lsrs	r3, r3, #8
 8001812:	b29b      	uxth	r3, r3
 8001814:	b2db      	uxtb	r3, r3
 8001816:	733b      	strb	r3, [r7, #12]
    pData[1] = temp;
 8001818:	8afb      	ldrh	r3, [r7, #22]
 800181a:	b2db      	uxtb	r3, r3
 800181c:	737b      	strb	r3, [r7, #13]

    HAL_GPIO_WritePin(WM8731_NSS_PORT, WM8731_NSS_PIN, 0 );
 800181e:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8001822:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8001826:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800182a:	2200      	movs	r2, #0
 800182c:	f003 fd44 	bl	80052b8 <HAL_GPIO_WritePin>
    HAL_SPI_Transmit( hspi, pData, 2, 100);
 8001830:	f107 030c 	add.w	r3, r7, #12
 8001834:	6878      	ldr	r0, [r7, #4]
 8001836:	4619      	mov	r1, r3
 8001838:	2202      	movs	r2, #2
 800183a:	2364      	movs	r3, #100	; 0x64
 800183c:	f007 fcf4 	bl	8009228 <HAL_SPI_Transmit>
    HAL_GPIO_WritePin(WM8731_NSS_PORT, WM8731_NSS_PIN, 1 );
 8001840:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8001844:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8001848:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800184c:	2201      	movs	r2, #1
 800184e:	f003 fd33 	bl	80052b8 <HAL_GPIO_WritePin>
    HAL_Delay(spi_delay);
 8001852:	693b      	ldr	r3, [r7, #16]
 8001854:	4618      	mov	r0, r3
 8001856:	f000 f8c3 	bl	80019e0 <HAL_Delay>
    
 800185a:	3718      	adds	r7, #24
 800185c:	46bd      	mov	sp, r7
 800185e:	bd80      	pop	{r7, pc}

08001860 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8001860:	b580      	push	{r7, lr}
 8001862:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8001864:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8001868:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800186c:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
 8001870:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001874:	6812      	ldr	r2, [r2, #0]
 8001876:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800187a:	601a      	str	r2, [r3, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0)
   __HAL_FLASH_DATA_CACHE_ENABLE();
 800187c:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8001880:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001884:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
 8001888:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800188c:	6812      	ldr	r2, [r2, #0]
 800188e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8001892:	601a      	str	r2, [r3, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8001894:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8001898:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800189c:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
 80018a0:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80018a4:	6812      	ldr	r2, [r2, #0]
 80018a6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80018aa:	601a      	str	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80018ac:	2003      	movs	r0, #3
 80018ae:	f002 f837 	bl	8003920 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 80018b2:	2000      	movs	r0, #0
 80018b4:	f000 f85a 	bl	800196c <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 80018b8:	f7ff fd78 	bl	80013ac <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
 80018bc:	2300      	movs	r3, #0
}
 80018be:	4618      	mov	r0, r3
 80018c0:	bd80      	pop	{r7, pc}
 80018c2:	bf00      	nop

080018c4 <HAL_DeInit>:
  * @brief  This function de-Initializes common part of the HAL and stops the systick.
  *         This function is optional.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DeInit(void)
{
 80018c4:	b580      	push	{r7, lr}
 80018c6:	af00      	add	r7, sp, #0
  /* Reset of all peripherals */
  __HAL_RCC_APB1_FORCE_RESET();
 80018c8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80018cc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80018d0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80018d4:	621a      	str	r2, [r3, #32]
  __HAL_RCC_APB1_RELEASE_RESET();
 80018d6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80018da:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80018de:	2200      	movs	r2, #0
 80018e0:	621a      	str	r2, [r3, #32]

  __HAL_RCC_APB2_FORCE_RESET();
 80018e2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80018e6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80018ea:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80018ee:	625a      	str	r2, [r3, #36]	; 0x24
  __HAL_RCC_APB2_RELEASE_RESET();
 80018f0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80018f4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80018f8:	2200      	movs	r2, #0
 80018fa:	625a      	str	r2, [r3, #36]	; 0x24

  __HAL_RCC_AHB1_FORCE_RESET();
 80018fc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001900:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001904:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8001908:	611a      	str	r2, [r3, #16]
  __HAL_RCC_AHB1_RELEASE_RESET();
 800190a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800190e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001912:	2200      	movs	r2, #0
 8001914:	611a      	str	r2, [r3, #16]

  __HAL_RCC_AHB2_FORCE_RESET();
 8001916:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800191a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800191e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8001922:	615a      	str	r2, [r3, #20]
  __HAL_RCC_AHB2_RELEASE_RESET();
 8001924:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001928:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800192c:	2200      	movs	r2, #0
 800192e:	615a      	str	r2, [r3, #20]

  __HAL_RCC_AHB3_FORCE_RESET();
 8001930:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001934:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001938:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800193c:	619a      	str	r2, [r3, #24]
  __HAL_RCC_AHB3_RELEASE_RESET();
 800193e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001942:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001946:	2200      	movs	r2, #0
 8001948:	619a      	str	r2, [r3, #24]

  /* De-Init the low level hardware */
  HAL_MspDeInit();
 800194a:	f000 f809 	bl	8001960 <HAL_MspDeInit>
    
  /* Return function status */
  return HAL_OK;
 800194e:	2300      	movs	r3, #0
}
 8001950:	4618      	mov	r0, r3
 8001952:	bd80      	pop	{r7, pc}
/**
  * @brief  Initializes the MSP.
  * @retval None
  */
__weak void HAL_MspInit(void)
{
 8001954:	b480      	push	{r7}
 8001956:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
 8001958:	46bd      	mov	sp, r7
 800195a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800195e:	4770      	bx	lr

08001960 <HAL_MspDeInit>:
/**
  * @brief  DeInitializes the MSP.
  * @retval None
  */
__weak void HAL_MspDeInit(void)
{
 8001960:	b480      	push	{r7}
 8001962:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspDeInit could be implemented in the user file
   */ 
}
 8001964:	46bd      	mov	sp, r7
 8001966:	f85d 7b04 	ldr.w	r7, [sp], #4
 800196a:	4770      	bx	lr

0800196c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800196c:	b580      	push	{r7, lr}
 800196e:	b082      	sub	sp, #8
 8001970:	af00      	add	r7, sp, #0
 8001972:	6078      	str	r0, [r7, #4]
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8001974:	f007 f842 	bl	80089fc <HAL_RCC_GetHCLKFreq>
 8001978:	4602      	mov	r2, r0
 800197a:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 800197e:	f2c1 0362 	movt	r3, #4194	; 0x1062
 8001982:	fba3 1302 	umull	r1, r3, r3, r2
 8001986:	099b      	lsrs	r3, r3, #6
 8001988:	4618      	mov	r0, r3
 800198a:	f002 f811 	bl	80039b0 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 800198e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001992:	6879      	ldr	r1, [r7, #4]
 8001994:	2200      	movs	r2, #0
 8001996:	f001 ffcd 	bl	8003934 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
 800199a:	2300      	movs	r3, #0
}
 800199c:	4618      	mov	r0, r3
 800199e:	3708      	adds	r7, #8
 80019a0:	46bd      	mov	sp, r7
 80019a2:	bd80      	pop	{r7, pc}

080019a4 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 80019a4:	b480      	push	{r7}
 80019a6:	af00      	add	r7, sp, #0
  uwTick++;
 80019a8:	f640 6380 	movw	r3, #3712	; 0xe80
 80019ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019b0:	681b      	ldr	r3, [r3, #0]
 80019b2:	1c5a      	adds	r2, r3, #1
 80019b4:	f640 6380 	movw	r3, #3712	; 0xe80
 80019b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019bc:	601a      	str	r2, [r3, #0]
}
 80019be:	46bd      	mov	sp, r7
 80019c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80019c4:	4770      	bx	lr
 80019c6:	bf00      	nop

080019c8 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 80019c8:	b480      	push	{r7}
 80019ca:	af00      	add	r7, sp, #0
  return uwTick;
 80019cc:	f640 6380 	movw	r3, #3712	; 0xe80
 80019d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019d4:	681b      	ldr	r3, [r3, #0]
}
 80019d6:	4618      	mov	r0, r3
 80019d8:	46bd      	mov	sp, r7
 80019da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80019de:	4770      	bx	lr

080019e0 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 80019e0:	b580      	push	{r7, lr}
 80019e2:	b084      	sub	sp, #16
 80019e4:	af00      	add	r7, sp, #0
 80019e6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0;
 80019e8:	2300      	movs	r3, #0
 80019ea:	60fb      	str	r3, [r7, #12]
  tickstart = HAL_GetTick();
 80019ec:	f7ff ffec 	bl	80019c8 <HAL_GetTick>
 80019f0:	60f8      	str	r0, [r7, #12]
  while((HAL_GetTick() - tickstart) < Delay)
 80019f2:	bf00      	nop
 80019f4:	f7ff ffe8 	bl	80019c8 <HAL_GetTick>
 80019f8:	4602      	mov	r2, r0
 80019fa:	68fb      	ldr	r3, [r7, #12]
 80019fc:	1ad2      	subs	r2, r2, r3
 80019fe:	687b      	ldr	r3, [r7, #4]
 8001a00:	429a      	cmp	r2, r3
 8001a02:	d3f7      	bcc.n	80019f4 <HAL_Delay+0x14>
  {
  }
}
 8001a04:	3710      	adds	r7, #16
 8001a06:	46bd      	mov	sp, r7
 8001a08:	bd80      	pop	{r7, pc}
 8001a0a:	bf00      	nop

08001a0c <HAL_SuspendTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
 8001a0c:	b480      	push	{r7}
 8001a0e:	af00      	add	r7, sp, #0
  /* Disable SysTick Interrupt */
  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
 8001a10:	f24e 0310 	movw	r3, #57360	; 0xe010
 8001a14:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001a18:	f24e 0210 	movw	r2, #57360	; 0xe010
 8001a1c:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8001a20:	6812      	ldr	r2, [r2, #0]
 8001a22:	f022 0202 	bic.w	r2, r2, #2
 8001a26:	601a      	str	r2, [r3, #0]
}
 8001a28:	46bd      	mov	sp, r7
 8001a2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a2e:	4770      	bx	lr

08001a30 <HAL_ResumeTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
 8001a30:	b480      	push	{r7}
 8001a32:	af00      	add	r7, sp, #0
  /* Enable SysTick Interrupt */
  SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
 8001a34:	f24e 0310 	movw	r3, #57360	; 0xe010
 8001a38:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001a3c:	f24e 0210 	movw	r2, #57360	; 0xe010
 8001a40:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8001a44:	6812      	ldr	r2, [r2, #0]
 8001a46:	f042 0202 	orr.w	r2, r2, #2
 8001a4a:	601a      	str	r2, [r3, #0]
}
 8001a4c:	46bd      	mov	sp, r7
 8001a4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a52:	4770      	bx	lr

08001a54 <HAL_GetHalVersion>:
/**
  * @brief  Returns the HAL revision
  * @retval version : 0xXYZR (8bits for each decimal, R for RC)
  */
uint32_t HAL_GetHalVersion(void)
{
 8001a54:	b480      	push	{r7}
 8001a56:	af00      	add	r7, sp, #0
 return __STM32F4xx_HAL_VERSION;
 8001a58:	f04f 7382 	mov.w	r3, #17039360	; 0x1040000
}
 8001a5c:	4618      	mov	r0, r3
 8001a5e:	46bd      	mov	sp, r7
 8001a60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a64:	4770      	bx	lr
 8001a66:	bf00      	nop

08001a68 <HAL_GetREVID>:
/**
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
 8001a68:	b480      	push	{r7}
 8001a6a:	af00      	add	r7, sp, #0
   return((DBGMCU->IDCODE) >> 16);
 8001a6c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001a70:	f2ce 0304 	movt	r3, #57348	; 0xe004
 8001a74:	681b      	ldr	r3, [r3, #0]
 8001a76:	0c1b      	lsrs	r3, r3, #16
}
 8001a78:	4618      	mov	r0, r3
 8001a7a:	46bd      	mov	sp, r7
 8001a7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a80:	4770      	bx	lr
 8001a82:	bf00      	nop

08001a84 <HAL_GetDEVID>:
/**
  * @brief  Returns the device identifier.
  * @retval Device identifier
  */
uint32_t HAL_GetDEVID(void)
{
 8001a84:	b480      	push	{r7}
 8001a86:	af00      	add	r7, sp, #0
   return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
 8001a88:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001a8c:	f2ce 0304 	movt	r3, #57348	; 0xe004
 8001a90:	681b      	ldr	r3, [r3, #0]
 8001a92:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
 8001a96:	4618      	mov	r0, r3
 8001a98:	46bd      	mov	sp, r7
 8001a9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a9e:	4770      	bx	lr

08001aa0 <HAL_DBGMCU_EnableDBGSleepMode>:
/**
  * @brief  Enable the Debug Module during SLEEP mode
  * @retval None
  */
void HAL_DBGMCU_EnableDBGSleepMode(void)
{
 8001aa0:	b480      	push	{r7}
 8001aa2:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 8001aa4:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001aa8:	f2ce 0304 	movt	r3, #57348	; 0xe004
 8001aac:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001ab0:	f2ce 0204 	movt	r2, #57348	; 0xe004
 8001ab4:	6852      	ldr	r2, [r2, #4]
 8001ab6:	f042 0201 	orr.w	r2, r2, #1
 8001aba:	605a      	str	r2, [r3, #4]
}
 8001abc:	46bd      	mov	sp, r7
 8001abe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001ac2:	4770      	bx	lr

08001ac4 <HAL_DBGMCU_DisableDBGSleepMode>:
/**
  * @brief  Disable the Debug Module during SLEEP mode
  * @retval None
  */
void HAL_DBGMCU_DisableDBGSleepMode(void)
{
 8001ac4:	b480      	push	{r7}
 8001ac6:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 8001ac8:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001acc:	f2ce 0304 	movt	r3, #57348	; 0xe004
 8001ad0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001ad4:	f2ce 0204 	movt	r2, #57348	; 0xe004
 8001ad8:	6852      	ldr	r2, [r2, #4]
 8001ada:	f022 0201 	bic.w	r2, r2, #1
 8001ade:	605a      	str	r2, [r3, #4]
}
 8001ae0:	46bd      	mov	sp, r7
 8001ae2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001ae6:	4770      	bx	lr

08001ae8 <HAL_DBGMCU_EnableDBGStopMode>:
/**
  * @brief  Enable the Debug Module during STOP mode
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStopMode(void)
{
 8001ae8:	b480      	push	{r7}
 8001aea:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 8001aec:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001af0:	f2ce 0304 	movt	r3, #57348	; 0xe004
 8001af4:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001af8:	f2ce 0204 	movt	r2, #57348	; 0xe004
 8001afc:	6852      	ldr	r2, [r2, #4]
 8001afe:	f042 0202 	orr.w	r2, r2, #2
 8001b02:	605a      	str	r2, [r3, #4]
}
 8001b04:	46bd      	mov	sp, r7
 8001b06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b0a:	4770      	bx	lr

08001b0c <HAL_DBGMCU_DisableDBGStopMode>:
/**
  * @brief  Disable the Debug Module during STOP mode
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStopMode(void)
{
 8001b0c:	b480      	push	{r7}
 8001b0e:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 8001b10:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001b14:	f2ce 0304 	movt	r3, #57348	; 0xe004
 8001b18:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001b1c:	f2ce 0204 	movt	r2, #57348	; 0xe004
 8001b20:	6852      	ldr	r2, [r2, #4]
 8001b22:	f022 0202 	bic.w	r2, r2, #2
 8001b26:	605a      	str	r2, [r3, #4]
}
 8001b28:	46bd      	mov	sp, r7
 8001b2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b2e:	4770      	bx	lr

08001b30 <HAL_DBGMCU_EnableDBGStandbyMode>:
/**
  * @brief  Enable the Debug Module during STANDBY mode
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStandbyMode(void)
{
 8001b30:	b480      	push	{r7}
 8001b32:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 8001b34:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001b38:	f2ce 0304 	movt	r3, #57348	; 0xe004
 8001b3c:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001b40:	f2ce 0204 	movt	r2, #57348	; 0xe004
 8001b44:	6852      	ldr	r2, [r2, #4]
 8001b46:	f042 0204 	orr.w	r2, r2, #4
 8001b4a:	605a      	str	r2, [r3, #4]
}
 8001b4c:	46bd      	mov	sp, r7
 8001b4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b52:	4770      	bx	lr

08001b54 <HAL_DBGMCU_DisableDBGStandbyMode>:
/**
  * @brief  Disable the Debug Module during STANDBY mode
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStandbyMode(void)
{
 8001b54:	b480      	push	{r7}
 8001b56:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 8001b58:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001b5c:	f2ce 0304 	movt	r3, #57348	; 0xe004
 8001b60:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001b64:	f2ce 0204 	movt	r2, #57348	; 0xe004
 8001b68:	6852      	ldr	r2, [r2, #4]
 8001b6a:	f022 0204 	bic.w	r2, r2, #4
 8001b6e:	605a      	str	r2, [r3, #4]
}
 8001b70:	46bd      	mov	sp, r7
 8001b72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b76:	4770      	bx	lr

08001b78 <HAL_EnableCompensationCell>:
  * @note   The I/O compensation cell can be used only when the device supply
  *         voltage ranges from 2.4 to 3.6 V.  
  * @retval None
  */
void HAL_EnableCompensationCell(void)
{
 8001b78:	b480      	push	{r7}
 8001b7a:	b083      	sub	sp, #12
 8001b7c:	af00      	add	r7, sp, #0
 8001b7e:	2301      	movs	r3, #1
 8001b80:	607b      	str	r3, [r7, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001b82:	687b      	ldr	r3, [r7, #4]
 8001b84:	fa93 f3a3 	rbit	r3, r3
 8001b88:	603b      	str	r3, [r7, #0]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8001b8a:	683b      	ldr	r3, [r7, #0]
  *(__IO uint32_t *)CMPCR_CMP_PD_BB = (uint32_t)ENABLE;
 8001b8c:	fab3 f383 	clz	r3, r3
 8001b90:	009b      	lsls	r3, r3, #2
 8001b92:	461a      	mov	r2, r3
 8001b94:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001b98:	f2c4 2327 	movt	r3, #16935	; 0x4227
 8001b9c:	4413      	add	r3, r2
 8001b9e:	2201      	movs	r2, #1
 8001ba0:	601a      	str	r2, [r3, #0]
}
 8001ba2:	370c      	adds	r7, #12
 8001ba4:	46bd      	mov	sp, r7
 8001ba6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001baa:	4770      	bx	lr

08001bac <HAL_DisableCompensationCell>:
  * @note   The I/O compensation cell can be used only when the device supply
  *         voltage ranges from 2.4 to 3.6 V.  
  * @retval None
  */
void HAL_DisableCompensationCell(void)
{
 8001bac:	b480      	push	{r7}
 8001bae:	b083      	sub	sp, #12
 8001bb0:	af00      	add	r7, sp, #0
 8001bb2:	2301      	movs	r3, #1
 8001bb4:	607b      	str	r3, [r7, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001bb6:	687b      	ldr	r3, [r7, #4]
 8001bb8:	fa93 f3a3 	rbit	r3, r3
 8001bbc:	603b      	str	r3, [r7, #0]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8001bbe:	683b      	ldr	r3, [r7, #0]
  *(__IO uint32_t *)CMPCR_CMP_PD_BB = (uint32_t)DISABLE;
 8001bc0:	fab3 f383 	clz	r3, r3
 8001bc4:	009b      	lsls	r3, r3, #2
 8001bc6:	461a      	mov	r2, r3
 8001bc8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001bcc:	f2c4 2327 	movt	r3, #16935	; 0x4227
 8001bd0:	4413      	add	r3, r2
 8001bd2:	2200      	movs	r2, #0
 8001bd4:	601a      	str	r2, [r3, #0]
}
 8001bd6:	370c      	adds	r7, #12
 8001bd8:	46bd      	mov	sp, r7
 8001bda:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001bde:	4770      	bx	lr

08001be0 <HAL_ADC_Init>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
 8001be0:	b580      	push	{r7, lr}
 8001be2:	b082      	sub	sp, #8
 8001be4:	af00      	add	r7, sp, #0
 8001be6:	6078      	str	r0, [r7, #4]
  /* Check ADC handle */
  if(hadc == NULL)
 8001be8:	687b      	ldr	r3, [r7, #4]
 8001bea:	2b00      	cmp	r3, #0
 8001bec:	d101      	bne.n	8001bf2 <HAL_ADC_Init+0x12>
  {
     return HAL_ERROR;
 8001bee:	2301      	movs	r3, #1
 8001bf0:	e01f      	b.n	8001c32 <HAL_ADC_Init+0x52>
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
  {
    assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
  }
  
  if(hadc->State == HAL_ADC_STATE_RESET)
 8001bf2:	687b      	ldr	r3, [r7, #4]
 8001bf4:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8001bf8:	b2db      	uxtb	r3, r3
 8001bfa:	2b00      	cmp	r3, #0
 8001bfc:	d106      	bne.n	8001c0c <HAL_ADC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hadc->Lock = HAL_UNLOCKED;
 8001bfe:	687b      	ldr	r3, [r7, #4]
 8001c00:	2200      	movs	r2, #0
 8001c02:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 8001c06:	6878      	ldr	r0, [r7, #4]
 8001c08:	f7fe fc86 	bl	8000518 <HAL_ADC_MspInit>
  }
  
  /* Initialize the ADC state */
  hadc->State = HAL_ADC_STATE_BUSY;
 8001c0c:	687b      	ldr	r3, [r7, #4]
 8001c0e:	2202      	movs	r2, #2
 8001c10:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Set ADC parameters */
  ADC_Init(hadc);
 8001c14:	6878      	ldr	r0, [r7, #4]
 8001c16:	f000 fdfb 	bl	8002810 <ADC_Init>
  
  /* Set ADC error code to none */
  hadc->ErrorCode = HAL_ADC_ERROR_NONE;
 8001c1a:	687b      	ldr	r3, [r7, #4]
 8001c1c:	2200      	movs	r2, #0
 8001c1e:	641a      	str	r2, [r3, #64]	; 0x40
  
  /* Initialize the ADC state */
  hadc->State = HAL_ADC_STATE_READY;
 8001c20:	687b      	ldr	r3, [r7, #4]
 8001c22:	2201      	movs	r2, #1
 8001c24:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(hadc);
 8001c28:	687b      	ldr	r3, [r7, #4]
 8001c2a:	2200      	movs	r2, #0
 8001c2c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Return function status */
  return HAL_OK;
 8001c30:	2300      	movs	r3, #0
}
 8001c32:	4618      	mov	r0, r3
 8001c34:	3708      	adds	r7, #8
 8001c36:	46bd      	mov	sp, r7
 8001c38:	bd80      	pop	{r7, pc}
 8001c3a:	bf00      	nop

08001c3c <HAL_ADC_DeInit>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_DeInit(ADC_HandleTypeDef* hadc)
{
 8001c3c:	b580      	push	{r7, lr}
 8001c3e:	b082      	sub	sp, #8
 8001c40:	af00      	add	r7, sp, #0
 8001c42:	6078      	str	r0, [r7, #4]
  /* Check ADC handle */
  if(hadc == NULL)
 8001c44:	687b      	ldr	r3, [r7, #4]
 8001c46:	2b00      	cmp	r3, #0
 8001c48:	d101      	bne.n	8001c4e <HAL_ADC_DeInit+0x12>
  {
     return HAL_ERROR;
 8001c4a:	2301      	movs	r3, #1
 8001c4c:	e00e      	b.n	8001c6c <HAL_ADC_DeInit+0x30>
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_BUSY;
 8001c4e:	687b      	ldr	r3, [r7, #4]
 8001c50:	2202      	movs	r2, #2
 8001c52:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* DeInit the low level hardware */
  HAL_ADC_MspDeInit(hadc);
 8001c56:	6878      	ldr	r0, [r7, #4]
 8001c58:	f7fe fcf8 	bl	800064c <HAL_ADC_MspDeInit>
  
  /* Set ADC error code to none */
  hadc->ErrorCode = HAL_ADC_ERROR_NONE;
 8001c5c:	687b      	ldr	r3, [r7, #4]
 8001c5e:	2200      	movs	r2, #0
 8001c60:	641a      	str	r2, [r3, #64]	; 0x40
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_RESET;
 8001c62:	687b      	ldr	r3, [r7, #4]
 8001c64:	2200      	movs	r2, #0
 8001c66:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Return function status */
  return HAL_OK;
 8001c6a:	2300      	movs	r3, #0
}
 8001c6c:	4618      	mov	r0, r3
 8001c6e:	3708      	adds	r7, #8
 8001c70:	46bd      	mov	sp, r7
 8001c72:	bd80      	pop	{r7, pc}
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval None
  */
__weak void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 8001c74:	b480      	push	{r7}
 8001c76:	b083      	sub	sp, #12
 8001c78:	af00      	add	r7, sp, #0
 8001c7a:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_MspInit could be implemented in the user file
   */ 
}
 8001c7c:	370c      	adds	r7, #12
 8001c7e:	46bd      	mov	sp, r7
 8001c80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c84:	4770      	bx	lr
 8001c86:	bf00      	nop
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval None
  */
__weak void HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc)
{
 8001c88:	b480      	push	{r7}
 8001c8a:	b083      	sub	sp, #12
 8001c8c:	af00      	add	r7, sp, #0
 8001c8e:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_MspDeInit could be implemented in the user file
   */ 
}
 8001c90:	370c      	adds	r7, #12
 8001c92:	46bd      	mov	sp, r7
 8001c94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c98:	4770      	bx	lr
 8001c9a:	bf00      	nop

08001c9c <HAL_ADC_Start>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc)
{
 8001c9c:	b480      	push	{r7}
 8001c9e:	b085      	sub	sp, #20
 8001ca0:	af00      	add	r7, sp, #0
 8001ca2:	6078      	str	r0, [r7, #4]
  __IO uint32_t counter = 0;
 8001ca4:	2300      	movs	r3, #0
 8001ca6:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
  assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge)); 
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8001ca8:	687b      	ldr	r3, [r7, #4]
 8001caa:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8001cae:	2b01      	cmp	r3, #1
 8001cb0:	d101      	bne.n	8001cb6 <HAL_ADC_Start+0x1a>
 8001cb2:	2302      	movs	r3, #2
 8001cb4:	e06d      	b.n	8001d92 <HAL_ADC_Start+0xf6>
 8001cb6:	687b      	ldr	r3, [r7, #4]
 8001cb8:	2201      	movs	r2, #1
 8001cba:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Check if an injected conversion is ongoing */
  if(hadc->State == HAL_ADC_STATE_BUSY_INJ)
 8001cbe:	687b      	ldr	r3, [r7, #4]
 8001cc0:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8001cc4:	b2db      	uxtb	r3, r3
 8001cc6:	2b22      	cmp	r3, #34	; 0x22
 8001cc8:	d104      	bne.n	8001cd4 <HAL_ADC_Start+0x38>
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_INJ_REG;  
 8001cca:	687b      	ldr	r3, [r7, #4]
 8001ccc:	2232      	movs	r2, #50	; 0x32
 8001cce:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8001cd2:	e003      	b.n	8001cdc <HAL_ADC_Start+0x40>
  }
  else
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_REG;
 8001cd4:	687b      	ldr	r3, [r7, #4]
 8001cd6:	2212      	movs	r2, #18
 8001cd8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  } 
    
  /* Check if ADC peripheral is disabled in order to enable it and wait during 
  Tstab time the ADC's stabilization */
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 8001cdc:	687b      	ldr	r3, [r7, #4]
 8001cde:	681b      	ldr	r3, [r3, #0]
 8001ce0:	689b      	ldr	r3, [r3, #8]
 8001ce2:	f003 0301 	and.w	r3, r3, #1
 8001ce6:	2b00      	cmp	r3, #0
 8001ce8:	d11e      	bne.n	8001d28 <HAL_ADC_Start+0x8c>
  {  
    /* Enable the Peripheral */
    __HAL_ADC_ENABLE(hadc);
 8001cea:	687b      	ldr	r3, [r7, #4]
 8001cec:	681b      	ldr	r3, [r3, #0]
 8001cee:	687a      	ldr	r2, [r7, #4]
 8001cf0:	6812      	ldr	r2, [r2, #0]
 8001cf2:	6892      	ldr	r2, [r2, #8]
 8001cf4:	f042 0201 	orr.w	r2, r2, #1
 8001cf8:	609a      	str	r2, [r3, #8]
    
    /* Delay for ADC stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 8001cfa:	f240 0300 	movw	r3, #0
 8001cfe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001d02:	681a      	ldr	r2, [r3, #0]
 8001d04:	f64d 6383 	movw	r3, #56963	; 0xde83
 8001d08:	f2c4 331b 	movt	r3, #17179	; 0x431b
 8001d0c:	fba3 1302 	umull	r1, r3, r3, r2
 8001d10:	0c9a      	lsrs	r2, r3, #18
 8001d12:	4613      	mov	r3, r2
 8001d14:	005b      	lsls	r3, r3, #1
 8001d16:	4413      	add	r3, r2
 8001d18:	60fb      	str	r3, [r7, #12]
    while(counter != 0)
 8001d1a:	e002      	b.n	8001d22 <HAL_ADC_Start+0x86>
    {
      counter--;
 8001d1c:	68fb      	ldr	r3, [r7, #12]
 8001d1e:	3b01      	subs	r3, #1
 8001d20:	60fb      	str	r3, [r7, #12]
    __HAL_ADC_ENABLE(hadc);
    
    /* Delay for ADC stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
    while(counter != 0)
 8001d22:	68fb      	ldr	r3, [r7, #12]
 8001d24:	2b00      	cmp	r3, #0
 8001d26:	d1f9      	bne.n	8001d1c <HAL_ADC_Start+0x80>
      counter--;
    }
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8001d28:	687b      	ldr	r3, [r7, #4]
 8001d2a:	2200      	movs	r2, #0
 8001d2c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Check if Multimode enabled */
  if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
 8001d30:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 8001d34:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8001d38:	685b      	ldr	r3, [r3, #4]
 8001d3a:	f003 031f 	and.w	r3, r3, #31
 8001d3e:	2b00      	cmp	r3, #0
 8001d40:	d10f      	bne.n	8001d62 <HAL_ADC_Start+0xc6>
  {
    /* if no external trigger present enable software conversion of regular channels */
    if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
 8001d42:	687b      	ldr	r3, [r7, #4]
 8001d44:	681b      	ldr	r3, [r3, #0]
 8001d46:	689b      	ldr	r3, [r3, #8]
 8001d48:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 8001d4c:	2b00      	cmp	r3, #0
 8001d4e:	d11f      	bne.n	8001d90 <HAL_ADC_Start+0xf4>
    {
      /* Enable the selected ADC software conversion for regular group */
      hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 8001d50:	687b      	ldr	r3, [r7, #4]
 8001d52:	681b      	ldr	r3, [r3, #0]
 8001d54:	687a      	ldr	r2, [r7, #4]
 8001d56:	6812      	ldr	r2, [r2, #0]
 8001d58:	6892      	ldr	r2, [r2, #8]
 8001d5a:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8001d5e:	609a      	str	r2, [r3, #8]
 8001d60:	e016      	b.n	8001d90 <HAL_ADC_Start+0xf4>
    }
  }
  else
  {
    /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
    if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 8001d62:	687b      	ldr	r3, [r7, #4]
 8001d64:	681a      	ldr	r2, [r3, #0]
 8001d66:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001d6a:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8001d6e:	429a      	cmp	r2, r3
 8001d70:	d10e      	bne.n	8001d90 <HAL_ADC_Start+0xf4>
 8001d72:	687b      	ldr	r3, [r7, #4]
 8001d74:	681b      	ldr	r3, [r3, #0]
 8001d76:	689b      	ldr	r3, [r3, #8]
 8001d78:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 8001d7c:	2b00      	cmp	r3, #0
 8001d7e:	d107      	bne.n	8001d90 <HAL_ADC_Start+0xf4>
    {
      /* Enable the selected ADC software conversion for regular group */
        hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 8001d80:	687b      	ldr	r3, [r7, #4]
 8001d82:	681b      	ldr	r3, [r3, #0]
 8001d84:	687a      	ldr	r2, [r7, #4]
 8001d86:	6812      	ldr	r2, [r2, #0]
 8001d88:	6892      	ldr	r2, [r2, #8]
 8001d8a:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8001d8e:	609a      	str	r2, [r3, #8]
    }
  }
  
  /* Return function status */
  return HAL_OK;
 8001d90:	2300      	movs	r3, #0
}
 8001d92:	4618      	mov	r0, r3
 8001d94:	3714      	adds	r7, #20
 8001d96:	46bd      	mov	sp, r7
 8001d98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d9c:	4770      	bx	lr
 8001d9e:	bf00      	nop

08001da0 <HAL_ADC_Stop>:
  *         the configuration information for the specified ADC.
  *
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc)
{
 8001da0:	b480      	push	{r7}
 8001da2:	b083      	sub	sp, #12
 8001da4:	af00      	add	r7, sp, #0
 8001da6:	6078      	str	r0, [r7, #4]
  /* Disable the Peripheral */
  __HAL_ADC_DISABLE(hadc);
 8001da8:	687b      	ldr	r3, [r7, #4]
 8001daa:	681b      	ldr	r3, [r3, #0]
 8001dac:	687a      	ldr	r2, [r7, #4]
 8001dae:	6812      	ldr	r2, [r2, #0]
 8001db0:	6892      	ldr	r2, [r2, #8]
 8001db2:	f022 0201 	bic.w	r2, r2, #1
 8001db6:	609a      	str	r2, [r3, #8]
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_READY;
 8001db8:	687b      	ldr	r3, [r7, #4]
 8001dba:	2201      	movs	r2, #1
 8001dbc:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Return function status */
  return HAL_OK;
 8001dc0:	2300      	movs	r3, #0
}
 8001dc2:	4618      	mov	r0, r3
 8001dc4:	370c      	adds	r7, #12
 8001dc6:	46bd      	mov	sp, r7
 8001dc8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001dcc:	4770      	bx	lr
 8001dce:	bf00      	nop

08001dd0 <HAL_ADC_PollForConversion>:
  *         the configuration information for the specified ADC.
  * @param  Timeout: Timeout value in millisecond.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
{
 8001dd0:	b580      	push	{r7, lr}
 8001dd2:	b084      	sub	sp, #16
 8001dd4:	af00      	add	r7, sp, #0
 8001dd6:	6078      	str	r0, [r7, #4]
 8001dd8:	6039      	str	r1, [r7, #0]
  uint32_t tickstart = 0;
 8001dda:	2300      	movs	r3, #0
 8001ddc:	60fb      	str	r3, [r7, #12]
  /* each conversion:                                                       */
  /* Particular case is ADC configured in DMA mode and ADC sequencer with   */
  /* several ranks and polling for end of each conversion.                  */
  /* For code simplicity sake, this particular case is generalized to       */
  /* ADC configured in DMA mode and polling for end of each conversion.     */
  if (HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_EOCS) &&
 8001dde:	687b      	ldr	r3, [r7, #4]
 8001de0:	681b      	ldr	r3, [r3, #0]
 8001de2:	689b      	ldr	r3, [r3, #8]
 8001de4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8001de8:	2b00      	cmp	r3, #0
 8001dea:	d010      	beq.n	8001e0e <HAL_ADC_PollForConversion+0x3e>
      HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_DMA)    )
 8001dec:	687b      	ldr	r3, [r7, #4]
 8001dee:	681b      	ldr	r3, [r3, #0]
 8001df0:	689b      	ldr	r3, [r3, #8]
 8001df2:	f403 7380 	and.w	r3, r3, #256	; 0x100
  /* each conversion:                                                       */
  /* Particular case is ADC configured in DMA mode and ADC sequencer with   */
  /* several ranks and polling for end of each conversion.                  */
  /* For code simplicity sake, this particular case is generalized to       */
  /* ADC configured in DMA mode and polling for end of each conversion.     */
  if (HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_EOCS) &&
 8001df6:	2b00      	cmp	r3, #0
 8001df8:	d009      	beq.n	8001e0e <HAL_ADC_PollForConversion+0x3e>
      HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_DMA)    )
  {
    /* Update ADC state machine to error */
    hadc->State = HAL_ADC_STATE_ERROR;
 8001dfa:	687b      	ldr	r3, [r7, #4]
 8001dfc:	2204      	movs	r2, #4
 8001dfe:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    
    /* Process unlocked */
    __HAL_UNLOCK(hadc);
 8001e02:	687b      	ldr	r3, [r7, #4]
 8001e04:	2200      	movs	r2, #0
 8001e06:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    
    return HAL_ERROR;
 8001e0a:	2301      	movs	r3, #1
 8001e0c:	e033      	b.n	8001e76 <HAL_ADC_PollForConversion+0xa6>
  }

  /* Get tick */ 
  tickstart = HAL_GetTick();
 8001e0e:	f7ff fddb 	bl	80019c8 <HAL_GetTick>
 8001e12:	60f8      	str	r0, [r7, #12]

  /* Check End of conversion flag */
  while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC)))
 8001e14:	e018      	b.n	8001e48 <HAL_ADC_PollForConversion+0x78>
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 8001e16:	683b      	ldr	r3, [r7, #0]
 8001e18:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8001e1c:	d014      	beq.n	8001e48 <HAL_ADC_PollForConversion+0x78>
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8001e1e:	683b      	ldr	r3, [r7, #0]
 8001e20:	2b00      	cmp	r3, #0
 8001e22:	d007      	beq.n	8001e34 <HAL_ADC_PollForConversion+0x64>
 8001e24:	f7ff fdd0 	bl	80019c8 <HAL_GetTick>
 8001e28:	4602      	mov	r2, r0
 8001e2a:	68fb      	ldr	r3, [r7, #12]
 8001e2c:	1ad2      	subs	r2, r2, r3
 8001e2e:	683b      	ldr	r3, [r7, #0]
 8001e30:	429a      	cmp	r2, r3
 8001e32:	d909      	bls.n	8001e48 <HAL_ADC_PollForConversion+0x78>
      {
        hadc->State= HAL_ADC_STATE_TIMEOUT;
 8001e34:	687b      	ldr	r3, [r7, #4]
 8001e36:	2203      	movs	r2, #3
 8001e38:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        /* Process unlocked */
        __HAL_UNLOCK(hadc);
 8001e3c:	687b      	ldr	r3, [r7, #4]
 8001e3e:	2200      	movs	r2, #0
 8001e40:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
        return HAL_TIMEOUT;
 8001e44:	2303      	movs	r3, #3
 8001e46:	e016      	b.n	8001e76 <HAL_ADC_PollForConversion+0xa6>

  /* Get tick */ 
  tickstart = HAL_GetTick();

  /* Check End of conversion flag */
  while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC)))
 8001e48:	687b      	ldr	r3, [r7, #4]
 8001e4a:	681b      	ldr	r3, [r3, #0]
 8001e4c:	681b      	ldr	r3, [r3, #0]
 8001e4e:	f003 0302 	and.w	r3, r3, #2
 8001e52:	2b00      	cmp	r3, #0
 8001e54:	d0df      	beq.n	8001e16 <HAL_ADC_PollForConversion+0x46>
      }
    }
  }
  
  /* Check if an injected conversion is ready */
  if(hadc->State == HAL_ADC_STATE_EOC_INJ)
 8001e56:	687b      	ldr	r3, [r7, #4]
 8001e58:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8001e5c:	b2db      	uxtb	r3, r3
 8001e5e:	2b25      	cmp	r3, #37	; 0x25
 8001e60:	d104      	bne.n	8001e6c <HAL_ADC_PollForConversion+0x9c>
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
 8001e62:	687b      	ldr	r3, [r7, #4]
 8001e64:	2235      	movs	r2, #53	; 0x35
 8001e66:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8001e6a:	e003      	b.n	8001e74 <HAL_ADC_PollForConversion+0xa4>
  }
  else
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_EOC_REG;
 8001e6c:	687b      	ldr	r3, [r7, #4]
 8001e6e:	2215      	movs	r2, #21
 8001e70:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  }
  
  /* Return ADC state */
  return HAL_OK;
 8001e74:	2300      	movs	r3, #0
}
 8001e76:	4618      	mov	r0, r3
 8001e78:	3710      	adds	r7, #16
 8001e7a:	46bd      	mov	sp, r7
 8001e7c:	bd80      	pop	{r7, pc}
 8001e7e:	bf00      	nop

08001e80 <HAL_ADC_PollForEvent>:
  *            @arg ADC_OVR_EVENT: ADC Overrun event.
  * @param  Timeout: Timeout value in millisecond.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_PollForEvent(ADC_HandleTypeDef* hadc, uint32_t EventType, uint32_t Timeout)
{
 8001e80:	b580      	push	{r7, lr}
 8001e82:	b086      	sub	sp, #24
 8001e84:	af00      	add	r7, sp, #0
 8001e86:	60f8      	str	r0, [r7, #12]
 8001e88:	60b9      	str	r1, [r7, #8]
 8001e8a:	607a      	str	r2, [r7, #4]
  uint32_t tickstart = 0;
 8001e8c:	2300      	movs	r3, #0
 8001e8e:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_ADC_EVENT_TYPE(EventType));

  /* Get tick */
  tickstart = HAL_GetTick();
 8001e90:	f7ff fd9a 	bl	80019c8 <HAL_GetTick>
 8001e94:	6178      	str	r0, [r7, #20]

  /* Check selected event flag */
  while(!(__HAL_ADC_GET_FLAG(hadc,EventType)))
 8001e96:	e018      	b.n	8001eca <HAL_ADC_PollForEvent+0x4a>
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 8001e98:	687b      	ldr	r3, [r7, #4]
 8001e9a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8001e9e:	d014      	beq.n	8001eca <HAL_ADC_PollForEvent+0x4a>
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8001ea0:	687b      	ldr	r3, [r7, #4]
 8001ea2:	2b00      	cmp	r3, #0
 8001ea4:	d007      	beq.n	8001eb6 <HAL_ADC_PollForEvent+0x36>
 8001ea6:	f7ff fd8f 	bl	80019c8 <HAL_GetTick>
 8001eaa:	4602      	mov	r2, r0
 8001eac:	697b      	ldr	r3, [r7, #20]
 8001eae:	1ad2      	subs	r2, r2, r3
 8001eb0:	687b      	ldr	r3, [r7, #4]
 8001eb2:	429a      	cmp	r2, r3
 8001eb4:	d909      	bls.n	8001eca <HAL_ADC_PollForEvent+0x4a>
      {
        hadc->State= HAL_ADC_STATE_TIMEOUT;
 8001eb6:	68fb      	ldr	r3, [r7, #12]
 8001eb8:	2203      	movs	r2, #3
 8001eba:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        /* Process unlocked */
        __HAL_UNLOCK(hadc);
 8001ebe:	68fb      	ldr	r3, [r7, #12]
 8001ec0:	2200      	movs	r2, #0
 8001ec2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
        return HAL_TIMEOUT;
 8001ec6:	2303      	movs	r3, #3
 8001ec8:	e01e      	b.n	8001f08 <HAL_ADC_PollForEvent+0x88>

  /* Get tick */
  tickstart = HAL_GetTick();

  /* Check selected event flag */
  while(!(__HAL_ADC_GET_FLAG(hadc,EventType)))
 8001eca:	68fb      	ldr	r3, [r7, #12]
 8001ecc:	681b      	ldr	r3, [r3, #0]
 8001ece:	681a      	ldr	r2, [r3, #0]
 8001ed0:	68bb      	ldr	r3, [r7, #8]
 8001ed2:	401a      	ands	r2, r3
 8001ed4:	68bb      	ldr	r3, [r7, #8]
 8001ed6:	429a      	cmp	r2, r3
 8001ed8:	d1de      	bne.n	8001e98 <HAL_ADC_PollForEvent+0x18>
      }
    }
  }
  
  /* Check analog watchdog flag */
  if(EventType == ADC_AWD_EVENT)
 8001eda:	68bb      	ldr	r3, [r7, #8]
 8001edc:	2b01      	cmp	r3, #1
 8001ede:	d109      	bne.n	8001ef4 <HAL_ADC_PollForEvent+0x74>
  {
     /* Change ADC state */
     hadc->State = HAL_ADC_STATE_AWD;
 8001ee0:	68fb      	ldr	r3, [r7, #12]
 8001ee2:	2206      	movs	r2, #6
 8001ee4:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
      
     /* Clear the ADCx's analog watchdog flag */
     __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
 8001ee8:	68fb      	ldr	r3, [r7, #12]
 8001eea:	681b      	ldr	r3, [r3, #0]
 8001eec:	f06f 0201 	mvn.w	r2, #1
 8001ef0:	601a      	str	r2, [r3, #0]
 8001ef2:	e008      	b.n	8001f06 <HAL_ADC_PollForEvent+0x86>
  }
  else
  {
     /* Change ADC state */
     hadc->State = HAL_ADC_STATE_ERROR;
 8001ef4:	68fb      	ldr	r3, [r7, #12]
 8001ef6:	2204      	movs	r2, #4
 8001ef8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
     
     /* Clear the ADCx's Overrun flag */
     __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
 8001efc:	68fb      	ldr	r3, [r7, #12]
 8001efe:	681b      	ldr	r3, [r3, #0]
 8001f00:	f06f 0220 	mvn.w	r2, #32
 8001f04:	601a      	str	r2, [r3, #0]
  }
  
  /* Return ADC state */
  return HAL_OK;
 8001f06:	2300      	movs	r3, #0
}
 8001f08:	4618      	mov	r0, r3
 8001f0a:	3718      	adds	r7, #24
 8001f0c:	46bd      	mov	sp, r7
 8001f0e:	bd80      	pop	{r7, pc}

08001f10 <HAL_ADC_Start_IT>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef* hadc)
{
 8001f10:	b480      	push	{r7}
 8001f12:	b085      	sub	sp, #20
 8001f14:	af00      	add	r7, sp, #0
 8001f16:	6078      	str	r0, [r7, #4]
  __IO uint32_t counter = 0;
 8001f18:	2300      	movs	r3, #0
 8001f1a:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
  assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8001f1c:	687b      	ldr	r3, [r7, #4]
 8001f1e:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8001f22:	2b01      	cmp	r3, #1
 8001f24:	d101      	bne.n	8001f2a <HAL_ADC_Start_IT+0x1a>
 8001f26:	2302      	movs	r3, #2
 8001f28:	e080      	b.n	800202c <HAL_ADC_Start_IT+0x11c>
 8001f2a:	687b      	ldr	r3, [r7, #4]
 8001f2c:	2201      	movs	r2, #1
 8001f2e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Check if an injected conversion is ongoing */
  if(hadc->State == HAL_ADC_STATE_BUSY_INJ)
 8001f32:	687b      	ldr	r3, [r7, #4]
 8001f34:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8001f38:	b2db      	uxtb	r3, r3
 8001f3a:	2b22      	cmp	r3, #34	; 0x22
 8001f3c:	d104      	bne.n	8001f48 <HAL_ADC_Start_IT+0x38>
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_INJ_REG;  
 8001f3e:	687b      	ldr	r3, [r7, #4]
 8001f40:	2232      	movs	r2, #50	; 0x32
 8001f42:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8001f46:	e003      	b.n	8001f50 <HAL_ADC_Start_IT+0x40>
  }
  else
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_REG;
 8001f48:	687b      	ldr	r3, [r7, #4]
 8001f4a:	2212      	movs	r2, #18
 8001f4c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  } 
  
  /* Set ADC error code to none */
  hadc->ErrorCode = HAL_ADC_ERROR_NONE;
 8001f50:	687b      	ldr	r3, [r7, #4]
 8001f52:	2200      	movs	r2, #0
 8001f54:	641a      	str	r2, [r3, #64]	; 0x40
  
  /* Check if ADC peripheral is disabled in order to enable it and wait during 
     Tstab time the ADC's stabilization */
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 8001f56:	687b      	ldr	r3, [r7, #4]
 8001f58:	681b      	ldr	r3, [r3, #0]
 8001f5a:	689b      	ldr	r3, [r3, #8]
 8001f5c:	f003 0301 	and.w	r3, r3, #1
 8001f60:	2b00      	cmp	r3, #0
 8001f62:	d11e      	bne.n	8001fa2 <HAL_ADC_Start_IT+0x92>
  {  
    /* Enable the Peripheral */
    __HAL_ADC_ENABLE(hadc);
 8001f64:	687b      	ldr	r3, [r7, #4]
 8001f66:	681b      	ldr	r3, [r3, #0]
 8001f68:	687a      	ldr	r2, [r7, #4]
 8001f6a:	6812      	ldr	r2, [r2, #0]
 8001f6c:	6892      	ldr	r2, [r2, #8]
 8001f6e:	f042 0201 	orr.w	r2, r2, #1
 8001f72:	609a      	str	r2, [r3, #8]
    
    /* Delay for ADC stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 8001f74:	f240 0300 	movw	r3, #0
 8001f78:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001f7c:	681a      	ldr	r2, [r3, #0]
 8001f7e:	f64d 6383 	movw	r3, #56963	; 0xde83
 8001f82:	f2c4 331b 	movt	r3, #17179	; 0x431b
 8001f86:	fba3 1302 	umull	r1, r3, r3, r2
 8001f8a:	0c9a      	lsrs	r2, r3, #18
 8001f8c:	4613      	mov	r3, r2
 8001f8e:	005b      	lsls	r3, r3, #1
 8001f90:	4413      	add	r3, r2
 8001f92:	60fb      	str	r3, [r7, #12]
    while(counter != 0)
 8001f94:	e002      	b.n	8001f9c <HAL_ADC_Start_IT+0x8c>
    {
      counter--;
 8001f96:	68fb      	ldr	r3, [r7, #12]
 8001f98:	3b01      	subs	r3, #1
 8001f9a:	60fb      	str	r3, [r7, #12]
    __HAL_ADC_ENABLE(hadc);
    
    /* Delay for ADC stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
    while(counter != 0)
 8001f9c:	68fb      	ldr	r3, [r7, #12]
 8001f9e:	2b00      	cmp	r3, #0
 8001fa0:	d1f9      	bne.n	8001f96 <HAL_ADC_Start_IT+0x86>
      counter--;
    }
  }
  
  /* Enable the ADC overrun interrupt */
  __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 8001fa2:	687b      	ldr	r3, [r7, #4]
 8001fa4:	681b      	ldr	r3, [r3, #0]
 8001fa6:	687a      	ldr	r2, [r7, #4]
 8001fa8:	6812      	ldr	r2, [r2, #0]
 8001faa:	6852      	ldr	r2, [r2, #4]
 8001fac:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8001fb0:	605a      	str	r2, [r3, #4]
  
  /* Enable the ADC end of conversion interrupt for regular group */
  __HAL_ADC_ENABLE_IT(hadc, ADC_IT_EOC);
 8001fb2:	687b      	ldr	r3, [r7, #4]
 8001fb4:	681b      	ldr	r3, [r3, #0]
 8001fb6:	687a      	ldr	r2, [r7, #4]
 8001fb8:	6812      	ldr	r2, [r2, #0]
 8001fba:	6852      	ldr	r2, [r2, #4]
 8001fbc:	f042 0220 	orr.w	r2, r2, #32
 8001fc0:	605a      	str	r2, [r3, #4]
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8001fc2:	687b      	ldr	r3, [r7, #4]
 8001fc4:	2200      	movs	r2, #0
 8001fc6:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Check if Multimode enabled */
  if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
 8001fca:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 8001fce:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8001fd2:	685b      	ldr	r3, [r3, #4]
 8001fd4:	f003 031f 	and.w	r3, r3, #31
 8001fd8:	2b00      	cmp	r3, #0
 8001fda:	d10f      	bne.n	8001ffc <HAL_ADC_Start_IT+0xec>
  {
    /* if no external trigger present enable software conversion of regular channels */
    if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
 8001fdc:	687b      	ldr	r3, [r7, #4]
 8001fde:	681b      	ldr	r3, [r3, #0]
 8001fe0:	689b      	ldr	r3, [r3, #8]
 8001fe2:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 8001fe6:	2b00      	cmp	r3, #0
 8001fe8:	d11f      	bne.n	800202a <HAL_ADC_Start_IT+0x11a>
    {
      /* Enable the selected ADC software conversion for regular group */
      hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 8001fea:	687b      	ldr	r3, [r7, #4]
 8001fec:	681b      	ldr	r3, [r3, #0]
 8001fee:	687a      	ldr	r2, [r7, #4]
 8001ff0:	6812      	ldr	r2, [r2, #0]
 8001ff2:	6892      	ldr	r2, [r2, #8]
 8001ff4:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8001ff8:	609a      	str	r2, [r3, #8]
 8001ffa:	e016      	b.n	800202a <HAL_ADC_Start_IT+0x11a>
    }
  }
  else
  {
    /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
    if((hadc->Instance == (ADC_TypeDef*)0x40012000) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 8001ffc:	687b      	ldr	r3, [r7, #4]
 8001ffe:	681a      	ldr	r2, [r3, #0]
 8002000:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8002004:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8002008:	429a      	cmp	r2, r3
 800200a:	d10e      	bne.n	800202a <HAL_ADC_Start_IT+0x11a>
 800200c:	687b      	ldr	r3, [r7, #4]
 800200e:	681b      	ldr	r3, [r3, #0]
 8002010:	689b      	ldr	r3, [r3, #8]
 8002012:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 8002016:	2b00      	cmp	r3, #0
 8002018:	d107      	bne.n	800202a <HAL_ADC_Start_IT+0x11a>
    {
      /* Enable the selected ADC software conversion for regular group */
        hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 800201a:	687b      	ldr	r3, [r7, #4]
 800201c:	681b      	ldr	r3, [r3, #0]
 800201e:	687a      	ldr	r2, [r7, #4]
 8002020:	6812      	ldr	r2, [r2, #0]
 8002022:	6892      	ldr	r2, [r2, #8]
 8002024:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8002028:	609a      	str	r2, [r3, #8]
    }
  }

  /* Return function status */
  return HAL_OK;
 800202a:	2300      	movs	r3, #0
}
 800202c:	4618      	mov	r0, r3
 800202e:	3714      	adds	r7, #20
 8002030:	46bd      	mov	sp, r7
 8002032:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002036:	4770      	bx	lr

08002038 <HAL_ADC_Stop_IT>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef* hadc)
{
 8002038:	b480      	push	{r7}
 800203a:	b083      	sub	sp, #12
 800203c:	af00      	add	r7, sp, #0
 800203e:	6078      	str	r0, [r7, #4]
  /* Disable the ADC end of conversion interrupt for regular group */
  __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 8002040:	687b      	ldr	r3, [r7, #4]
 8002042:	681b      	ldr	r3, [r3, #0]
 8002044:	687a      	ldr	r2, [r7, #4]
 8002046:	6812      	ldr	r2, [r2, #0]
 8002048:	6852      	ldr	r2, [r2, #4]
 800204a:	f022 0220 	bic.w	r2, r2, #32
 800204e:	605a      	str	r2, [r3, #4]
  
  /* Disable the ADC end of conversion interrupt for injected group */
  __HAL_ADC_DISABLE_IT(hadc, ADC_CR1_JEOCIE);
 8002050:	687b      	ldr	r3, [r7, #4]
 8002052:	681b      	ldr	r3, [r3, #0]
 8002054:	687a      	ldr	r2, [r7, #4]
 8002056:	6812      	ldr	r2, [r2, #0]
 8002058:	6852      	ldr	r2, [r2, #4]
 800205a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800205e:	605a      	str	r2, [r3, #4]
  
  /* Enable the Peripheral */
  __HAL_ADC_DISABLE(hadc);
 8002060:	687b      	ldr	r3, [r7, #4]
 8002062:	681b      	ldr	r3, [r3, #0]
 8002064:	687a      	ldr	r2, [r7, #4]
 8002066:	6812      	ldr	r2, [r2, #0]
 8002068:	6892      	ldr	r2, [r2, #8]
 800206a:	f022 0201 	bic.w	r2, r2, #1
 800206e:	609a      	str	r2, [r3, #8]
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_READY;
 8002070:	687b      	ldr	r3, [r7, #4]
 8002072:	2201      	movs	r2, #1
 8002074:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Return function status */
  return HAL_OK;
 8002078:	2300      	movs	r3, #0
}
 800207a:	4618      	mov	r0, r3
 800207c:	370c      	adds	r7, #12
 800207e:	46bd      	mov	sp, r7
 8002080:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002084:	4770      	bx	lr
 8002086:	bf00      	nop

08002088 <HAL_ADC_IRQHandler>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */
void HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc)
{
 8002088:	b580      	push	{r7, lr}
 800208a:	b084      	sub	sp, #16
 800208c:	af00      	add	r7, sp, #0
 800208e:	6078      	str	r0, [r7, #4]
  uint32_t tmp1 = 0, tmp2 = 0;
 8002090:	2300      	movs	r3, #0
 8002092:	60fb      	str	r3, [r7, #12]
 8002094:	2300      	movs	r3, #0
 8002096:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
  assert_param(IS_ADC_REGULAR_LENGTH(hadc->Init.NbrOfConversion));
  assert_param(IS_ADC_EOCSelection(hadc->Init.EOCSelection));
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC);
 8002098:	687b      	ldr	r3, [r7, #4]
 800209a:	681b      	ldr	r3, [r3, #0]
 800209c:	681b      	ldr	r3, [r3, #0]
 800209e:	f003 0302 	and.w	r3, r3, #2
 80020a2:	2b00      	cmp	r3, #0
 80020a4:	bf0c      	ite	eq
 80020a6:	2300      	moveq	r3, #0
 80020a8:	2301      	movne	r3, #1
 80020aa:	b2db      	uxtb	r3, r3
 80020ac:	60fb      	str	r3, [r7, #12]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC);
 80020ae:	687b      	ldr	r3, [r7, #4]
 80020b0:	681b      	ldr	r3, [r3, #0]
 80020b2:	685b      	ldr	r3, [r3, #4]
 80020b4:	f003 0320 	and.w	r3, r3, #32
 80020b8:	2b00      	cmp	r3, #0
 80020ba:	bf0c      	ite	eq
 80020bc:	2300      	moveq	r3, #0
 80020be:	2301      	movne	r3, #1
 80020c0:	b2db      	uxtb	r3, r3
 80020c2:	60bb      	str	r3, [r7, #8]
  /* Check End of conversion flag for regular channels */
  if(tmp1 && tmp2)
 80020c4:	68fb      	ldr	r3, [r7, #12]
 80020c6:	2b00      	cmp	r3, #0
 80020c8:	d05a      	beq.n	8002180 <HAL_ADC_IRQHandler+0xf8>
 80020ca:	68bb      	ldr	r3, [r7, #8]
 80020cc:	2b00      	cmp	r3, #0
 80020ce:	d057      	beq.n	8002180 <HAL_ADC_IRQHandler+0xf8>
  {
    /* Check if an injected conversion is ready */
    if(hadc->State == HAL_ADC_STATE_EOC_INJ)
 80020d0:	687b      	ldr	r3, [r7, #4]
 80020d2:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80020d6:	b2db      	uxtb	r3, r3
 80020d8:	2b25      	cmp	r3, #37	; 0x25
 80020da:	d104      	bne.n	80020e6 <HAL_ADC_IRQHandler+0x5e>
    {
      /* Change ADC state */
      hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
 80020dc:	687b      	ldr	r3, [r7, #4]
 80020de:	2235      	movs	r2, #53	; 0x35
 80020e0:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 80020e4:	e003      	b.n	80020ee <HAL_ADC_IRQHandler+0x66>
    }
    else
    {
      /* Change ADC state */
      hadc->State = HAL_ADC_STATE_EOC_REG;
 80020e6:	687b      	ldr	r3, [r7, #4]
 80020e8:	2215      	movs	r2, #21
 80020ea:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    }
  
    if((hadc->Init.ContinuousConvMode == DISABLE) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 80020ee:	687b      	ldr	r3, [r7, #4]
 80020f0:	699b      	ldr	r3, [r3, #24]
 80020f2:	2b00      	cmp	r3, #0
 80020f4:	d13c      	bne.n	8002170 <HAL_ADC_IRQHandler+0xe8>
 80020f6:	687b      	ldr	r3, [r7, #4]
 80020f8:	681b      	ldr	r3, [r3, #0]
 80020fa:	689b      	ldr	r3, [r3, #8]
 80020fc:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 8002100:	2b00      	cmp	r3, #0
 8002102:	d135      	bne.n	8002170 <HAL_ADC_IRQHandler+0xe8>
    {
      if(hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 8002104:	687b      	ldr	r3, [r7, #4]
 8002106:	695b      	ldr	r3, [r3, #20]
 8002108:	2b00      	cmp	r3, #0
 800210a:	d110      	bne.n	800212e <HAL_ADC_IRQHandler+0xa6>
      {   
        /* DISABLE the ADC end of conversion interrupt for regular group */
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 800210c:	687b      	ldr	r3, [r7, #4]
 800210e:	681b      	ldr	r3, [r3, #0]
 8002110:	687a      	ldr	r2, [r7, #4]
 8002112:	6812      	ldr	r2, [r2, #0]
 8002114:	6852      	ldr	r2, [r2, #4]
 8002116:	f022 0220 	bic.w	r2, r2, #32
 800211a:	605a      	str	r2, [r3, #4]
        
        /* DISABLE the ADC overrun interrupt */
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
 800211c:	687b      	ldr	r3, [r7, #4]
 800211e:	681b      	ldr	r3, [r3, #0]
 8002120:	687a      	ldr	r2, [r7, #4]
 8002122:	6812      	ldr	r2, [r2, #0]
 8002124:	6852      	ldr	r2, [r2, #4]
 8002126:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 800212a:	605a      	str	r2, [r3, #4]
 800212c:	e020      	b.n	8002170 <HAL_ADC_IRQHandler+0xe8>
      }
      else
      {
        if (hadc->NbrOfCurrentConversionRank == 0)
 800212e:	687b      	ldr	r3, [r7, #4]
 8002130:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002132:	2b00      	cmp	r3, #0
 8002134:	d103      	bne.n	800213e <HAL_ADC_IRQHandler+0xb6>
        {
          hadc->NbrOfCurrentConversionRank = hadc->Init.NbrOfConversion;
 8002136:	687b      	ldr	r3, [r7, #4]
 8002138:	6a1a      	ldr	r2, [r3, #32]
 800213a:	687b      	ldr	r3, [r7, #4]
 800213c:	635a      	str	r2, [r3, #52]	; 0x34
        }
        
        /* Decrement the number of conversion when an interrupt occurs */
        hadc->NbrOfCurrentConversionRank--;
 800213e:	687b      	ldr	r3, [r7, #4]
 8002140:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002142:	1e5a      	subs	r2, r3, #1
 8002144:	687b      	ldr	r3, [r7, #4]
 8002146:	635a      	str	r2, [r3, #52]	; 0x34
        
        /* Check if all conversions are finished */
        if(hadc->NbrOfCurrentConversionRank == 0)
 8002148:	687b      	ldr	r3, [r7, #4]
 800214a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800214c:	2b00      	cmp	r3, #0
 800214e:	d10f      	bne.n	8002170 <HAL_ADC_IRQHandler+0xe8>
        {
          /* DISABLE the ADC end of conversion interrupt for regular group */
          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 8002150:	687b      	ldr	r3, [r7, #4]
 8002152:	681b      	ldr	r3, [r3, #0]
 8002154:	687a      	ldr	r2, [r7, #4]
 8002156:	6812      	ldr	r2, [r2, #0]
 8002158:	6852      	ldr	r2, [r2, #4]
 800215a:	f022 0220 	bic.w	r2, r2, #32
 800215e:	605a      	str	r2, [r3, #4]
          
          /* DISABLE the ADC overrun interrupt */
          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
 8002160:	687b      	ldr	r3, [r7, #4]
 8002162:	681b      	ldr	r3, [r3, #0]
 8002164:	687a      	ldr	r2, [r7, #4]
 8002166:	6812      	ldr	r2, [r2, #0]
 8002168:	6852      	ldr	r2, [r2, #4]
 800216a:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 800216e:	605a      	str	r2, [r3, #4]
        }
      }
    }
    
    /* Conversion complete callback */ 
    HAL_ADC_ConvCpltCallback(hadc);
 8002170:	6878      	ldr	r0, [r7, #4]
 8002172:	f000 f979 	bl	8002468 <HAL_ADC_ConvCpltCallback>
    
   /* Clear the ADCx flag for regular end of conversion */
    __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 8002176:	687b      	ldr	r3, [r7, #4]
 8002178:	681b      	ldr	r3, [r3, #0]
 800217a:	f06f 0202 	mvn.w	r2, #2
 800217e:	601a      	str	r2, [r3, #0]
  }
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC);
 8002180:	687b      	ldr	r3, [r7, #4]
 8002182:	681b      	ldr	r3, [r3, #0]
 8002184:	681b      	ldr	r3, [r3, #0]
 8002186:	f003 0304 	and.w	r3, r3, #4
 800218a:	2b00      	cmp	r3, #0
 800218c:	bf0c      	ite	eq
 800218e:	2300      	moveq	r3, #0
 8002190:	2301      	movne	r3, #1
 8002192:	b2db      	uxtb	r3, r3
 8002194:	60fb      	str	r3, [r7, #12]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC);                               
 8002196:	687b      	ldr	r3, [r7, #4]
 8002198:	681b      	ldr	r3, [r3, #0]
 800219a:	685b      	ldr	r3, [r3, #4]
 800219c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80021a0:	2b00      	cmp	r3, #0
 80021a2:	bf0c      	ite	eq
 80021a4:	2300      	moveq	r3, #0
 80021a6:	2301      	movne	r3, #1
 80021a8:	b2db      	uxtb	r3, r3
 80021aa:	60bb      	str	r3, [r7, #8]
  /* Check End of conversion flag for injected channels */
  if(tmp1 && tmp2)
 80021ac:	68fb      	ldr	r3, [r7, #12]
 80021ae:	2b00      	cmp	r3, #0
 80021b0:	d041      	beq.n	8002236 <HAL_ADC_IRQHandler+0x1ae>
 80021b2:	68bb      	ldr	r3, [r7, #8]
 80021b4:	2b00      	cmp	r3, #0
 80021b6:	d03e      	beq.n	8002236 <HAL_ADC_IRQHandler+0x1ae>
  {
    /* Check if a regular conversion is ready */
    if(hadc->State == HAL_ADC_STATE_EOC_REG)
 80021b8:	687b      	ldr	r3, [r7, #4]
 80021ba:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80021be:	b2db      	uxtb	r3, r3
 80021c0:	2b15      	cmp	r3, #21
 80021c2:	d104      	bne.n	80021ce <HAL_ADC_IRQHandler+0x146>
    {
      /* Change ADC state */
      hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
 80021c4:	687b      	ldr	r3, [r7, #4]
 80021c6:	2235      	movs	r2, #53	; 0x35
 80021c8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 80021cc:	e003      	b.n	80021d6 <HAL_ADC_IRQHandler+0x14e>
    }
    else
    {
      /* Change ADC state */
      hadc->State = HAL_ADC_STATE_EOC_INJ;
 80021ce:	687b      	ldr	r3, [r7, #4]
 80021d0:	2225      	movs	r2, #37	; 0x25
 80021d2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    }
    
    tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
 80021d6:	687b      	ldr	r3, [r7, #4]
 80021d8:	681b      	ldr	r3, [r3, #0]
 80021da:	685b      	ldr	r3, [r3, #4]
 80021dc:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80021e0:	2b00      	cmp	r3, #0
 80021e2:	bf14      	ite	ne
 80021e4:	2300      	movne	r3, #0
 80021e6:	2301      	moveq	r3, #1
 80021e8:	b2db      	uxtb	r3, r3
 80021ea:	60fb      	str	r3, [r7, #12]
    tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
 80021ec:	687b      	ldr	r3, [r7, #4]
 80021ee:	681b      	ldr	r3, [r3, #0]
 80021f0:	689b      	ldr	r3, [r3, #8]
 80021f2:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 80021f6:	2b00      	cmp	r3, #0
 80021f8:	bf14      	ite	ne
 80021fa:	2300      	movne	r3, #0
 80021fc:	2301      	moveq	r3, #1
 80021fe:	b2db      	uxtb	r3, r3
 8002200:	60bb      	str	r3, [r7, #8]
    if(((hadc->Init.ContinuousConvMode == DISABLE) || tmp1) && tmp2)
 8002202:	687b      	ldr	r3, [r7, #4]
 8002204:	699b      	ldr	r3, [r3, #24]
 8002206:	2b00      	cmp	r3, #0
 8002208:	d002      	beq.n	8002210 <HAL_ADC_IRQHandler+0x188>
 800220a:	68fb      	ldr	r3, [r7, #12]
 800220c:	2b00      	cmp	r3, #0
 800220e:	d00a      	beq.n	8002226 <HAL_ADC_IRQHandler+0x19e>
 8002210:	68bb      	ldr	r3, [r7, #8]
 8002212:	2b00      	cmp	r3, #0
 8002214:	d007      	beq.n	8002226 <HAL_ADC_IRQHandler+0x19e>
    {
      /* DISABLE the ADC end of conversion interrupt for injected group */
      __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
 8002216:	687b      	ldr	r3, [r7, #4]
 8002218:	681b      	ldr	r3, [r3, #0]
 800221a:	687a      	ldr	r2, [r7, #4]
 800221c:	6812      	ldr	r2, [r2, #0]
 800221e:	6852      	ldr	r2, [r2, #4]
 8002220:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8002224:	605a      	str	r2, [r3, #4]
    }
    
    /* Conversion complete callback */ 
    HAL_ADCEx_InjectedConvCpltCallback(hadc);
 8002226:	6878      	ldr	r0, [r7, #4]
 8002228:	f000 ff54 	bl	80030d4 <HAL_ADCEx_InjectedConvCpltCallback>
    
   /* Clear the ADCx flag for injected end of conversion */
    __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_JEOC);
 800222c:	687b      	ldr	r3, [r7, #4]
 800222e:	681b      	ldr	r3, [r3, #0]
 8002230:	f06f 0204 	mvn.w	r2, #4
 8002234:	601a      	str	r2, [r3, #0]
  }
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD);
 8002236:	687b      	ldr	r3, [r7, #4]
 8002238:	681b      	ldr	r3, [r3, #0]
 800223a:	681b      	ldr	r3, [r3, #0]
 800223c:	f003 0301 	and.w	r3, r3, #1
 8002240:	2b00      	cmp	r3, #0
 8002242:	bf0c      	ite	eq
 8002244:	2300      	moveq	r3, #0
 8002246:	2301      	movne	r3, #1
 8002248:	b2db      	uxtb	r3, r3
 800224a:	60fb      	str	r3, [r7, #12]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD);                          
 800224c:	687b      	ldr	r3, [r7, #4]
 800224e:	681b      	ldr	r3, [r3, #0]
 8002250:	685b      	ldr	r3, [r3, #4]
 8002252:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8002256:	2b00      	cmp	r3, #0
 8002258:	bf0c      	ite	eq
 800225a:	2300      	moveq	r3, #0
 800225c:	2301      	movne	r3, #1
 800225e:	b2db      	uxtb	r3, r3
 8002260:	60bb      	str	r3, [r7, #8]
  /* Check Analog watchdog flag */
  if(tmp1 && tmp2)
 8002262:	68fb      	ldr	r3, [r7, #12]
 8002264:	2b00      	cmp	r3, #0
 8002266:	d00e      	beq.n	8002286 <HAL_ADC_IRQHandler+0x1fe>
 8002268:	68bb      	ldr	r3, [r7, #8]
 800226a:	2b00      	cmp	r3, #0
 800226c:	d00b      	beq.n	8002286 <HAL_ADC_IRQHandler+0x1fe>
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_AWD;
 800226e:	687b      	ldr	r3, [r7, #4]
 8002270:	2206      	movs	r2, #6
 8002272:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
      
    /* Clear the ADCx's Analog watchdog flag */
    __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_AWD);
 8002276:	687b      	ldr	r3, [r7, #4]
 8002278:	681b      	ldr	r3, [r3, #0]
 800227a:	f06f 0201 	mvn.w	r2, #1
 800227e:	601a      	str	r2, [r3, #0]
    
    /* Level out of window callback */ 
    HAL_ADC_LevelOutOfWindowCallback(hadc);
 8002280:	6878      	ldr	r0, [r7, #4]
 8002282:	f000 f905 	bl	8002490 <HAL_ADC_LevelOutOfWindowCallback>
  }
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_OVR);
 8002286:	687b      	ldr	r3, [r7, #4]
 8002288:	681b      	ldr	r3, [r3, #0]
 800228a:	681b      	ldr	r3, [r3, #0]
 800228c:	f003 0320 	and.w	r3, r3, #32
 8002290:	2b00      	cmp	r3, #0
 8002292:	bf0c      	ite	eq
 8002294:	2300      	moveq	r3, #0
 8002296:	2301      	movne	r3, #1
 8002298:	b2db      	uxtb	r3, r3
 800229a:	60fb      	str	r3, [r7, #12]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_OVR);
 800229c:	687b      	ldr	r3, [r7, #4]
 800229e:	681b      	ldr	r3, [r3, #0]
 80022a0:	685b      	ldr	r3, [r3, #4]
 80022a2:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 80022a6:	2b00      	cmp	r3, #0
 80022a8:	bf0c      	ite	eq
 80022aa:	2300      	moveq	r3, #0
 80022ac:	2301      	movne	r3, #1
 80022ae:	b2db      	uxtb	r3, r3
 80022b0:	60bb      	str	r3, [r7, #8]
  /* Check Overrun flag */
  if(tmp1 && tmp2)
 80022b2:	68fb      	ldr	r3, [r7, #12]
 80022b4:	2b00      	cmp	r3, #0
 80022b6:	d014      	beq.n	80022e2 <HAL_ADC_IRQHandler+0x25a>
 80022b8:	68bb      	ldr	r3, [r7, #8]
 80022ba:	2b00      	cmp	r3, #0
 80022bc:	d011      	beq.n	80022e2 <HAL_ADC_IRQHandler+0x25a>
  {
    /* Change ADC state to overrun state */
    hadc->State = HAL_ADC_STATE_ERROR;
 80022be:	687b      	ldr	r3, [r7, #4]
 80022c0:	2204      	movs	r2, #4
 80022c2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    
    /* Set ADC error code to overrun */
    hadc->ErrorCode |= HAL_ADC_ERROR_OVR;
 80022c6:	687b      	ldr	r3, [r7, #4]
 80022c8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80022ca:	f043 0201 	orr.w	r2, r3, #1
 80022ce:	687b      	ldr	r3, [r7, #4]
 80022d0:	641a      	str	r2, [r3, #64]	; 0x40
    
    /* Clear the Overrun flag */
    __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_OVR);
 80022d2:	687b      	ldr	r3, [r7, #4]
 80022d4:	681b      	ldr	r3, [r3, #0]
 80022d6:	f06f 0220 	mvn.w	r2, #32
 80022da:	601a      	str	r2, [r3, #0]
    
    /* Error callback */ 
    HAL_ADC_ErrorCallback(hadc);
 80022dc:	6878      	ldr	r0, [r7, #4]
 80022de:	f000 f8e1 	bl	80024a4 <HAL_ADC_ErrorCallback>
  }
}
 80022e2:	3710      	adds	r7, #16
 80022e4:	46bd      	mov	sp, r7
 80022e6:	bd80      	pop	{r7, pc}

080022e8 <HAL_ADC_Start_DMA>:
  * @param  pData: The destination Buffer address.
  * @param  Length: The length of data to be transferred from ADC peripheral to memory.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
{
 80022e8:	b580      	push	{r7, lr}
 80022ea:	b086      	sub	sp, #24
 80022ec:	af00      	add	r7, sp, #0
 80022ee:	60f8      	str	r0, [r7, #12]
 80022f0:	60b9      	str	r1, [r7, #8]
 80022f2:	607a      	str	r2, [r7, #4]
  __IO uint32_t counter = 0;
 80022f4:	2300      	movs	r3, #0
 80022f6:	617b      	str	r3, [r7, #20]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
  assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 80022f8:	68fb      	ldr	r3, [r7, #12]
 80022fa:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80022fe:	2b01      	cmp	r3, #1
 8002300:	d101      	bne.n	8002306 <HAL_ADC_Start_DMA+0x1e>
 8002302:	2302      	movs	r3, #2
 8002304:	e073      	b.n	80023ee <HAL_ADC_Start_DMA+0x106>
 8002306:	68fb      	ldr	r3, [r7, #12]
 8002308:	2201      	movs	r2, #1
 800230a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Enable ADC overrun interrupt */
  __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 800230e:	68fb      	ldr	r3, [r7, #12]
 8002310:	681b      	ldr	r3, [r3, #0]
 8002312:	68fa      	ldr	r2, [r7, #12]
 8002314:	6812      	ldr	r2, [r2, #0]
 8002316:	6852      	ldr	r2, [r2, #4]
 8002318:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 800231c:	605a      	str	r2, [r3, #4]
  
  /* Enable ADC DMA mode */
  hadc->Instance->CR2 |= ADC_CR2_DMA;
 800231e:	68fb      	ldr	r3, [r7, #12]
 8002320:	681b      	ldr	r3, [r3, #0]
 8002322:	68fa      	ldr	r2, [r7, #12]
 8002324:	6812      	ldr	r2, [r2, #0]
 8002326:	6892      	ldr	r2, [r2, #8]
 8002328:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800232c:	609a      	str	r2, [r3, #8]
  
  /* Set the DMA transfer complete callback */
  hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 800232e:	68fb      	ldr	r3, [r7, #12]
 8002330:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002332:	f642 2329 	movw	r3, #10793	; 0x2a29
 8002336:	f6c0 0300 	movt	r3, #2048	; 0x800
 800233a:	63d3      	str	r3, [r2, #60]	; 0x3c
  
  /* Set the DMA half transfer complete callback */
  hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 800233c:	68fb      	ldr	r3, [r7, #12]
 800233e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002340:	f642 2361 	movw	r3, #10849	; 0x2a61
 8002344:	f6c0 0300 	movt	r3, #2048	; 0x800
 8002348:	6413      	str	r3, [r2, #64]	; 0x40
     
  /* Set the DMA error callback */
  hadc->DMA_Handle->XferErrorCallback = ADC_DMAError ;
 800234a:	68fb      	ldr	r3, [r7, #12]
 800234c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800234e:	f642 237d 	movw	r3, #10877	; 0x2a7d
 8002352:	f6c0 0300 	movt	r3, #2048	; 0x800
 8002356:	6493      	str	r3, [r2, #72]	; 0x48
  
  /* Enable the DMA Stream */
  HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
 8002358:	68fb      	ldr	r3, [r7, #12]
 800235a:	6b99      	ldr	r1, [r3, #56]	; 0x38
 800235c:	68fb      	ldr	r3, [r7, #12]
 800235e:	681b      	ldr	r3, [r3, #0]
 8002360:	334c      	adds	r3, #76	; 0x4c
 8002362:	461a      	mov	r2, r3
 8002364:	68bb      	ldr	r3, [r7, #8]
 8002366:	4608      	mov	r0, r1
 8002368:	4611      	mov	r1, r2
 800236a:	461a      	mov	r2, r3
 800236c:	687b      	ldr	r3, [r7, #4]
 800236e:	f002 f91b 	bl	80045a8 <HAL_DMA_Start_IT>
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_BUSY_REG;
 8002372:	68fb      	ldr	r3, [r7, #12]
 8002374:	2212      	movs	r2, #18
 8002376:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 800237a:	68fb      	ldr	r3, [r7, #12]
 800237c:	2200      	movs	r2, #0
 800237e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Check if ADC peripheral is disabled in order to enable it and wait during 
     Tstab time the ADC's stabilization */
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 8002382:	68fb      	ldr	r3, [r7, #12]
 8002384:	681b      	ldr	r3, [r3, #0]
 8002386:	689b      	ldr	r3, [r3, #8]
 8002388:	f003 0301 	and.w	r3, r3, #1
 800238c:	2b00      	cmp	r3, #0
 800238e:	d11e      	bne.n	80023ce <HAL_ADC_Start_DMA+0xe6>
  {  
    /* Enable the Peripheral */
    __HAL_ADC_ENABLE(hadc);
 8002390:	68fb      	ldr	r3, [r7, #12]
 8002392:	681b      	ldr	r3, [r3, #0]
 8002394:	68fa      	ldr	r2, [r7, #12]
 8002396:	6812      	ldr	r2, [r2, #0]
 8002398:	6892      	ldr	r2, [r2, #8]
 800239a:	f042 0201 	orr.w	r2, r2, #1
 800239e:	609a      	str	r2, [r3, #8]
    
    /* Delay for ADC stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 80023a0:	f240 0300 	movw	r3, #0
 80023a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80023a8:	681a      	ldr	r2, [r3, #0]
 80023aa:	f64d 6383 	movw	r3, #56963	; 0xde83
 80023ae:	f2c4 331b 	movt	r3, #17179	; 0x431b
 80023b2:	fba3 1302 	umull	r1, r3, r3, r2
 80023b6:	0c9a      	lsrs	r2, r3, #18
 80023b8:	4613      	mov	r3, r2
 80023ba:	005b      	lsls	r3, r3, #1
 80023bc:	4413      	add	r3, r2
 80023be:	617b      	str	r3, [r7, #20]
    while(counter != 0)
 80023c0:	e002      	b.n	80023c8 <HAL_ADC_Start_DMA+0xe0>
    {
      counter--;
 80023c2:	697b      	ldr	r3, [r7, #20]
 80023c4:	3b01      	subs	r3, #1
 80023c6:	617b      	str	r3, [r7, #20]
    __HAL_ADC_ENABLE(hadc);
    
    /* Delay for ADC stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
    while(counter != 0)
 80023c8:	697b      	ldr	r3, [r7, #20]
 80023ca:	2b00      	cmp	r3, #0
 80023cc:	d1f9      	bne.n	80023c2 <HAL_ADC_Start_DMA+0xda>
      counter--;
    }
  }
  
  /* if no external trigger present enable software conversion of regular channels */
  if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET)
 80023ce:	68fb      	ldr	r3, [r7, #12]
 80023d0:	681b      	ldr	r3, [r3, #0]
 80023d2:	689b      	ldr	r3, [r3, #8]
 80023d4:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 80023d8:	2b00      	cmp	r3, #0
 80023da:	d107      	bne.n	80023ec <HAL_ADC_Start_DMA+0x104>
  {
    /* Enable the selected ADC software conversion for regular group */
    hadc->Instance->CR2 |= ADC_CR2_SWSTART;
 80023dc:	68fb      	ldr	r3, [r7, #12]
 80023de:	681b      	ldr	r3, [r3, #0]
 80023e0:	68fa      	ldr	r2, [r7, #12]
 80023e2:	6812      	ldr	r2, [r2, #0]
 80023e4:	6892      	ldr	r2, [r2, #8]
 80023e6:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 80023ea:	609a      	str	r2, [r3, #8]
  }
  
  /* Return function status */
  return HAL_OK;
 80023ec:	2300      	movs	r3, #0
}
 80023ee:	4618      	mov	r0, r3
 80023f0:	3718      	adds	r7, #24
 80023f2:	46bd      	mov	sp, r7
 80023f4:	bd80      	pop	{r7, pc}
 80023f6:	bf00      	nop

080023f8 <HAL_ADC_Stop_DMA>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Stop_DMA(ADC_HandleTypeDef* hadc)
{
 80023f8:	b580      	push	{r7, lr}
 80023fa:	b082      	sub	sp, #8
 80023fc:	af00      	add	r7, sp, #0
 80023fe:	6078      	str	r0, [r7, #4]
  /* Disable the Peripheral */
  __HAL_ADC_DISABLE(hadc);
 8002400:	687b      	ldr	r3, [r7, #4]
 8002402:	681b      	ldr	r3, [r3, #0]
 8002404:	687a      	ldr	r2, [r7, #4]
 8002406:	6812      	ldr	r2, [r2, #0]
 8002408:	6892      	ldr	r2, [r2, #8]
 800240a:	f022 0201 	bic.w	r2, r2, #1
 800240e:	609a      	str	r2, [r3, #8]
  
  /* Disable ADC overrun interrupt */
  __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
 8002410:	687b      	ldr	r3, [r7, #4]
 8002412:	681b      	ldr	r3, [r3, #0]
 8002414:	687a      	ldr	r2, [r7, #4]
 8002416:	6812      	ldr	r2, [r2, #0]
 8002418:	6852      	ldr	r2, [r2, #4]
 800241a:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 800241e:	605a      	str	r2, [r3, #4]
  
  /* Disable the selected ADC DMA mode */
  hadc->Instance->CR2 &= ~ADC_CR2_DMA;
 8002420:	687b      	ldr	r3, [r7, #4]
 8002422:	681b      	ldr	r3, [r3, #0]
 8002424:	687a      	ldr	r2, [r7, #4]
 8002426:	6812      	ldr	r2, [r2, #0]
 8002428:	6892      	ldr	r2, [r2, #8]
 800242a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800242e:	609a      	str	r2, [r3, #8]
  
  /* Disable the ADC DMA Stream */
  HAL_DMA_Abort(hadc->DMA_Handle);
 8002430:	687b      	ldr	r3, [r7, #4]
 8002432:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002434:	4618      	mov	r0, r3
 8002436:	f002 f8f9 	bl	800462c <HAL_DMA_Abort>
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_READY;
 800243a:	687b      	ldr	r3, [r7, #4]
 800243c:	2201      	movs	r2, #1
 800243e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Return function status */
  return HAL_OK;
 8002442:	2300      	movs	r3, #0
}
 8002444:	4618      	mov	r0, r3
 8002446:	3708      	adds	r7, #8
 8002448:	46bd      	mov	sp, r7
 800244a:	bd80      	pop	{r7, pc}

0800244c <HAL_ADC_GetValue>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval Converted value
  */
uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc)
{       
 800244c:	b480      	push	{r7}
 800244e:	b083      	sub	sp, #12
 8002450:	af00      	add	r7, sp, #0
 8002452:	6078      	str	r0, [r7, #4]
  /* Return the selected ADC converted value */ 
  return hadc->Instance->DR;
 8002454:	687b      	ldr	r3, [r7, #4]
 8002456:	681b      	ldr	r3, [r3, #0]
 8002458:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
 800245a:	4618      	mov	r0, r3
 800245c:	370c      	adds	r7, #12
 800245e:	46bd      	mov	sp, r7
 8002460:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002464:	4770      	bx	lr
 8002466:	bf00      	nop

08002468 <HAL_ADC_ConvCpltCallback>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */
__weak void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
{
 8002468:	b480      	push	{r7}
 800246a:	b083      	sub	sp, #12
 800246c:	af00      	add	r7, sp, #0
 800246e:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_ConvCpltCallback could be implemented in the user file
   */
}
 8002470:	370c      	adds	r7, #12
 8002472:	46bd      	mov	sp, r7
 8002474:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002478:	4770      	bx	lr
 800247a:	bf00      	nop

0800247c <HAL_ADC_ConvHalfCpltCallback>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */
__weak void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc)
{
 800247c:	b480      	push	{r7}
 800247e:	b083      	sub	sp, #12
 8002480:	af00      	add	r7, sp, #0
 8002482:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_ConvHalfCpltCallback could be implemented in the user file
   */
}
 8002484:	370c      	adds	r7, #12
 8002486:	46bd      	mov	sp, r7
 8002488:	f85d 7b04 	ldr.w	r7, [sp], #4
 800248c:	4770      	bx	lr
 800248e:	bf00      	nop

08002490 <HAL_ADC_LevelOutOfWindowCallback>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */
__weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc)
{
 8002490:	b480      	push	{r7}
 8002492:	b083      	sub	sp, #12
 8002494:	af00      	add	r7, sp, #0
 8002496:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_LevelOoutOfWindowCallback could be implemented in the user file
   */
}
 8002498:	370c      	adds	r7, #12
 800249a:	46bd      	mov	sp, r7
 800249c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80024a0:	4770      	bx	lr
 80024a2:	bf00      	nop

080024a4 <HAL_ADC_ErrorCallback>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */
__weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
{
 80024a4:	b480      	push	{r7}
 80024a6:	b083      	sub	sp, #12
 80024a8:	af00      	add	r7, sp, #0
 80024aa:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_ErrorCallback could be implemented in the user file
   */
}
 80024ac:	370c      	adds	r7, #12
 80024ae:	46bd      	mov	sp, r7
 80024b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80024b4:	4770      	bx	lr
 80024b6:	bf00      	nop

080024b8 <HAL_ADC_ConfigChannel>:
  *         the configuration information for the specified ADC.
  * @param  sConfig: ADC configuration structure. 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{
 80024b8:	b490      	push	{r4, r7}
 80024ba:	b084      	sub	sp, #16
 80024bc:	af00      	add	r7, sp, #0
 80024be:	6078      	str	r0, [r7, #4]
 80024c0:	6039      	str	r1, [r7, #0]
  __IO uint32_t counter = 0;
 80024c2:	2300      	movs	r3, #0
 80024c4:	60fb      	str	r3, [r7, #12]
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 80024c6:	687b      	ldr	r3, [r7, #4]
 80024c8:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80024cc:	2b01      	cmp	r3, #1
 80024ce:	d101      	bne.n	80024d4 <HAL_ADC_ConfigChannel+0x1c>
 80024d0:	2302      	movs	r3, #2
 80024d2:	e11d      	b.n	8002710 <HAL_ADC_ConfigChannel+0x258>
 80024d4:	687b      	ldr	r3, [r7, #4]
 80024d6:	2201      	movs	r2, #1
 80024d8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (sConfig->Channel > ADC_CHANNEL_9)
 80024dc:	683b      	ldr	r3, [r7, #0]
 80024de:	681b      	ldr	r3, [r3, #0]
 80024e0:	2b09      	cmp	r3, #9
 80024e2:	d926      	bls.n	8002532 <HAL_ADC_ConfigChannel+0x7a>
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 80024e4:	687b      	ldr	r3, [r7, #4]
 80024e6:	6819      	ldr	r1, [r3, #0]
 80024e8:	687b      	ldr	r3, [r7, #4]
 80024ea:	681b      	ldr	r3, [r3, #0]
 80024ec:	68d8      	ldr	r0, [r3, #12]
 80024ee:	683b      	ldr	r3, [r7, #0]
 80024f0:	681b      	ldr	r3, [r3, #0]
 80024f2:	b29b      	uxth	r3, r3
 80024f4:	461a      	mov	r2, r3
 80024f6:	4613      	mov	r3, r2
 80024f8:	005b      	lsls	r3, r3, #1
 80024fa:	4413      	add	r3, r2
 80024fc:	3b1e      	subs	r3, #30
 80024fe:	2207      	movs	r2, #7
 8002500:	fa02 f303 	lsl.w	r3, r2, r3
 8002504:	43db      	mvns	r3, r3
 8002506:	4003      	ands	r3, r0
 8002508:	60cb      	str	r3, [r1, #12]
    
    /* Set the new sample time */
    hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
 800250a:	687b      	ldr	r3, [r7, #4]
 800250c:	6819      	ldr	r1, [r3, #0]
 800250e:	687b      	ldr	r3, [r7, #4]
 8002510:	681b      	ldr	r3, [r3, #0]
 8002512:	68d8      	ldr	r0, [r3, #12]
 8002514:	683b      	ldr	r3, [r7, #0]
 8002516:	689c      	ldr	r4, [r3, #8]
 8002518:	683b      	ldr	r3, [r7, #0]
 800251a:	681b      	ldr	r3, [r3, #0]
 800251c:	b29b      	uxth	r3, r3
 800251e:	461a      	mov	r2, r3
 8002520:	4613      	mov	r3, r2
 8002522:	005b      	lsls	r3, r3, #1
 8002524:	4413      	add	r3, r2
 8002526:	3b1e      	subs	r3, #30
 8002528:	fa04 f303 	lsl.w	r3, r4, r3
 800252c:	4303      	orrs	r3, r0
 800252e:	60cb      	str	r3, [r1, #12]
 8002530:	e023      	b.n	800257a <HAL_ADC_ConfigChannel+0xc2>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
 8002532:	687b      	ldr	r3, [r7, #4]
 8002534:	6819      	ldr	r1, [r3, #0]
 8002536:	687b      	ldr	r3, [r7, #4]
 8002538:	681b      	ldr	r3, [r3, #0]
 800253a:	6918      	ldr	r0, [r3, #16]
 800253c:	683b      	ldr	r3, [r7, #0]
 800253e:	681b      	ldr	r3, [r3, #0]
 8002540:	b29b      	uxth	r3, r3
 8002542:	461a      	mov	r2, r3
 8002544:	4613      	mov	r3, r2
 8002546:	005b      	lsls	r3, r3, #1
 8002548:	4413      	add	r3, r2
 800254a:	2207      	movs	r2, #7
 800254c:	fa02 f303 	lsl.w	r3, r2, r3
 8002550:	43db      	mvns	r3, r3
 8002552:	4003      	ands	r3, r0
 8002554:	610b      	str	r3, [r1, #16]
    
    /* Set the new sample time */
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
 8002556:	687b      	ldr	r3, [r7, #4]
 8002558:	6819      	ldr	r1, [r3, #0]
 800255a:	687b      	ldr	r3, [r7, #4]
 800255c:	681b      	ldr	r3, [r3, #0]
 800255e:	6918      	ldr	r0, [r3, #16]
 8002560:	683b      	ldr	r3, [r7, #0]
 8002562:	689c      	ldr	r4, [r3, #8]
 8002564:	683b      	ldr	r3, [r7, #0]
 8002566:	681b      	ldr	r3, [r3, #0]
 8002568:	b29b      	uxth	r3, r3
 800256a:	461a      	mov	r2, r3
 800256c:	4613      	mov	r3, r2
 800256e:	005b      	lsls	r3, r3, #1
 8002570:	4413      	add	r3, r2
 8002572:	fa04 f303 	lsl.w	r3, r4, r3
 8002576:	4303      	orrs	r3, r0
 8002578:	610b      	str	r3, [r1, #16]
  }
  
  /* For Rank 1 to 6 */
  if (sConfig->Rank < 7)
 800257a:	683b      	ldr	r3, [r7, #0]
 800257c:	685b      	ldr	r3, [r3, #4]
 800257e:	2b06      	cmp	r3, #6
 8002580:	d824      	bhi.n	80025cc <HAL_ADC_ConfigChannel+0x114>
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 8002582:	687b      	ldr	r3, [r7, #4]
 8002584:	6819      	ldr	r1, [r3, #0]
 8002586:	687b      	ldr	r3, [r7, #4]
 8002588:	681b      	ldr	r3, [r3, #0]
 800258a:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800258c:	683b      	ldr	r3, [r7, #0]
 800258e:	685a      	ldr	r2, [r3, #4]
 8002590:	4613      	mov	r3, r2
 8002592:	009b      	lsls	r3, r3, #2
 8002594:	4413      	add	r3, r2
 8002596:	3b05      	subs	r3, #5
 8002598:	221f      	movs	r2, #31
 800259a:	fa02 f303 	lsl.w	r3, r2, r3
 800259e:	43db      	mvns	r3, r3
 80025a0:	4003      	ands	r3, r0
 80025a2:	634b      	str	r3, [r1, #52]	; 0x34
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
 80025a4:	687b      	ldr	r3, [r7, #4]
 80025a6:	6819      	ldr	r1, [r3, #0]
 80025a8:	687b      	ldr	r3, [r7, #4]
 80025aa:	681b      	ldr	r3, [r3, #0]
 80025ac:	6b58      	ldr	r0, [r3, #52]	; 0x34
 80025ae:	683b      	ldr	r3, [r7, #0]
 80025b0:	681b      	ldr	r3, [r3, #0]
 80025b2:	b29b      	uxth	r3, r3
 80025b4:	461c      	mov	r4, r3
 80025b6:	683b      	ldr	r3, [r7, #0]
 80025b8:	685a      	ldr	r2, [r3, #4]
 80025ba:	4613      	mov	r3, r2
 80025bc:	009b      	lsls	r3, r3, #2
 80025be:	4413      	add	r3, r2
 80025c0:	3b05      	subs	r3, #5
 80025c2:	fa04 f303 	lsl.w	r3, r4, r3
 80025c6:	4303      	orrs	r3, r0
 80025c8:	634b      	str	r3, [r1, #52]	; 0x34
 80025ca:	e04c      	b.n	8002666 <HAL_ADC_ConfigChannel+0x1ae>
  }
  /* For Rank 7 to 12 */
  else if (sConfig->Rank < 13)
 80025cc:	683b      	ldr	r3, [r7, #0]
 80025ce:	685b      	ldr	r3, [r3, #4]
 80025d0:	2b0c      	cmp	r3, #12
 80025d2:	d824      	bhi.n	800261e <HAL_ADC_ConfigChannel+0x166>
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
 80025d4:	687b      	ldr	r3, [r7, #4]
 80025d6:	6819      	ldr	r1, [r3, #0]
 80025d8:	687b      	ldr	r3, [r7, #4]
 80025da:	681b      	ldr	r3, [r3, #0]
 80025dc:	6b18      	ldr	r0, [r3, #48]	; 0x30
 80025de:	683b      	ldr	r3, [r7, #0]
 80025e0:	685a      	ldr	r2, [r3, #4]
 80025e2:	4613      	mov	r3, r2
 80025e4:	009b      	lsls	r3, r3, #2
 80025e6:	4413      	add	r3, r2
 80025e8:	3b23      	subs	r3, #35	; 0x23
 80025ea:	221f      	movs	r2, #31
 80025ec:	fa02 f303 	lsl.w	r3, r2, r3
 80025f0:	43db      	mvns	r3, r3
 80025f2:	4003      	ands	r3, r0
 80025f4:	630b      	str	r3, [r1, #48]	; 0x30
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 80025f6:	687b      	ldr	r3, [r7, #4]
 80025f8:	6819      	ldr	r1, [r3, #0]
 80025fa:	687b      	ldr	r3, [r7, #4]
 80025fc:	681b      	ldr	r3, [r3, #0]
 80025fe:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8002600:	683b      	ldr	r3, [r7, #0]
 8002602:	681b      	ldr	r3, [r3, #0]
 8002604:	b29b      	uxth	r3, r3
 8002606:	461c      	mov	r4, r3
 8002608:	683b      	ldr	r3, [r7, #0]
 800260a:	685a      	ldr	r2, [r3, #4]
 800260c:	4613      	mov	r3, r2
 800260e:	009b      	lsls	r3, r3, #2
 8002610:	4413      	add	r3, r2
 8002612:	3b23      	subs	r3, #35	; 0x23
 8002614:	fa04 f303 	lsl.w	r3, r4, r3
 8002618:	4303      	orrs	r3, r0
 800261a:	630b      	str	r3, [r1, #48]	; 0x30
 800261c:	e023      	b.n	8002666 <HAL_ADC_ConfigChannel+0x1ae>
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
 800261e:	687b      	ldr	r3, [r7, #4]
 8002620:	6819      	ldr	r1, [r3, #0]
 8002622:	687b      	ldr	r3, [r7, #4]
 8002624:	681b      	ldr	r3, [r3, #0]
 8002626:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8002628:	683b      	ldr	r3, [r7, #0]
 800262a:	685a      	ldr	r2, [r3, #4]
 800262c:	4613      	mov	r3, r2
 800262e:	009b      	lsls	r3, r3, #2
 8002630:	4413      	add	r3, r2
 8002632:	3b41      	subs	r3, #65	; 0x41
 8002634:	221f      	movs	r2, #31
 8002636:	fa02 f303 	lsl.w	r3, r2, r3
 800263a:	43db      	mvns	r3, r3
 800263c:	4003      	ands	r3, r0
 800263e:	62cb      	str	r3, [r1, #44]	; 0x2c
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
 8002640:	687b      	ldr	r3, [r7, #4]
 8002642:	6819      	ldr	r1, [r3, #0]
 8002644:	687b      	ldr	r3, [r7, #4]
 8002646:	681b      	ldr	r3, [r3, #0]
 8002648:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 800264a:	683b      	ldr	r3, [r7, #0]
 800264c:	681b      	ldr	r3, [r3, #0]
 800264e:	b29b      	uxth	r3, r3
 8002650:	461c      	mov	r4, r3
 8002652:	683b      	ldr	r3, [r7, #0]
 8002654:	685a      	ldr	r2, [r3, #4]
 8002656:	4613      	mov	r3, r2
 8002658:	009b      	lsls	r3, r3, #2
 800265a:	4413      	add	r3, r2
 800265c:	3b41      	subs	r3, #65	; 0x41
 800265e:	fa04 f303 	lsl.w	r3, r4, r3
 8002662:	4303      	orrs	r3, r0
 8002664:	62cb      	str	r3, [r1, #44]	; 0x2c
  }
  
  /* if ADC1 Channel_18 is selected enable VBAT Channel */
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 8002666:	687b      	ldr	r3, [r7, #4]
 8002668:	681a      	ldr	r2, [r3, #0]
 800266a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800266e:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8002672:	429a      	cmp	r2, r3
 8002674:	d10f      	bne.n	8002696 <HAL_ADC_ConfigChannel+0x1de>
 8002676:	683b      	ldr	r3, [r7, #0]
 8002678:	681b      	ldr	r3, [r3, #0]
 800267a:	2b12      	cmp	r3, #18
 800267c:	d10b      	bne.n	8002696 <HAL_ADC_ConfigChannel+0x1de>
  {
    /* Enable the VBAT channel*/
    ADC->CCR |= ADC_CCR_VBATE;
 800267e:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 8002682:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8002686:	f44f 520c 	mov.w	r2, #8960	; 0x2300
 800268a:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800268e:	6852      	ldr	r2, [r2, #4]
 8002690:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8002694:	605a      	str	r2, [r3, #4]
  }
  
  /* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
 8002696:	687b      	ldr	r3, [r7, #4]
 8002698:	681a      	ldr	r2, [r3, #0]
 800269a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800269e:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80026a2:	429a      	cmp	r2, r3
 80026a4:	d12f      	bne.n	8002706 <HAL_ADC_ConfigChannel+0x24e>
 80026a6:	683b      	ldr	r3, [r7, #0]
 80026a8:	681b      	ldr	r3, [r3, #0]
 80026aa:	2b10      	cmp	r3, #16
 80026ac:	d003      	beq.n	80026b6 <HAL_ADC_ConfigChannel+0x1fe>
 80026ae:	683b      	ldr	r3, [r7, #0]
 80026b0:	681b      	ldr	r3, [r3, #0]
 80026b2:	2b11      	cmp	r3, #17
 80026b4:	d127      	bne.n	8002706 <HAL_ADC_ConfigChannel+0x24e>
  {
    /* Enable the TSVREFE channel*/
    ADC->CCR |= ADC_CCR_TSVREFE;
 80026b6:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 80026ba:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80026be:	f44f 520c 	mov.w	r2, #8960	; 0x2300
 80026c2:	f2c4 0201 	movt	r2, #16385	; 0x4001
 80026c6:	6852      	ldr	r2, [r2, #4]
 80026c8:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 80026cc:	605a      	str	r2, [r3, #4]
    
    if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
 80026ce:	683b      	ldr	r3, [r7, #0]
 80026d0:	681b      	ldr	r3, [r3, #0]
 80026d2:	2b10      	cmp	r3, #16
 80026d4:	d117      	bne.n	8002706 <HAL_ADC_ConfigChannel+0x24e>
    {
      /* Delay for temperature sensor stabilization time */
      /* Compute number of CPU cycles to wait for */
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
 80026d6:	f240 0300 	movw	r3, #0
 80026da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80026de:	681a      	ldr	r2, [r3, #0]
 80026e0:	f64d 6383 	movw	r3, #56963	; 0xde83
 80026e4:	f2c4 331b 	movt	r3, #17179	; 0x431b
 80026e8:	fba3 1302 	umull	r1, r3, r3, r2
 80026ec:	0c9a      	lsrs	r2, r3, #18
 80026ee:	4613      	mov	r3, r2
 80026f0:	009b      	lsls	r3, r3, #2
 80026f2:	4413      	add	r3, r2
 80026f4:	005b      	lsls	r3, r3, #1
 80026f6:	60fb      	str	r3, [r7, #12]
      while(counter != 0)
 80026f8:	e002      	b.n	8002700 <HAL_ADC_ConfigChannel+0x248>
      {
        counter--;
 80026fa:	68fb      	ldr	r3, [r7, #12]
 80026fc:	3b01      	subs	r3, #1
 80026fe:	60fb      	str	r3, [r7, #12]
    if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
    {
      /* Delay for temperature sensor stabilization time */
      /* Compute number of CPU cycles to wait for */
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
      while(counter != 0)
 8002700:	68fb      	ldr	r3, [r7, #12]
 8002702:	2b00      	cmp	r3, #0
 8002704:	d1f9      	bne.n	80026fa <HAL_ADC_ConfigChannel+0x242>
      }
    }
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8002706:	687b      	ldr	r3, [r7, #4]
 8002708:	2200      	movs	r2, #0
 800270a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 800270e:	2300      	movs	r3, #0
}
 8002710:	4618      	mov	r0, r3
 8002712:	3710      	adds	r7, #16
 8002714:	46bd      	mov	sp, r7
 8002716:	bc90      	pop	{r4, r7}
 8002718:	4770      	bx	lr
 800271a:	bf00      	nop

0800271c <HAL_ADC_AnalogWDGConfig>:
  * @param  AnalogWDGConfig : pointer to an ADC_AnalogWDGConfTypeDef structure 
  *         that contains the configuration information of ADC analog watchdog.
  * @retval HAL status	  
  */
HAL_StatusTypeDef HAL_ADC_AnalogWDGConfig(ADC_HandleTypeDef* hadc, ADC_AnalogWDGConfTypeDef* AnalogWDGConfig)
{
 800271c:	b480      	push	{r7}
 800271e:	b083      	sub	sp, #12
 8002720:	af00      	add	r7, sp, #0
 8002722:	6078      	str	r0, [r7, #4]
 8002724:	6039      	str	r1, [r7, #0]
  assert_param(IS_ADC_RANGE(tmp, AnalogWDGConfig->HighThreshold));
  assert_param(IS_ADC_RANGE(tmp, AnalogWDGConfig->LowThreshold));
#endif /* USE_FULL_ASSERT  */
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8002726:	687b      	ldr	r3, [r7, #4]
 8002728:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 800272c:	2b01      	cmp	r3, #1
 800272e:	d101      	bne.n	8002734 <HAL_ADC_AnalogWDGConfig+0x18>
 8002730:	2302      	movs	r3, #2
 8002732:	e04c      	b.n	80027ce <HAL_ADC_AnalogWDGConfig+0xb2>
 8002734:	687b      	ldr	r3, [r7, #4]
 8002736:	2201      	movs	r2, #1
 8002738:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  if(AnalogWDGConfig->ITMode == ENABLE)
 800273c:	683b      	ldr	r3, [r7, #0]
 800273e:	691b      	ldr	r3, [r3, #16]
 8002740:	2b01      	cmp	r3, #1
 8002742:	d108      	bne.n	8002756 <HAL_ADC_AnalogWDGConfig+0x3a>
  {
    /* Enable the ADC Analog watchdog interrupt */
    __HAL_ADC_ENABLE_IT(hadc, ADC_IT_AWD);
 8002744:	687b      	ldr	r3, [r7, #4]
 8002746:	681b      	ldr	r3, [r3, #0]
 8002748:	687a      	ldr	r2, [r7, #4]
 800274a:	6812      	ldr	r2, [r2, #0]
 800274c:	6852      	ldr	r2, [r2, #4]
 800274e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8002752:	605a      	str	r2, [r3, #4]
 8002754:	e007      	b.n	8002766 <HAL_ADC_AnalogWDGConfig+0x4a>
  }
  else
  {
    /* Disable the ADC Analog watchdog interrupt */
    __HAL_ADC_DISABLE_IT(hadc, ADC_IT_AWD);
 8002756:	687b      	ldr	r3, [r7, #4]
 8002758:	681b      	ldr	r3, [r3, #0]
 800275a:	687a      	ldr	r2, [r7, #4]
 800275c:	6812      	ldr	r2, [r2, #0]
 800275e:	6852      	ldr	r2, [r2, #4]
 8002760:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8002764:	605a      	str	r2, [r3, #4]
  }
  
  /* Clear AWDEN, JAWDEN and AWDSGL bits */
  hadc->Instance->CR1 &=  ~(ADC_CR1_AWDSGL | ADC_CR1_JAWDEN | ADC_CR1_AWDEN);
 8002766:	687b      	ldr	r3, [r7, #4]
 8002768:	681a      	ldr	r2, [r3, #0]
 800276a:	687b      	ldr	r3, [r7, #4]
 800276c:	681b      	ldr	r3, [r3, #0]
 800276e:	685b      	ldr	r3, [r3, #4]
 8002770:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 8002774:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8002778:	6053      	str	r3, [r2, #4]
  
  /* Set the analog watchdog enable mode */
  hadc->Instance->CR1 |= AnalogWDGConfig->WatchdogMode;
 800277a:	687b      	ldr	r3, [r7, #4]
 800277c:	681b      	ldr	r3, [r3, #0]
 800277e:	687a      	ldr	r2, [r7, #4]
 8002780:	6812      	ldr	r2, [r2, #0]
 8002782:	6851      	ldr	r1, [r2, #4]
 8002784:	683a      	ldr	r2, [r7, #0]
 8002786:	6812      	ldr	r2, [r2, #0]
 8002788:	430a      	orrs	r2, r1
 800278a:	605a      	str	r2, [r3, #4]
  
  /* Set the high threshold */
  hadc->Instance->HTR = AnalogWDGConfig->HighThreshold;
 800278c:	687b      	ldr	r3, [r7, #4]
 800278e:	681b      	ldr	r3, [r3, #0]
 8002790:	683a      	ldr	r2, [r7, #0]
 8002792:	6852      	ldr	r2, [r2, #4]
 8002794:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* Set the low threshold */
  hadc->Instance->LTR = AnalogWDGConfig->LowThreshold;
 8002796:	687b      	ldr	r3, [r7, #4]
 8002798:	681b      	ldr	r3, [r3, #0]
 800279a:	683a      	ldr	r2, [r7, #0]
 800279c:	6892      	ldr	r2, [r2, #8]
 800279e:	629a      	str	r2, [r3, #40]	; 0x28
  
  /* Clear the Analog watchdog channel select bits */
  hadc->Instance->CR1 &= ~ADC_CR1_AWDCH;
 80027a0:	687b      	ldr	r3, [r7, #4]
 80027a2:	681b      	ldr	r3, [r3, #0]
 80027a4:	687a      	ldr	r2, [r7, #4]
 80027a6:	6812      	ldr	r2, [r2, #0]
 80027a8:	6852      	ldr	r2, [r2, #4]
 80027aa:	f022 021f 	bic.w	r2, r2, #31
 80027ae:	605a      	str	r2, [r3, #4]
  
  /* Set the Analog watchdog channel */
  hadc->Instance->CR1 |= (uint32_t)((uint16_t)(AnalogWDGConfig->Channel));
 80027b0:	687b      	ldr	r3, [r7, #4]
 80027b2:	681b      	ldr	r3, [r3, #0]
 80027b4:	687a      	ldr	r2, [r7, #4]
 80027b6:	6812      	ldr	r2, [r2, #0]
 80027b8:	6851      	ldr	r1, [r2, #4]
 80027ba:	683a      	ldr	r2, [r7, #0]
 80027bc:	68d2      	ldr	r2, [r2, #12]
 80027be:	b292      	uxth	r2, r2
 80027c0:	430a      	orrs	r2, r1
 80027c2:	605a      	str	r2, [r3, #4]
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80027c4:	687b      	ldr	r3, [r7, #4]
 80027c6:	2200      	movs	r2, #0
 80027c8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 80027cc:	2300      	movs	r3, #0
}
 80027ce:	4618      	mov	r0, r3
 80027d0:	370c      	adds	r7, #12
 80027d2:	46bd      	mov	sp, r7
 80027d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80027d8:	4770      	bx	lr
 80027da:	bf00      	nop

080027dc <HAL_ADC_GetState>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL state
  */
HAL_ADC_StateTypeDef HAL_ADC_GetState(ADC_HandleTypeDef* hadc)
{
 80027dc:	b480      	push	{r7}
 80027de:	b083      	sub	sp, #12
 80027e0:	af00      	add	r7, sp, #0
 80027e2:	6078      	str	r0, [r7, #4]
  /* Return ADC state */
  return hadc->State;
 80027e4:	687b      	ldr	r3, [r7, #4]
 80027e6:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80027ea:	b2db      	uxtb	r3, r3
}
 80027ec:	4618      	mov	r0, r3
 80027ee:	370c      	adds	r7, #12
 80027f0:	46bd      	mov	sp, r7
 80027f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80027f6:	4770      	bx	lr

080027f8 <HAL_ADC_GetError>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval ADC Error Code
  */
uint32_t HAL_ADC_GetError(ADC_HandleTypeDef *hadc)
{
 80027f8:	b480      	push	{r7}
 80027fa:	b083      	sub	sp, #12
 80027fc:	af00      	add	r7, sp, #0
 80027fe:	6078      	str	r0, [r7, #4]
  return hadc->ErrorCode;
 8002800:	687b      	ldr	r3, [r7, #4]
 8002802:	6c1b      	ldr	r3, [r3, #64]	; 0x40
}
 8002804:	4618      	mov	r0, r3
 8002806:	370c      	adds	r7, #12
 8002808:	46bd      	mov	sp, r7
 800280a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800280e:	4770      	bx	lr

08002810 <ADC_Init>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval None
  */
static void ADC_Init(ADC_HandleTypeDef* hadc)
{
 8002810:	b480      	push	{r7}
 8002812:	b085      	sub	sp, #20
 8002814:	af00      	add	r7, sp, #0
 8002816:	6078      	str	r0, [r7, #4]
  /* Set ADC parameters */
  /* Set the ADC clock prescaler */
  ADC->CCR &= ~(ADC_CCR_ADCPRE);
 8002818:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 800281c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8002820:	f44f 520c 	mov.w	r2, #8960	; 0x2300
 8002824:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8002828:	6852      	ldr	r2, [r2, #4]
 800282a:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 800282e:	605a      	str	r2, [r3, #4]
  ADC->CCR |=  hadc->Init.ClockPrescaler;
 8002830:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 8002834:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8002838:	f44f 520c 	mov.w	r2, #8960	; 0x2300
 800283c:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8002840:	6851      	ldr	r1, [r2, #4]
 8002842:	687a      	ldr	r2, [r7, #4]
 8002844:	6852      	ldr	r2, [r2, #4]
 8002846:	430a      	orrs	r2, r1
 8002848:	605a      	str	r2, [r3, #4]
  
  /* Set ADC scan mode */
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 800284a:	687b      	ldr	r3, [r7, #4]
 800284c:	681b      	ldr	r3, [r3, #0]
 800284e:	687a      	ldr	r2, [r7, #4]
 8002850:	6812      	ldr	r2, [r2, #0]
 8002852:	6852      	ldr	r2, [r2, #4]
 8002854:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8002858:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 800285a:	687b      	ldr	r3, [r7, #4]
 800285c:	681b      	ldr	r3, [r3, #0]
 800285e:	687a      	ldr	r2, [r7, #4]
 8002860:	6812      	ldr	r2, [r2, #0]
 8002862:	6851      	ldr	r1, [r2, #4]
 8002864:	687a      	ldr	r2, [r7, #4]
 8002866:	6912      	ldr	r2, [r2, #16]
 8002868:	0212      	lsls	r2, r2, #8
 800286a:	430a      	orrs	r2, r1
 800286c:	605a      	str	r2, [r3, #4]
  
  /* Set ADC resolution */
  hadc->Instance->CR1 &= ~(ADC_CR1_RES);
 800286e:	687b      	ldr	r3, [r7, #4]
 8002870:	681b      	ldr	r3, [r3, #0]
 8002872:	687a      	ldr	r2, [r7, #4]
 8002874:	6812      	ldr	r2, [r2, #0]
 8002876:	6852      	ldr	r2, [r2, #4]
 8002878:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 800287c:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 800287e:	687b      	ldr	r3, [r7, #4]
 8002880:	681b      	ldr	r3, [r3, #0]
 8002882:	687a      	ldr	r2, [r7, #4]
 8002884:	6812      	ldr	r2, [r2, #0]
 8002886:	6851      	ldr	r1, [r2, #4]
 8002888:	687a      	ldr	r2, [r7, #4]
 800288a:	6892      	ldr	r2, [r2, #8]
 800288c:	430a      	orrs	r2, r1
 800288e:	605a      	str	r2, [r3, #4]
  
  /* Set ADC data alignment */
  hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
 8002890:	687b      	ldr	r3, [r7, #4]
 8002892:	681b      	ldr	r3, [r3, #0]
 8002894:	687a      	ldr	r2, [r7, #4]
 8002896:	6812      	ldr	r2, [r2, #0]
 8002898:	6892      	ldr	r2, [r2, #8]
 800289a:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 800289e:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 80028a0:	687b      	ldr	r3, [r7, #4]
 80028a2:	681b      	ldr	r3, [r3, #0]
 80028a4:	687a      	ldr	r2, [r7, #4]
 80028a6:	6812      	ldr	r2, [r2, #0]
 80028a8:	6891      	ldr	r1, [r2, #8]
 80028aa:	687a      	ldr	r2, [r7, #4]
 80028ac:	68d2      	ldr	r2, [r2, #12]
 80028ae:	430a      	orrs	r2, r1
 80028b0:	609a      	str	r2, [r3, #8]
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 80028b2:	687b      	ldr	r3, [r7, #4]
 80028b4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80028b6:	2301      	movs	r3, #1
 80028b8:	f6c0 7300 	movt	r3, #3840	; 0xf00
 80028bc:	429a      	cmp	r2, r3
 80028be:	d022      	beq.n	8002906 <ADC_Init+0xf6>
  {
    /* Select external trigger to start conversion */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 80028c0:	687b      	ldr	r3, [r7, #4]
 80028c2:	681b      	ldr	r3, [r3, #0]
 80028c4:	687a      	ldr	r2, [r7, #4]
 80028c6:	6812      	ldr	r2, [r2, #0]
 80028c8:	6892      	ldr	r2, [r2, #8]
 80028ca:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 80028ce:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
 80028d0:	687b      	ldr	r3, [r7, #4]
 80028d2:	681b      	ldr	r3, [r3, #0]
 80028d4:	687a      	ldr	r2, [r7, #4]
 80028d6:	6812      	ldr	r2, [r2, #0]
 80028d8:	6891      	ldr	r1, [r2, #8]
 80028da:	687a      	ldr	r2, [r7, #4]
 80028dc:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80028de:	430a      	orrs	r2, r1
 80028e0:	609a      	str	r2, [r3, #8]
    
    /* Select external trigger polarity */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 80028e2:	687b      	ldr	r3, [r7, #4]
 80028e4:	681b      	ldr	r3, [r3, #0]
 80028e6:	687a      	ldr	r2, [r7, #4]
 80028e8:	6812      	ldr	r2, [r2, #0]
 80028ea:	6892      	ldr	r2, [r2, #8]
 80028ec:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 80028f0:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
 80028f2:	687b      	ldr	r3, [r7, #4]
 80028f4:	681b      	ldr	r3, [r3, #0]
 80028f6:	687a      	ldr	r2, [r7, #4]
 80028f8:	6812      	ldr	r2, [r2, #0]
 80028fa:	6891      	ldr	r1, [r2, #8]
 80028fc:	687a      	ldr	r2, [r7, #4]
 80028fe:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8002900:	430a      	orrs	r2, r1
 8002902:	609a      	str	r2, [r3, #8]
 8002904:	e00f      	b.n	8002926 <ADC_Init+0x116>
  }
  else
  {
    /* Reset the external trigger */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 8002906:	687b      	ldr	r3, [r7, #4]
 8002908:	681b      	ldr	r3, [r3, #0]
 800290a:	687a      	ldr	r2, [r7, #4]
 800290c:	6812      	ldr	r2, [r2, #0]
 800290e:	6892      	ldr	r2, [r2, #8]
 8002910:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 8002914:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 8002916:	687b      	ldr	r3, [r7, #4]
 8002918:	681b      	ldr	r3, [r3, #0]
 800291a:	687a      	ldr	r2, [r7, #4]
 800291c:	6812      	ldr	r2, [r2, #0]
 800291e:	6892      	ldr	r2, [r2, #8]
 8002920:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 8002924:	609a      	str	r2, [r3, #8]
  }
  
  /* Enable or disable ADC continuous conversion mode */
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 8002926:	687b      	ldr	r3, [r7, #4]
 8002928:	681b      	ldr	r3, [r3, #0]
 800292a:	687a      	ldr	r2, [r7, #4]
 800292c:	6812      	ldr	r2, [r2, #0]
 800292e:	6892      	ldr	r2, [r2, #8]
 8002930:	f022 0202 	bic.w	r2, r2, #2
 8002934:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode);
 8002936:	687b      	ldr	r3, [r7, #4]
 8002938:	681b      	ldr	r3, [r3, #0]
 800293a:	687a      	ldr	r2, [r7, #4]
 800293c:	6812      	ldr	r2, [r2, #0]
 800293e:	6891      	ldr	r1, [r2, #8]
 8002940:	687a      	ldr	r2, [r7, #4]
 8002942:	6992      	ldr	r2, [r2, #24]
 8002944:	0052      	lsls	r2, r2, #1
 8002946:	430a      	orrs	r2, r1
 8002948:	609a      	str	r2, [r3, #8]
  
  if(hadc->Init.DiscontinuousConvMode != DISABLE)
 800294a:	687b      	ldr	r3, [r7, #4]
 800294c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800294e:	2b00      	cmp	r3, #0
 8002950:	d026      	beq.n	80029a0 <ADC_Init+0x190>
  {
    assert_param(IS_ADC_REGULAR_DISC_NUMBER(hadc->Init.NbrOfDiscConversion));
  
    /* Enable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 8002952:	687b      	ldr	r3, [r7, #4]
 8002954:	681b      	ldr	r3, [r3, #0]
 8002956:	687a      	ldr	r2, [r7, #4]
 8002958:	6812      	ldr	r2, [r2, #0]
 800295a:	6852      	ldr	r2, [r2, #4]
 800295c:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8002960:	605a      	str	r2, [r3, #4]
    
    /* Set the number of channels to be converted in discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
 8002962:	687b      	ldr	r3, [r7, #4]
 8002964:	681b      	ldr	r3, [r3, #0]
 8002966:	687a      	ldr	r2, [r7, #4]
 8002968:	6812      	ldr	r2, [r2, #0]
 800296a:	6852      	ldr	r2, [r2, #4]
 800296c:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 8002970:	605a      	str	r2, [r3, #4]
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 8002972:	687b      	ldr	r3, [r7, #4]
 8002974:	681b      	ldr	r3, [r3, #0]
 8002976:	687a      	ldr	r2, [r7, #4]
 8002978:	6812      	ldr	r2, [r2, #0]
 800297a:	6851      	ldr	r1, [r2, #4]
 800297c:	687a      	ldr	r2, [r7, #4]
 800297e:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8002980:	1e50      	subs	r0, r2, #1
 8002982:	f44f 4260 	mov.w	r2, #57344	; 0xe000
 8002986:	60fa      	str	r2, [r7, #12]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002988:	68fa      	ldr	r2, [r7, #12]
 800298a:	fa92 f2a2 	rbit	r2, r2
 800298e:	60ba      	str	r2, [r7, #8]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8002990:	68ba      	ldr	r2, [r7, #8]
 8002992:	fab2 f282 	clz	r2, r2
 8002996:	fa00 f202 	lsl.w	r2, r0, r2
 800299a:	430a      	orrs	r2, r1
 800299c:	605a      	str	r2, [r3, #4]
 800299e:	e007      	b.n	80029b0 <ADC_Init+0x1a0>
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
 80029a0:	687b      	ldr	r3, [r7, #4]
 80029a2:	681b      	ldr	r3, [r3, #0]
 80029a4:	687a      	ldr	r2, [r7, #4]
 80029a6:	6812      	ldr	r2, [r2, #0]
 80029a8:	6852      	ldr	r2, [r2, #4]
 80029aa:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80029ae:	605a      	str	r2, [r3, #4]
  }
  
  /* Set ADC number of conversion */
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 80029b0:	687b      	ldr	r3, [r7, #4]
 80029b2:	681b      	ldr	r3, [r3, #0]
 80029b4:	687a      	ldr	r2, [r7, #4]
 80029b6:	6812      	ldr	r2, [r2, #0]
 80029b8:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80029ba:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
 80029be:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 80029c0:	687b      	ldr	r3, [r7, #4]
 80029c2:	681b      	ldr	r3, [r3, #0]
 80029c4:	687a      	ldr	r2, [r7, #4]
 80029c6:	6812      	ldr	r2, [r2, #0]
 80029c8:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 80029ca:	687a      	ldr	r2, [r7, #4]
 80029cc:	6a12      	ldr	r2, [r2, #32]
 80029ce:	3a01      	subs	r2, #1
 80029d0:	0512      	lsls	r2, r2, #20
 80029d2:	430a      	orrs	r2, r1
 80029d4:	62da      	str	r2, [r3, #44]	; 0x2c
  
  /* Enable or disable ADC DMA continuous request */
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
 80029d6:	687b      	ldr	r3, [r7, #4]
 80029d8:	681b      	ldr	r3, [r3, #0]
 80029da:	687a      	ldr	r2, [r7, #4]
 80029dc:	6812      	ldr	r2, [r2, #0]
 80029de:	6892      	ldr	r2, [r2, #8]
 80029e0:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 80029e4:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq(hadc->Init.DMAContinuousRequests);
 80029e6:	687b      	ldr	r3, [r7, #4]
 80029e8:	681b      	ldr	r3, [r3, #0]
 80029ea:	687a      	ldr	r2, [r7, #4]
 80029ec:	6812      	ldr	r2, [r2, #0]
 80029ee:	6891      	ldr	r1, [r2, #8]
 80029f0:	687a      	ldr	r2, [r7, #4]
 80029f2:	69d2      	ldr	r2, [r2, #28]
 80029f4:	0252      	lsls	r2, r2, #9
 80029f6:	430a      	orrs	r2, r1
 80029f8:	609a      	str	r2, [r3, #8]
  
  /* Enable or disable ADC end of conversion selection */
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
 80029fa:	687b      	ldr	r3, [r7, #4]
 80029fc:	681b      	ldr	r3, [r3, #0]
 80029fe:	687a      	ldr	r2, [r7, #4]
 8002a00:	6812      	ldr	r2, [r2, #0]
 8002a02:	6892      	ldr	r2, [r2, #8]
 8002a04:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8002a08:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 8002a0a:	687b      	ldr	r3, [r7, #4]
 8002a0c:	681b      	ldr	r3, [r3, #0]
 8002a0e:	687a      	ldr	r2, [r7, #4]
 8002a10:	6812      	ldr	r2, [r2, #0]
 8002a12:	6891      	ldr	r1, [r2, #8]
 8002a14:	687a      	ldr	r2, [r7, #4]
 8002a16:	6952      	ldr	r2, [r2, #20]
 8002a18:	0292      	lsls	r2, r2, #10
 8002a1a:	430a      	orrs	r2, r1
 8002a1c:	609a      	str	r2, [r3, #8]
}
 8002a1e:	3714      	adds	r7, #20
 8002a20:	46bd      	mov	sp, r7
 8002a22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002a26:	4770      	bx	lr

08002a28 <ADC_DMAConvCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma)   
{
 8002a28:	b580      	push	{r7, lr}
 8002a2a:	b084      	sub	sp, #16
 8002a2c:	af00      	add	r7, sp, #0
 8002a2e:	6078      	str	r0, [r7, #4]
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8002a30:	687b      	ldr	r3, [r7, #4]
 8002a32:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002a34:	60fb      	str	r3, [r7, #12]
    
  /* Check if an injected conversion is ready */
  if(hadc->State == HAL_ADC_STATE_EOC_INJ)
 8002a36:	68fb      	ldr	r3, [r7, #12]
 8002a38:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8002a3c:	b2db      	uxtb	r3, r3
 8002a3e:	2b25      	cmp	r3, #37	; 0x25
 8002a40:	d104      	bne.n	8002a4c <ADC_DMAConvCplt+0x24>
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
 8002a42:	68fb      	ldr	r3, [r7, #12]
 8002a44:	2235      	movs	r2, #53	; 0x35
 8002a46:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8002a4a:	e003      	b.n	8002a54 <ADC_DMAConvCplt+0x2c>
  }
  else
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_EOC_REG;
 8002a4c:	68fb      	ldr	r3, [r7, #12]
 8002a4e:	2215      	movs	r2, #21
 8002a50:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  }
    
  HAL_ADC_ConvCpltCallback(hadc); 
 8002a54:	68f8      	ldr	r0, [r7, #12]
 8002a56:	f7ff fd07 	bl	8002468 <HAL_ADC_ConvCpltCallback>
}
 8002a5a:	3710      	adds	r7, #16
 8002a5c:	46bd      	mov	sp, r7
 8002a5e:	bd80      	pop	{r7, pc}

08002a60 <ADC_DMAHalfConvCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
{
 8002a60:	b580      	push	{r7, lr}
 8002a62:	b084      	sub	sp, #16
 8002a64:	af00      	add	r7, sp, #0
 8002a66:	6078      	str	r0, [r7, #4]
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8002a68:	687b      	ldr	r3, [r7, #4]
 8002a6a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002a6c:	60fb      	str	r3, [r7, #12]
  /* Conversion complete callback */
  HAL_ADC_ConvHalfCpltCallback(hadc); 
 8002a6e:	68f8      	ldr	r0, [r7, #12]
 8002a70:	f7ff fd04 	bl	800247c <HAL_ADC_ConvHalfCpltCallback>
}
 8002a74:	3710      	adds	r7, #16
 8002a76:	46bd      	mov	sp, r7
 8002a78:	bd80      	pop	{r7, pc}
 8002a7a:	bf00      	nop

08002a7c <ADC_DMAError>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void ADC_DMAError(DMA_HandleTypeDef *hdma)   
{
 8002a7c:	b580      	push	{r7, lr}
 8002a7e:	b084      	sub	sp, #16
 8002a80:	af00      	add	r7, sp, #0
 8002a82:	6078      	str	r0, [r7, #4]
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8002a84:	687b      	ldr	r3, [r7, #4]
 8002a86:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002a88:	60fb      	str	r3, [r7, #12]
  hadc->State= HAL_ADC_STATE_ERROR;
 8002a8a:	68fb      	ldr	r3, [r7, #12]
 8002a8c:	2204      	movs	r2, #4
 8002a8e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  /* Set ADC error code to DMA error */
  hadc->ErrorCode |= HAL_ADC_ERROR_DMA;
 8002a92:	68fb      	ldr	r3, [r7, #12]
 8002a94:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002a96:	f043 0202 	orr.w	r2, r3, #2
 8002a9a:	68fb      	ldr	r3, [r7, #12]
 8002a9c:	641a      	str	r2, [r3, #64]	; 0x40
  HAL_ADC_ErrorCallback(hadc); 
 8002a9e:	68f8      	ldr	r0, [r7, #12]
 8002aa0:	f7ff fd00 	bl	80024a4 <HAL_ADC_ErrorCallback>
}
 8002aa4:	3710      	adds	r7, #16
 8002aa6:	46bd      	mov	sp, r7
 8002aa8:	bd80      	pop	{r7, pc}
 8002aaa:	bf00      	nop

08002aac <HAL_ADCEx_InjectedStart>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedStart(ADC_HandleTypeDef* hadc)
{
 8002aac:	b480      	push	{r7}
 8002aae:	b087      	sub	sp, #28
 8002ab0:	af00      	add	r7, sp, #0
 8002ab2:	6078      	str	r0, [r7, #4]
  __IO uint32_t counter = 0;
 8002ab4:	2300      	movs	r3, #0
 8002ab6:	60fb      	str	r3, [r7, #12]
  uint32_t tmp1 = 0, tmp2 = 0;
 8002ab8:	2300      	movs	r3, #0
 8002aba:	617b      	str	r3, [r7, #20]
 8002abc:	2300      	movs	r3, #0
 8002abe:	613b      	str	r3, [r7, #16]
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8002ac0:	687b      	ldr	r3, [r7, #4]
 8002ac2:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8002ac6:	2b01      	cmp	r3, #1
 8002ac8:	d101      	bne.n	8002ace <HAL_ADCEx_InjectedStart+0x22>
 8002aca:	2302      	movs	r3, #2
 8002acc:	e097      	b.n	8002bfe <HAL_ADCEx_InjectedStart+0x152>
 8002ace:	687b      	ldr	r3, [r7, #4]
 8002ad0:	2201      	movs	r2, #1
 8002ad2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Check if a regular conversion is ongoing */
  if(hadc->State == HAL_ADC_STATE_BUSY_REG)
 8002ad6:	687b      	ldr	r3, [r7, #4]
 8002ad8:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8002adc:	b2db      	uxtb	r3, r3
 8002ade:	2b12      	cmp	r3, #18
 8002ae0:	d104      	bne.n	8002aec <HAL_ADCEx_InjectedStart+0x40>
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_INJ_REG;  
 8002ae2:	687b      	ldr	r3, [r7, #4]
 8002ae4:	2232      	movs	r2, #50	; 0x32
 8002ae6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8002aea:	e003      	b.n	8002af4 <HAL_ADCEx_InjectedStart+0x48>
  }
  else
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_INJ;
 8002aec:	687b      	ldr	r3, [r7, #4]
 8002aee:	2222      	movs	r2, #34	; 0x22
 8002af0:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  } 
  
  /* Check if ADC peripheral is disabled in order to enable it and wait during 
     Tstab time the ADC's stabilization */
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 8002af4:	687b      	ldr	r3, [r7, #4]
 8002af6:	681b      	ldr	r3, [r3, #0]
 8002af8:	689b      	ldr	r3, [r3, #8]
 8002afa:	f003 0301 	and.w	r3, r3, #1
 8002afe:	2b00      	cmp	r3, #0
 8002b00:	d11e      	bne.n	8002b40 <HAL_ADCEx_InjectedStart+0x94>
  {  
    /* Enable the Peripheral */
    __HAL_ADC_ENABLE(hadc);
 8002b02:	687b      	ldr	r3, [r7, #4]
 8002b04:	681b      	ldr	r3, [r3, #0]
 8002b06:	687a      	ldr	r2, [r7, #4]
 8002b08:	6812      	ldr	r2, [r2, #0]
 8002b0a:	6892      	ldr	r2, [r2, #8]
 8002b0c:	f042 0201 	orr.w	r2, r2, #1
 8002b10:	609a      	str	r2, [r3, #8]
    
    /* Delay for temperature sensor stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 8002b12:	f240 0300 	movw	r3, #0
 8002b16:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002b1a:	681a      	ldr	r2, [r3, #0]
 8002b1c:	f64d 6383 	movw	r3, #56963	; 0xde83
 8002b20:	f2c4 331b 	movt	r3, #17179	; 0x431b
 8002b24:	fba3 1302 	umull	r1, r3, r3, r2
 8002b28:	0c9a      	lsrs	r2, r3, #18
 8002b2a:	4613      	mov	r3, r2
 8002b2c:	005b      	lsls	r3, r3, #1
 8002b2e:	4413      	add	r3, r2
 8002b30:	60fb      	str	r3, [r7, #12]
    while(counter != 0)
 8002b32:	e002      	b.n	8002b3a <HAL_ADCEx_InjectedStart+0x8e>
    {
      counter--;
 8002b34:	68fb      	ldr	r3, [r7, #12]
 8002b36:	3b01      	subs	r3, #1
 8002b38:	60fb      	str	r3, [r7, #12]
    __HAL_ADC_ENABLE(hadc);
    
    /* Delay for temperature sensor stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
    while(counter != 0)
 8002b3a:	68fb      	ldr	r3, [r7, #12]
 8002b3c:	2b00      	cmp	r3, #0
 8002b3e:	d1f9      	bne.n	8002b34 <HAL_ADCEx_InjectedStart+0x88>
      counter--;
    }
  }
  
  /* Check if Multimode enabled */
  if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
 8002b40:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 8002b44:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8002b48:	685b      	ldr	r3, [r3, #4]
 8002b4a:	f003 031f 	and.w	r3, r3, #31
 8002b4e:	2b00      	cmp	r3, #0
 8002b50:	d124      	bne.n	8002b9c <HAL_ADCEx_InjectedStart+0xf0>
  {
    tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
 8002b52:	687b      	ldr	r3, [r7, #4]
 8002b54:	681b      	ldr	r3, [r3, #0]
 8002b56:	689b      	ldr	r3, [r3, #8]
 8002b58:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 8002b5c:	2b00      	cmp	r3, #0
 8002b5e:	bf14      	ite	ne
 8002b60:	2300      	movne	r3, #0
 8002b62:	2301      	moveq	r3, #1
 8002b64:	b2db      	uxtb	r3, r3
 8002b66:	617b      	str	r3, [r7, #20]
    tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
 8002b68:	687b      	ldr	r3, [r7, #4]
 8002b6a:	681b      	ldr	r3, [r3, #0]
 8002b6c:	685b      	ldr	r3, [r3, #4]
 8002b6e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8002b72:	2b00      	cmp	r3, #0
 8002b74:	bf14      	ite	ne
 8002b76:	2300      	movne	r3, #0
 8002b78:	2301      	moveq	r3, #1
 8002b7a:	b2db      	uxtb	r3, r3
 8002b7c:	613b      	str	r3, [r7, #16]
    if(tmp1 && tmp2)
 8002b7e:	697b      	ldr	r3, [r7, #20]
 8002b80:	2b00      	cmp	r3, #0
 8002b82:	d037      	beq.n	8002bf4 <HAL_ADCEx_InjectedStart+0x148>
 8002b84:	693b      	ldr	r3, [r7, #16]
 8002b86:	2b00      	cmp	r3, #0
 8002b88:	d034      	beq.n	8002bf4 <HAL_ADCEx_InjectedStart+0x148>
    {
      /* Enable the selected ADC software conversion for injected group */
      hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
 8002b8a:	687b      	ldr	r3, [r7, #4]
 8002b8c:	681b      	ldr	r3, [r3, #0]
 8002b8e:	687a      	ldr	r2, [r7, #4]
 8002b90:	6812      	ldr	r2, [r2, #0]
 8002b92:	6892      	ldr	r2, [r2, #8]
 8002b94:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8002b98:	609a      	str	r2, [r3, #8]
 8002b9a:	e02b      	b.n	8002bf4 <HAL_ADCEx_InjectedStart+0x148>
    }
  }
  else
  {
    tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
 8002b9c:	687b      	ldr	r3, [r7, #4]
 8002b9e:	681b      	ldr	r3, [r3, #0]
 8002ba0:	689b      	ldr	r3, [r3, #8]
 8002ba2:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 8002ba6:	2b00      	cmp	r3, #0
 8002ba8:	bf14      	ite	ne
 8002baa:	2300      	movne	r3, #0
 8002bac:	2301      	moveq	r3, #1
 8002bae:	b2db      	uxtb	r3, r3
 8002bb0:	617b      	str	r3, [r7, #20]
    tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
 8002bb2:	687b      	ldr	r3, [r7, #4]
 8002bb4:	681b      	ldr	r3, [r3, #0]
 8002bb6:	685b      	ldr	r3, [r3, #4]
 8002bb8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8002bbc:	2b00      	cmp	r3, #0
 8002bbe:	bf14      	ite	ne
 8002bc0:	2300      	movne	r3, #0
 8002bc2:	2301      	moveq	r3, #1
 8002bc4:	b2db      	uxtb	r3, r3
 8002bc6:	613b      	str	r3, [r7, #16]
    if((hadc->Instance == ADC1) && tmp1 && tmp2)  
 8002bc8:	687b      	ldr	r3, [r7, #4]
 8002bca:	681a      	ldr	r2, [r3, #0]
 8002bcc:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8002bd0:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8002bd4:	429a      	cmp	r2, r3
 8002bd6:	d10d      	bne.n	8002bf4 <HAL_ADCEx_InjectedStart+0x148>
 8002bd8:	697b      	ldr	r3, [r7, #20]
 8002bda:	2b00      	cmp	r3, #0
 8002bdc:	d00a      	beq.n	8002bf4 <HAL_ADCEx_InjectedStart+0x148>
 8002bde:	693b      	ldr	r3, [r7, #16]
 8002be0:	2b00      	cmp	r3, #0
 8002be2:	d007      	beq.n	8002bf4 <HAL_ADCEx_InjectedStart+0x148>
    {
      /* Enable the selected ADC software conversion for injected group */
      hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
 8002be4:	687b      	ldr	r3, [r7, #4]
 8002be6:	681b      	ldr	r3, [r3, #0]
 8002be8:	687a      	ldr	r2, [r7, #4]
 8002bea:	6812      	ldr	r2, [r2, #0]
 8002bec:	6892      	ldr	r2, [r2, #8]
 8002bee:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8002bf2:	609a      	str	r2, [r3, #8]
    }
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8002bf4:	687b      	ldr	r3, [r7, #4]
 8002bf6:	2200      	movs	r2, #0
 8002bf8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 8002bfc:	2300      	movs	r3, #0
}
 8002bfe:	4618      	mov	r0, r3
 8002c00:	371c      	adds	r7, #28
 8002c02:	46bd      	mov	sp, r7
 8002c04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c08:	4770      	bx	lr
 8002c0a:	bf00      	nop

08002c0c <HAL_ADCEx_InjectedStart_IT>:
  *         the configuration information for the specified ADC.
  *
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedStart_IT(ADC_HandleTypeDef* hadc)
{
 8002c0c:	b480      	push	{r7}
 8002c0e:	b087      	sub	sp, #28
 8002c10:	af00      	add	r7, sp, #0
 8002c12:	6078      	str	r0, [r7, #4]
  __IO uint32_t counter = 0;
 8002c14:	2300      	movs	r3, #0
 8002c16:	60fb      	str	r3, [r7, #12]
  uint32_t tmp1 = 0, tmp2 =0;
 8002c18:	2300      	movs	r3, #0
 8002c1a:	617b      	str	r3, [r7, #20]
 8002c1c:	2300      	movs	r3, #0
 8002c1e:	613b      	str	r3, [r7, #16]
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8002c20:	687b      	ldr	r3, [r7, #4]
 8002c22:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8002c26:	2b01      	cmp	r3, #1
 8002c28:	d101      	bne.n	8002c2e <HAL_ADCEx_InjectedStart_IT+0x22>
 8002c2a:	2302      	movs	r3, #2
 8002c2c:	e0aa      	b.n	8002d84 <HAL_ADCEx_InjectedStart_IT+0x178>
 8002c2e:	687b      	ldr	r3, [r7, #4]
 8002c30:	2201      	movs	r2, #1
 8002c32:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Check if a regular conversion is ongoing */
  if(hadc->State == HAL_ADC_STATE_BUSY_REG)
 8002c36:	687b      	ldr	r3, [r7, #4]
 8002c38:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8002c3c:	b2db      	uxtb	r3, r3
 8002c3e:	2b12      	cmp	r3, #18
 8002c40:	d104      	bne.n	8002c4c <HAL_ADCEx_InjectedStart_IT+0x40>
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_INJ_REG;  
 8002c42:	687b      	ldr	r3, [r7, #4]
 8002c44:	2232      	movs	r2, #50	; 0x32
 8002c46:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8002c4a:	e003      	b.n	8002c54 <HAL_ADCEx_InjectedStart_IT+0x48>
  }
  else
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_INJ;
 8002c4c:	687b      	ldr	r3, [r7, #4]
 8002c4e:	2222      	movs	r2, #34	; 0x22
 8002c50:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  }
  
  /* Set ADC error code to none */
  hadc->ErrorCode = HAL_ADC_ERROR_NONE;
 8002c54:	687b      	ldr	r3, [r7, #4]
 8002c56:	2200      	movs	r2, #0
 8002c58:	641a      	str	r2, [r3, #64]	; 0x40
  
  /* Check if ADC peripheral is disabled in order to enable it and wait during 
     Tstab time the ADC's stabilization */
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 8002c5a:	687b      	ldr	r3, [r7, #4]
 8002c5c:	681b      	ldr	r3, [r3, #0]
 8002c5e:	689b      	ldr	r3, [r3, #8]
 8002c60:	f003 0301 	and.w	r3, r3, #1
 8002c64:	2b00      	cmp	r3, #0
 8002c66:	d11e      	bne.n	8002ca6 <HAL_ADCEx_InjectedStart_IT+0x9a>
  {  
    /* Enable the Peripheral */
    __HAL_ADC_ENABLE(hadc);
 8002c68:	687b      	ldr	r3, [r7, #4]
 8002c6a:	681b      	ldr	r3, [r3, #0]
 8002c6c:	687a      	ldr	r2, [r7, #4]
 8002c6e:	6812      	ldr	r2, [r2, #0]
 8002c70:	6892      	ldr	r2, [r2, #8]
 8002c72:	f042 0201 	orr.w	r2, r2, #1
 8002c76:	609a      	str	r2, [r3, #8]
    
    /* Delay for temperature sensor stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 8002c78:	f240 0300 	movw	r3, #0
 8002c7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002c80:	681a      	ldr	r2, [r3, #0]
 8002c82:	f64d 6383 	movw	r3, #56963	; 0xde83
 8002c86:	f2c4 331b 	movt	r3, #17179	; 0x431b
 8002c8a:	fba3 1302 	umull	r1, r3, r3, r2
 8002c8e:	0c9a      	lsrs	r2, r3, #18
 8002c90:	4613      	mov	r3, r2
 8002c92:	005b      	lsls	r3, r3, #1
 8002c94:	4413      	add	r3, r2
 8002c96:	60fb      	str	r3, [r7, #12]
    while(counter != 0)
 8002c98:	e002      	b.n	8002ca0 <HAL_ADCEx_InjectedStart_IT+0x94>
    {
      counter--;
 8002c9a:	68fb      	ldr	r3, [r7, #12]
 8002c9c:	3b01      	subs	r3, #1
 8002c9e:	60fb      	str	r3, [r7, #12]
    __HAL_ADC_ENABLE(hadc);
    
    /* Delay for temperature sensor stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
    while(counter != 0)
 8002ca0:	68fb      	ldr	r3, [r7, #12]
 8002ca2:	2b00      	cmp	r3, #0
 8002ca4:	d1f9      	bne.n	8002c9a <HAL_ADCEx_InjectedStart_IT+0x8e>
      counter--;
    }
  }
  
  /* Enable the ADC end of conversion interrupt for injected group */
  __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
 8002ca6:	687b      	ldr	r3, [r7, #4]
 8002ca8:	681b      	ldr	r3, [r3, #0]
 8002caa:	687a      	ldr	r2, [r7, #4]
 8002cac:	6812      	ldr	r2, [r2, #0]
 8002cae:	6852      	ldr	r2, [r2, #4]
 8002cb0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8002cb4:	605a      	str	r2, [r3, #4]
  
  /* Enable the ADC overrun interrupt */
  __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 8002cb6:	687b      	ldr	r3, [r7, #4]
 8002cb8:	681b      	ldr	r3, [r3, #0]
 8002cba:	687a      	ldr	r2, [r7, #4]
 8002cbc:	6812      	ldr	r2, [r2, #0]
 8002cbe:	6852      	ldr	r2, [r2, #4]
 8002cc0:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8002cc4:	605a      	str	r2, [r3, #4]
  
  /* Check if Multimode enabled */
  if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
 8002cc6:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 8002cca:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8002cce:	685b      	ldr	r3, [r3, #4]
 8002cd0:	f003 031f 	and.w	r3, r3, #31
 8002cd4:	2b00      	cmp	r3, #0
 8002cd6:	d124      	bne.n	8002d22 <HAL_ADCEx_InjectedStart_IT+0x116>
  {
    tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
 8002cd8:	687b      	ldr	r3, [r7, #4]
 8002cda:	681b      	ldr	r3, [r3, #0]
 8002cdc:	689b      	ldr	r3, [r3, #8]
 8002cde:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 8002ce2:	2b00      	cmp	r3, #0
 8002ce4:	bf14      	ite	ne
 8002ce6:	2300      	movne	r3, #0
 8002ce8:	2301      	moveq	r3, #1
 8002cea:	b2db      	uxtb	r3, r3
 8002cec:	617b      	str	r3, [r7, #20]
    tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
 8002cee:	687b      	ldr	r3, [r7, #4]
 8002cf0:	681b      	ldr	r3, [r3, #0]
 8002cf2:	685b      	ldr	r3, [r3, #4]
 8002cf4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8002cf8:	2b00      	cmp	r3, #0
 8002cfa:	bf14      	ite	ne
 8002cfc:	2300      	movne	r3, #0
 8002cfe:	2301      	moveq	r3, #1
 8002d00:	b2db      	uxtb	r3, r3
 8002d02:	613b      	str	r3, [r7, #16]
    if(tmp1 && tmp2)
 8002d04:	697b      	ldr	r3, [r7, #20]
 8002d06:	2b00      	cmp	r3, #0
 8002d08:	d037      	beq.n	8002d7a <HAL_ADCEx_InjectedStart_IT+0x16e>
 8002d0a:	693b      	ldr	r3, [r7, #16]
 8002d0c:	2b00      	cmp	r3, #0
 8002d0e:	d034      	beq.n	8002d7a <HAL_ADCEx_InjectedStart_IT+0x16e>
    {
      /* Enable the selected ADC software conversion for injected group */
      hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
 8002d10:	687b      	ldr	r3, [r7, #4]
 8002d12:	681b      	ldr	r3, [r3, #0]
 8002d14:	687a      	ldr	r2, [r7, #4]
 8002d16:	6812      	ldr	r2, [r2, #0]
 8002d18:	6892      	ldr	r2, [r2, #8]
 8002d1a:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8002d1e:	609a      	str	r2, [r3, #8]
 8002d20:	e02b      	b.n	8002d7a <HAL_ADCEx_InjectedStart_IT+0x16e>
    }
  }
  else
  {
    tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
 8002d22:	687b      	ldr	r3, [r7, #4]
 8002d24:	681b      	ldr	r3, [r3, #0]
 8002d26:	689b      	ldr	r3, [r3, #8]
 8002d28:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 8002d2c:	2b00      	cmp	r3, #0
 8002d2e:	bf14      	ite	ne
 8002d30:	2300      	movne	r3, #0
 8002d32:	2301      	moveq	r3, #1
 8002d34:	b2db      	uxtb	r3, r3
 8002d36:	617b      	str	r3, [r7, #20]
    tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
 8002d38:	687b      	ldr	r3, [r7, #4]
 8002d3a:	681b      	ldr	r3, [r3, #0]
 8002d3c:	685b      	ldr	r3, [r3, #4]
 8002d3e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8002d42:	2b00      	cmp	r3, #0
 8002d44:	bf14      	ite	ne
 8002d46:	2300      	movne	r3, #0
 8002d48:	2301      	moveq	r3, #1
 8002d4a:	b2db      	uxtb	r3, r3
 8002d4c:	613b      	str	r3, [r7, #16]
    if((hadc->Instance == ADC1) && tmp1 && tmp2)  
 8002d4e:	687b      	ldr	r3, [r7, #4]
 8002d50:	681a      	ldr	r2, [r3, #0]
 8002d52:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8002d56:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8002d5a:	429a      	cmp	r2, r3
 8002d5c:	d10d      	bne.n	8002d7a <HAL_ADCEx_InjectedStart_IT+0x16e>
 8002d5e:	697b      	ldr	r3, [r7, #20]
 8002d60:	2b00      	cmp	r3, #0
 8002d62:	d00a      	beq.n	8002d7a <HAL_ADCEx_InjectedStart_IT+0x16e>
 8002d64:	693b      	ldr	r3, [r7, #16]
 8002d66:	2b00      	cmp	r3, #0
 8002d68:	d007      	beq.n	8002d7a <HAL_ADCEx_InjectedStart_IT+0x16e>
    {
      /* Enable the selected ADC software conversion for injected group */
      hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
 8002d6a:	687b      	ldr	r3, [r7, #4]
 8002d6c:	681b      	ldr	r3, [r3, #0]
 8002d6e:	687a      	ldr	r2, [r7, #4]
 8002d70:	6812      	ldr	r2, [r2, #0]
 8002d72:	6892      	ldr	r2, [r2, #8]
 8002d74:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8002d78:	609a      	str	r2, [r3, #8]
    }
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8002d7a:	687b      	ldr	r3, [r7, #4]
 8002d7c:	2200      	movs	r2, #0
 8002d7e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 8002d82:	2300      	movs	r3, #0
}
 8002d84:	4618      	mov	r0, r3
 8002d86:	371c      	adds	r7, #28
 8002d88:	46bd      	mov	sp, r7
 8002d8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002d8e:	4770      	bx	lr

08002d90 <HAL_ADCEx_InjectedStop>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedStop(ADC_HandleTypeDef* hadc)
{
 8002d90:	b480      	push	{r7}
 8002d92:	b083      	sub	sp, #12
 8002d94:	af00      	add	r7, sp, #0
 8002d96:	6078      	str	r0, [r7, #4]
  /* Disable the Peripheral */
  __HAL_ADC_DISABLE(hadc);
 8002d98:	687b      	ldr	r3, [r7, #4]
 8002d9a:	681b      	ldr	r3, [r3, #0]
 8002d9c:	687a      	ldr	r2, [r7, #4]
 8002d9e:	6812      	ldr	r2, [r2, #0]
 8002da0:	6892      	ldr	r2, [r2, #8]
 8002da2:	f022 0201 	bic.w	r2, r2, #1
 8002da6:	609a      	str	r2, [r3, #8]
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_READY;
 8002da8:	687b      	ldr	r3, [r7, #4]
 8002daa:	2201      	movs	r2, #1
 8002dac:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Return function status */
  return HAL_OK;
 8002db0:	2300      	movs	r3, #0
}
 8002db2:	4618      	mov	r0, r3
 8002db4:	370c      	adds	r7, #12
 8002db6:	46bd      	mov	sp, r7
 8002db8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002dbc:	4770      	bx	lr
 8002dbe:	bf00      	nop

08002dc0 <HAL_ADCEx_InjectedPollForConversion>:
  *         the configuration information for the specified ADC.
  * @param  Timeout: Timeout value in millisecond.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedPollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
{
 8002dc0:	b580      	push	{r7, lr}
 8002dc2:	b084      	sub	sp, #16
 8002dc4:	af00      	add	r7, sp, #0
 8002dc6:	6078      	str	r0, [r7, #4]
 8002dc8:	6039      	str	r1, [r7, #0]
  uint32_t tickstart = 0;
 8002dca:	2300      	movs	r3, #0
 8002dcc:	60fb      	str	r3, [r7, #12]

  /* Get tick */ 
  tickstart = HAL_GetTick();
 8002dce:	f7fe fdfb 	bl	80019c8 <HAL_GetTick>
 8002dd2:	60f8      	str	r0, [r7, #12]

  /* Check End of conversion flag */
  while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC)))
 8002dd4:	e018      	b.n	8002e08 <HAL_ADCEx_InjectedPollForConversion+0x48>
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 8002dd6:	683b      	ldr	r3, [r7, #0]
 8002dd8:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8002ddc:	d014      	beq.n	8002e08 <HAL_ADCEx_InjectedPollForConversion+0x48>
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8002dde:	683b      	ldr	r3, [r7, #0]
 8002de0:	2b00      	cmp	r3, #0
 8002de2:	d007      	beq.n	8002df4 <HAL_ADCEx_InjectedPollForConversion+0x34>
 8002de4:	f7fe fdf0 	bl	80019c8 <HAL_GetTick>
 8002de8:	4602      	mov	r2, r0
 8002dea:	68fb      	ldr	r3, [r7, #12]
 8002dec:	1ad2      	subs	r2, r2, r3
 8002dee:	683b      	ldr	r3, [r7, #0]
 8002df0:	429a      	cmp	r2, r3
 8002df2:	d909      	bls.n	8002e08 <HAL_ADCEx_InjectedPollForConversion+0x48>
      {
        hadc->State= HAL_ADC_STATE_TIMEOUT;
 8002df4:	687b      	ldr	r3, [r7, #4]
 8002df6:	2203      	movs	r2, #3
 8002df8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        /* Process unlocked */
        __HAL_UNLOCK(hadc);
 8002dfc:	687b      	ldr	r3, [r7, #4]
 8002dfe:	2200      	movs	r2, #0
 8002e00:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
        return HAL_TIMEOUT;
 8002e04:	2303      	movs	r3, #3
 8002e06:	e016      	b.n	8002e36 <HAL_ADCEx_InjectedPollForConversion+0x76>

  /* Get tick */ 
  tickstart = HAL_GetTick();

  /* Check End of conversion flag */
  while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC)))
 8002e08:	687b      	ldr	r3, [r7, #4]
 8002e0a:	681b      	ldr	r3, [r3, #0]
 8002e0c:	681b      	ldr	r3, [r3, #0]
 8002e0e:	f003 0304 	and.w	r3, r3, #4
 8002e12:	2b00      	cmp	r3, #0
 8002e14:	d0df      	beq.n	8002dd6 <HAL_ADCEx_InjectedPollForConversion+0x16>
      }
    }
  }
  
  /* Check if a regular conversion is ready */
  if(hadc->State == HAL_ADC_STATE_EOC_REG)
 8002e16:	687b      	ldr	r3, [r7, #4]
 8002e18:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8002e1c:	b2db      	uxtb	r3, r3
 8002e1e:	2b15      	cmp	r3, #21
 8002e20:	d104      	bne.n	8002e2c <HAL_ADCEx_InjectedPollForConversion+0x6c>
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
 8002e22:	687b      	ldr	r3, [r7, #4]
 8002e24:	2235      	movs	r2, #53	; 0x35
 8002e26:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8002e2a:	e003      	b.n	8002e34 <HAL_ADCEx_InjectedPollForConversion+0x74>
  }
  else
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_EOC_INJ;
 8002e2c:	687b      	ldr	r3, [r7, #4]
 8002e2e:	2225      	movs	r2, #37	; 0x25
 8002e30:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  }
  
  /* Return ADC state */
  return HAL_OK;
 8002e34:	2300      	movs	r3, #0
}      
 8002e36:	4618      	mov	r0, r3
 8002e38:	3710      	adds	r7, #16
 8002e3a:	46bd      	mov	sp, r7
 8002e3c:	bd80      	pop	{r7, pc}
 8002e3e:	bf00      	nop

08002e40 <HAL_ADCEx_InjectedStop_IT>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedStop_IT(ADC_HandleTypeDef* hadc)
{
 8002e40:	b480      	push	{r7}
 8002e42:	b083      	sub	sp, #12
 8002e44:	af00      	add	r7, sp, #0
 8002e46:	6078      	str	r0, [r7, #4]
  /* Disable the ADC end of conversion interrupt for regular group */
  __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 8002e48:	687b      	ldr	r3, [r7, #4]
 8002e4a:	681b      	ldr	r3, [r3, #0]
 8002e4c:	687a      	ldr	r2, [r7, #4]
 8002e4e:	6812      	ldr	r2, [r2, #0]
 8002e50:	6852      	ldr	r2, [r2, #4]
 8002e52:	f022 0220 	bic.w	r2, r2, #32
 8002e56:	605a      	str	r2, [r3, #4]
  
  /* Disable the ADC end of conversion interrupt for injected group */
  __HAL_ADC_DISABLE_IT(hadc, ADC_CR1_JEOCIE);
 8002e58:	687b      	ldr	r3, [r7, #4]
 8002e5a:	681b      	ldr	r3, [r3, #0]
 8002e5c:	687a      	ldr	r2, [r7, #4]
 8002e5e:	6812      	ldr	r2, [r2, #0]
 8002e60:	6852      	ldr	r2, [r2, #4]
 8002e62:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8002e66:	605a      	str	r2, [r3, #4]
  
  /* Enable the Peripheral */
  __HAL_ADC_DISABLE(hadc);
 8002e68:	687b      	ldr	r3, [r7, #4]
 8002e6a:	681b      	ldr	r3, [r3, #0]
 8002e6c:	687a      	ldr	r2, [r7, #4]
 8002e6e:	6812      	ldr	r2, [r2, #0]
 8002e70:	6892      	ldr	r2, [r2, #8]
 8002e72:	f022 0201 	bic.w	r2, r2, #1
 8002e76:	609a      	str	r2, [r3, #8]
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_READY;
 8002e78:	687b      	ldr	r3, [r7, #4]
 8002e7a:	2201      	movs	r2, #1
 8002e7c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Return function status */
  return HAL_OK;
 8002e80:	2300      	movs	r3, #0
}
 8002e82:	4618      	mov	r0, r3
 8002e84:	370c      	adds	r7, #12
 8002e86:	46bd      	mov	sp, r7
 8002e88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002e8c:	4770      	bx	lr
 8002e8e:	bf00      	nop

08002e90 <HAL_ADCEx_InjectedGetValue>:
  *            @arg ADC_INJECTED_RANK_3: Injected Channel3 selected
  *            @arg ADC_INJECTED_RANK_4: Injected Channel4 selected
  * @retval None
  */
uint32_t HAL_ADCEx_InjectedGetValue(ADC_HandleTypeDef* hadc, uint32_t InjectedRank)
{
 8002e90:	b480      	push	{r7}
 8002e92:	b085      	sub	sp, #20
 8002e94:	af00      	add	r7, sp, #0
 8002e96:	6078      	str	r0, [r7, #4]
 8002e98:	6039      	str	r1, [r7, #0]
  __IO uint32_t tmp = 0;
 8002e9a:	2300      	movs	r3, #0
 8002e9c:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_ADC_INJECTED_RANK(InjectedRank));
  
   /* Clear the ADCx's flag for injected end of conversion */
   __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_JEOC);
 8002e9e:	687b      	ldr	r3, [r7, #4]
 8002ea0:	681b      	ldr	r3, [r3, #0]
 8002ea2:	f06f 0204 	mvn.w	r2, #4
 8002ea6:	601a      	str	r2, [r3, #0]
  
  /* Return the selected ADC converted value */ 
  switch(InjectedRank)
 8002ea8:	683b      	ldr	r3, [r7, #0]
 8002eaa:	3b01      	subs	r3, #1
 8002eac:	2b03      	cmp	r3, #3
 8002eae:	d81f      	bhi.n	8002ef0 <HAL_ADCEx_InjectedGetValue+0x60>
 8002eb0:	a201      	add	r2, pc, #4	; (adr r2, 8002eb8 <HAL_ADCEx_InjectedGetValue+0x28>)
 8002eb2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8002eb6:	bf00      	nop
 8002eb8:	08002ee7 	.word	0x08002ee7
 8002ebc:	08002edd 	.word	0x08002edd
 8002ec0:	08002ed3 	.word	0x08002ed3
 8002ec4:	08002ec9 	.word	0x08002ec9
  {  
    case ADC_INJECTED_RANK_4:
    {
      tmp =  hadc->Instance->JDR4;
 8002ec8:	687b      	ldr	r3, [r7, #4]
 8002eca:	681b      	ldr	r3, [r3, #0]
 8002ecc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8002ece:	60fb      	str	r3, [r7, #12]
    }  
    break;
 8002ed0:	e00f      	b.n	8002ef2 <HAL_ADCEx_InjectedGetValue+0x62>
    case ADC_INJECTED_RANK_3: 
    {  
      tmp =  hadc->Instance->JDR3;
 8002ed2:	687b      	ldr	r3, [r7, #4]
 8002ed4:	681b      	ldr	r3, [r3, #0]
 8002ed6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002ed8:	60fb      	str	r3, [r7, #12]
    }  
    break;
 8002eda:	e00a      	b.n	8002ef2 <HAL_ADCEx_InjectedGetValue+0x62>
    case ADC_INJECTED_RANK_2: 
    {  
      tmp =  hadc->Instance->JDR2;
 8002edc:	687b      	ldr	r3, [r7, #4]
 8002ede:	681b      	ldr	r3, [r3, #0]
 8002ee0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002ee2:	60fb      	str	r3, [r7, #12]
    }
    break;
 8002ee4:	e005      	b.n	8002ef2 <HAL_ADCEx_InjectedGetValue+0x62>
    case ADC_INJECTED_RANK_1:
    {
      tmp =  hadc->Instance->JDR1;
 8002ee6:	687b      	ldr	r3, [r7, #4]
 8002ee8:	681b      	ldr	r3, [r3, #0]
 8002eea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002eec:	60fb      	str	r3, [r7, #12]
    }
    break;
 8002eee:	e000      	b.n	8002ef2 <HAL_ADCEx_InjectedGetValue+0x62>
    default:
    break;  
 8002ef0:	bf00      	nop
  }
  return tmp;
 8002ef2:	68fb      	ldr	r3, [r7, #12]
}
 8002ef4:	4618      	mov	r0, r3
 8002ef6:	3714      	adds	r7, #20
 8002ef8:	46bd      	mov	sp, r7
 8002efa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002efe:	4770      	bx	lr

08002f00 <HAL_ADCEx_MultiModeStart_DMA>:
  * @param  pData:   Pointer to buffer in which transferred from ADC peripheral to memory will be stored. 
  * @param  Length:  The length of data to be transferred from ADC peripheral to memory.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeStart_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
{
 8002f00:	b580      	push	{r7, lr}
 8002f02:	b086      	sub	sp, #24
 8002f04:	af00      	add	r7, sp, #0
 8002f06:	60f8      	str	r0, [r7, #12]
 8002f08:	60b9      	str	r1, [r7, #8]
 8002f0a:	607a      	str	r2, [r7, #4]
  __IO uint32_t counter = 0;
 8002f0c:	2300      	movs	r3, #0
 8002f0e:	617b      	str	r3, [r7, #20]
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
  assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DMAContinuousRequests));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8002f10:	68fb      	ldr	r3, [r7, #12]
 8002f12:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8002f16:	2b01      	cmp	r3, #1
 8002f18:	d101      	bne.n	8002f1e <HAL_ADCEx_MultiModeStart_DMA+0x1e>
 8002f1a:	2302      	movs	r3, #2
 8002f1c:	e087      	b.n	800302e <HAL_ADCEx_MultiModeStart_DMA+0x12e>
 8002f1e:	68fb      	ldr	r3, [r7, #12]
 8002f20:	2201      	movs	r2, #1
 8002f22:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Enable ADC overrun interrupt */
  __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 8002f26:	68fb      	ldr	r3, [r7, #12]
 8002f28:	681b      	ldr	r3, [r3, #0]
 8002f2a:	68fa      	ldr	r2, [r7, #12]
 8002f2c:	6812      	ldr	r2, [r2, #0]
 8002f2e:	6852      	ldr	r2, [r2, #4]
 8002f30:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8002f34:	605a      	str	r2, [r3, #4]
  
  if (hadc->Init.DMAContinuousRequests != DISABLE)
 8002f36:	68fb      	ldr	r3, [r7, #12]
 8002f38:	69db      	ldr	r3, [r3, #28]
 8002f3a:	2b00      	cmp	r3, #0
 8002f3c:	d00c      	beq.n	8002f58 <HAL_ADCEx_MultiModeStart_DMA+0x58>
  {
    /* Enable the selected ADC DMA request after last transfer */
    ADC->CCR |= ADC_CCR_DDS;
 8002f3e:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 8002f42:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8002f46:	f44f 520c 	mov.w	r2, #8960	; 0x2300
 8002f4a:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8002f4e:	6852      	ldr	r2, [r2, #4]
 8002f50:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8002f54:	605a      	str	r2, [r3, #4]
 8002f56:	e00b      	b.n	8002f70 <HAL_ADCEx_MultiModeStart_DMA+0x70>
  }
  else
  {
    /* Disable the selected ADC EOC rising on each regular channel conversion */
    ADC->CCR &= ~ADC_CCR_DDS;
 8002f58:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 8002f5c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8002f60:	f44f 520c 	mov.w	r2, #8960	; 0x2300
 8002f64:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8002f68:	6852      	ldr	r2, [r2, #4]
 8002f6a:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8002f6e:	605a      	str	r2, [r3, #4]
  }
  
  /* Set the DMA transfer complete callback */
  hadc->DMA_Handle->XferCpltCallback = ADC_MultiModeDMAConvCplt;
 8002f70:	68fb      	ldr	r3, [r7, #12]
 8002f72:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002f74:	f243 43f5 	movw	r3, #13557	; 0x34f5
 8002f78:	f6c0 0300 	movt	r3, #2048	; 0x800
 8002f7c:	63d3      	str	r3, [r2, #60]	; 0x3c
  
  /* Set the DMA half transfer complete callback */
  hadc->DMA_Handle->XferHalfCpltCallback = ADC_MultiModeDMAHalfConvCplt;
 8002f7e:	68fb      	ldr	r3, [r7, #12]
 8002f80:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002f82:	f243 532d 	movw	r3, #13613	; 0x352d
 8002f86:	f6c0 0300 	movt	r3, #2048	; 0x800
 8002f8a:	6413      	str	r3, [r2, #64]	; 0x40
     
  /* Set the DMA error callback */
  hadc->DMA_Handle->XferErrorCallback = ADC_MultiModeDMAError ;
 8002f8c:	68fb      	ldr	r3, [r7, #12]
 8002f8e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002f90:	f243 5349 	movw	r3, #13641	; 0x3549
 8002f94:	f6c0 0300 	movt	r3, #2048	; 0x800
 8002f98:	6493      	str	r3, [r2, #72]	; 0x48
  
  /* Enable the DMA Stream */
  HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&ADC->CDR, (uint32_t)pData, Length);
 8002f9a:	68fb      	ldr	r3, [r7, #12]
 8002f9c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002f9e:	68bb      	ldr	r3, [r7, #8]
 8002fa0:	4610      	mov	r0, r2
 8002fa2:	f242 3108 	movw	r1, #8968	; 0x2308
 8002fa6:	f2c4 0101 	movt	r1, #16385	; 0x4001
 8002faa:	461a      	mov	r2, r3
 8002fac:	687b      	ldr	r3, [r7, #4]
 8002fae:	f001 fafb 	bl	80045a8 <HAL_DMA_Start_IT>
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_BUSY_REG;
 8002fb2:	68fb      	ldr	r3, [r7, #12]
 8002fb4:	2212      	movs	r2, #18
 8002fb6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Check if ADC peripheral is disabled in order to enable it and wait during 
     Tstab time the ADC's stabilization */
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 8002fba:	68fb      	ldr	r3, [r7, #12]
 8002fbc:	681b      	ldr	r3, [r3, #0]
 8002fbe:	689b      	ldr	r3, [r3, #8]
 8002fc0:	f003 0301 	and.w	r3, r3, #1
 8002fc4:	2b00      	cmp	r3, #0
 8002fc6:	d11e      	bne.n	8003006 <HAL_ADCEx_MultiModeStart_DMA+0x106>
  {  
    /* Enable the Peripheral */
    __HAL_ADC_ENABLE(hadc);
 8002fc8:	68fb      	ldr	r3, [r7, #12]
 8002fca:	681b      	ldr	r3, [r3, #0]
 8002fcc:	68fa      	ldr	r2, [r7, #12]
 8002fce:	6812      	ldr	r2, [r2, #0]
 8002fd0:	6892      	ldr	r2, [r2, #8]
 8002fd2:	f042 0201 	orr.w	r2, r2, #1
 8002fd6:	609a      	str	r2, [r3, #8]
    
    /* Delay for temperature sensor stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 8002fd8:	f240 0300 	movw	r3, #0
 8002fdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002fe0:	681a      	ldr	r2, [r3, #0]
 8002fe2:	f64d 6383 	movw	r3, #56963	; 0xde83
 8002fe6:	f2c4 331b 	movt	r3, #17179	; 0x431b
 8002fea:	fba3 1302 	umull	r1, r3, r3, r2
 8002fee:	0c9a      	lsrs	r2, r3, #18
 8002ff0:	4613      	mov	r3, r2
 8002ff2:	005b      	lsls	r3, r3, #1
 8002ff4:	4413      	add	r3, r2
 8002ff6:	617b      	str	r3, [r7, #20]
    while(counter != 0)
 8002ff8:	e002      	b.n	8003000 <HAL_ADCEx_MultiModeStart_DMA+0x100>
    {
      counter--;
 8002ffa:	697b      	ldr	r3, [r7, #20]
 8002ffc:	3b01      	subs	r3, #1
 8002ffe:	617b      	str	r3, [r7, #20]
    __HAL_ADC_ENABLE(hadc);
    
    /* Delay for temperature sensor stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
    while(counter != 0)
 8003000:	697b      	ldr	r3, [r7, #20]
 8003002:	2b00      	cmp	r3, #0
 8003004:	d1f9      	bne.n	8002ffa <HAL_ADCEx_MultiModeStart_DMA+0xfa>
      counter--;
    }
  }
  
  /* if no external trigger present enable software conversion of regular channels */
  if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
 8003006:	68fb      	ldr	r3, [r7, #12]
 8003008:	681b      	ldr	r3, [r3, #0]
 800300a:	689b      	ldr	r3, [r3, #8]
 800300c:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 8003010:	2b00      	cmp	r3, #0
 8003012:	d107      	bne.n	8003024 <HAL_ADCEx_MultiModeStart_DMA+0x124>
  {
    /* Enable the selected ADC software conversion for regular group */
    hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 8003014:	68fb      	ldr	r3, [r7, #12]
 8003016:	681b      	ldr	r3, [r3, #0]
 8003018:	68fa      	ldr	r2, [r7, #12]
 800301a:	6812      	ldr	r2, [r2, #0]
 800301c:	6892      	ldr	r2, [r2, #8]
 800301e:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8003022:	609a      	str	r2, [r3, #8]
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8003024:	68fb      	ldr	r3, [r7, #12]
 8003026:	2200      	movs	r2, #0
 8003028:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 800302c:	2300      	movs	r3, #0
}
 800302e:	4618      	mov	r0, r3
 8003030:	3718      	adds	r7, #24
 8003032:	46bd      	mov	sp, r7
 8003034:	bd80      	pop	{r7, pc}
 8003036:	bf00      	nop

08003038 <HAL_ADCEx_MultiModeStop_DMA>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeStop_DMA(ADC_HandleTypeDef* hadc)
{
 8003038:	b580      	push	{r7, lr}
 800303a:	b082      	sub	sp, #8
 800303c:	af00      	add	r7, sp, #0
 800303e:	6078      	str	r0, [r7, #4]
  /* Process locked */
  __HAL_LOCK(hadc);
 8003040:	687b      	ldr	r3, [r7, #4]
 8003042:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8003046:	2b01      	cmp	r3, #1
 8003048:	d101      	bne.n	800304e <HAL_ADCEx_MultiModeStop_DMA+0x16>
 800304a:	2302      	movs	r3, #2
 800304c:	e02d      	b.n	80030aa <HAL_ADCEx_MultiModeStop_DMA+0x72>
 800304e:	687b      	ldr	r3, [r7, #4]
 8003050:	2201      	movs	r2, #1
 8003052:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Enable the Peripheral */
  __HAL_ADC_DISABLE(hadc);
 8003056:	687b      	ldr	r3, [r7, #4]
 8003058:	681b      	ldr	r3, [r3, #0]
 800305a:	687a      	ldr	r2, [r7, #4]
 800305c:	6812      	ldr	r2, [r2, #0]
 800305e:	6892      	ldr	r2, [r2, #8]
 8003060:	f022 0201 	bic.w	r2, r2, #1
 8003064:	609a      	str	r2, [r3, #8]
  
  /* Disable ADC overrun interrupt */
  __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
 8003066:	687b      	ldr	r3, [r7, #4]
 8003068:	681b      	ldr	r3, [r3, #0]
 800306a:	687a      	ldr	r2, [r7, #4]
 800306c:	6812      	ldr	r2, [r2, #0]
 800306e:	6852      	ldr	r2, [r2, #4]
 8003070:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8003074:	605a      	str	r2, [r3, #4]
  
  /* Disable the selected ADC DMA request after last transfer */
  ADC->CCR &= ~ADC_CCR_DDS;
 8003076:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 800307a:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800307e:	f44f 520c 	mov.w	r2, #8960	; 0x2300
 8003082:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8003086:	6852      	ldr	r2, [r2, #4]
 8003088:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800308c:	605a      	str	r2, [r3, #4]
  
  /* Disable the ADC DMA Stream */
  HAL_DMA_Abort(hadc->DMA_Handle);
 800308e:	687b      	ldr	r3, [r7, #4]
 8003090:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003092:	4618      	mov	r0, r3
 8003094:	f001 faca 	bl	800462c <HAL_DMA_Abort>
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_READY;
 8003098:	687b      	ldr	r3, [r7, #4]
 800309a:	2201      	movs	r2, #1
 800309c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80030a0:	687b      	ldr	r3, [r7, #4]
 80030a2:	2200      	movs	r2, #0
 80030a4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    
  /* Return function status */
  return HAL_OK;
 80030a8:	2300      	movs	r3, #0
}
 80030aa:	4618      	mov	r0, r3
 80030ac:	3708      	adds	r7, #8
 80030ae:	46bd      	mov	sp, r7
 80030b0:	bd80      	pop	{r7, pc}
 80030b2:	bf00      	nop

080030b4 <HAL_ADCEx_MultiModeGetValue>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval The converted data value.
  */
uint32_t HAL_ADCEx_MultiModeGetValue(ADC_HandleTypeDef* hadc)
{
 80030b4:	b480      	push	{r7}
 80030b6:	b083      	sub	sp, #12
 80030b8:	af00      	add	r7, sp, #0
 80030ba:	6078      	str	r0, [r7, #4]
  /* Return the multi mode conversion value */
  return ADC->CDR;
 80030bc:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 80030c0:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80030c4:	689b      	ldr	r3, [r3, #8]
}
 80030c6:	4618      	mov	r0, r3
 80030c8:	370c      	adds	r7, #12
 80030ca:	46bd      	mov	sp, r7
 80030cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80030d0:	4770      	bx	lr
 80030d2:	bf00      	nop

080030d4 <HAL_ADCEx_InjectedConvCpltCallback>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */
__weak void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef* hadc)
{
 80030d4:	b480      	push	{r7}
 80030d6:	b083      	sub	sp, #12
 80030d8:	af00      	add	r7, sp, #0
 80030da:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_InjectedConvCpltCallback could be implemented in the user file
   */
}
 80030dc:	370c      	adds	r7, #12
 80030de:	46bd      	mov	sp, r7
 80030e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80030e4:	4770      	bx	lr
 80030e6:	bf00      	nop

080030e8 <HAL_ADCEx_InjectedConfigChannel>:
  *         the configuration information for the specified ADC.
  * @param  sConfigInjected: ADC configuration structure for injected channel. 
  * @retval None
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef* hadc, ADC_InjectionConfTypeDef* sConfigInjected)
{
 80030e8:	b490      	push	{r4, r7}
 80030ea:	b082      	sub	sp, #8
 80030ec:	af00      	add	r7, sp, #0
 80030ee:	6078      	str	r0, [r7, #4]
 80030f0:	6039      	str	r1, [r7, #0]
  {
    assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(sConfigInjected->ExternalTrigInjecConvEdge));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 80030f2:	687b      	ldr	r3, [r7, #4]
 80030f4:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80030f8:	2b01      	cmp	r3, #1
 80030fa:	d101      	bne.n	8003100 <HAL_ADCEx_InjectedConfigChannel+0x18>
 80030fc:	2302      	movs	r3, #2
 80030fe:	e18e      	b.n	800341e <HAL_ADCEx_InjectedConfigChannel+0x336>
 8003100:	687b      	ldr	r3, [r7, #4]
 8003102:	2201      	movs	r2, #1
 8003104:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (sConfigInjected->InjectedChannel > ADC_CHANNEL_9)
 8003108:	683b      	ldr	r3, [r7, #0]
 800310a:	681b      	ldr	r3, [r3, #0]
 800310c:	2b09      	cmp	r3, #9
 800310e:	d926      	bls.n	800315e <HAL_ADCEx_InjectedConfigChannel+0x76>
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfigInjected->InjectedChannel);
 8003110:	687b      	ldr	r3, [r7, #4]
 8003112:	6819      	ldr	r1, [r3, #0]
 8003114:	687b      	ldr	r3, [r7, #4]
 8003116:	681b      	ldr	r3, [r3, #0]
 8003118:	68d8      	ldr	r0, [r3, #12]
 800311a:	683b      	ldr	r3, [r7, #0]
 800311c:	681b      	ldr	r3, [r3, #0]
 800311e:	b29b      	uxth	r3, r3
 8003120:	461a      	mov	r2, r3
 8003122:	4613      	mov	r3, r2
 8003124:	005b      	lsls	r3, r3, #1
 8003126:	4413      	add	r3, r2
 8003128:	3b1e      	subs	r3, #30
 800312a:	2207      	movs	r2, #7
 800312c:	fa02 f303 	lsl.w	r3, r2, r3
 8003130:	43db      	mvns	r3, r3
 8003132:	4003      	ands	r3, r0
 8003134:	60cb      	str	r3, [r1, #12]
    
    /* Set the new sample time */
    hadc->Instance->SMPR1 |= ADC_SMPR1(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel);
 8003136:	687b      	ldr	r3, [r7, #4]
 8003138:	6819      	ldr	r1, [r3, #0]
 800313a:	687b      	ldr	r3, [r7, #4]
 800313c:	681b      	ldr	r3, [r3, #0]
 800313e:	68d8      	ldr	r0, [r3, #12]
 8003140:	683b      	ldr	r3, [r7, #0]
 8003142:	689c      	ldr	r4, [r3, #8]
 8003144:	683b      	ldr	r3, [r7, #0]
 8003146:	681b      	ldr	r3, [r3, #0]
 8003148:	b29b      	uxth	r3, r3
 800314a:	461a      	mov	r2, r3
 800314c:	4613      	mov	r3, r2
 800314e:	005b      	lsls	r3, r3, #1
 8003150:	4413      	add	r3, r2
 8003152:	3b1e      	subs	r3, #30
 8003154:	fa04 f303 	lsl.w	r3, r4, r3
 8003158:	4303      	orrs	r3, r0
 800315a:	60cb      	str	r3, [r1, #12]
 800315c:	e023      	b.n	80031a6 <HAL_ADCEx_InjectedConfigChannel+0xbe>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfigInjected->InjectedChannel);
 800315e:	687b      	ldr	r3, [r7, #4]
 8003160:	6819      	ldr	r1, [r3, #0]
 8003162:	687b      	ldr	r3, [r7, #4]
 8003164:	681b      	ldr	r3, [r3, #0]
 8003166:	6918      	ldr	r0, [r3, #16]
 8003168:	683b      	ldr	r3, [r7, #0]
 800316a:	681b      	ldr	r3, [r3, #0]
 800316c:	b29b      	uxth	r3, r3
 800316e:	461a      	mov	r2, r3
 8003170:	4613      	mov	r3, r2
 8003172:	005b      	lsls	r3, r3, #1
 8003174:	4413      	add	r3, r2
 8003176:	2207      	movs	r2, #7
 8003178:	fa02 f303 	lsl.w	r3, r2, r3
 800317c:	43db      	mvns	r3, r3
 800317e:	4003      	ands	r3, r0
 8003180:	610b      	str	r3, [r1, #16]
    
    /* Set the new sample time */
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel);
 8003182:	687b      	ldr	r3, [r7, #4]
 8003184:	6819      	ldr	r1, [r3, #0]
 8003186:	687b      	ldr	r3, [r7, #4]
 8003188:	681b      	ldr	r3, [r3, #0]
 800318a:	6918      	ldr	r0, [r3, #16]
 800318c:	683b      	ldr	r3, [r7, #0]
 800318e:	689c      	ldr	r4, [r3, #8]
 8003190:	683b      	ldr	r3, [r7, #0]
 8003192:	681b      	ldr	r3, [r3, #0]
 8003194:	b29b      	uxth	r3, r3
 8003196:	461a      	mov	r2, r3
 8003198:	4613      	mov	r3, r2
 800319a:	005b      	lsls	r3, r3, #1
 800319c:	4413      	add	r3, r2
 800319e:	fa04 f303 	lsl.w	r3, r4, r3
 80031a2:	4303      	orrs	r3, r0
 80031a4:	610b      	str	r3, [r1, #16]
  }
  
  /*---------------------------- ADCx JSQR Configuration -----------------*/
  hadc->Instance->JSQR &= ~(ADC_JSQR_JL);
 80031a6:	687b      	ldr	r3, [r7, #4]
 80031a8:	681b      	ldr	r3, [r3, #0]
 80031aa:	687a      	ldr	r2, [r7, #4]
 80031ac:	6812      	ldr	r2, [r2, #0]
 80031ae:	6b92      	ldr	r2, [r2, #56]	; 0x38
 80031b0:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 80031b4:	639a      	str	r2, [r3, #56]	; 0x38
  hadc->Instance->JSQR |=  ADC_SQR1(sConfigInjected->InjectedNbrOfConversion);
 80031b6:	687b      	ldr	r3, [r7, #4]
 80031b8:	681b      	ldr	r3, [r3, #0]
 80031ba:	687a      	ldr	r2, [r7, #4]
 80031bc:	6812      	ldr	r2, [r2, #0]
 80031be:	6b91      	ldr	r1, [r2, #56]	; 0x38
 80031c0:	683a      	ldr	r2, [r7, #0]
 80031c2:	6912      	ldr	r2, [r2, #16]
 80031c4:	3a01      	subs	r2, #1
 80031c6:	0512      	lsls	r2, r2, #20
 80031c8:	430a      	orrs	r2, r1
 80031ca:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* Rank configuration */
  
  /* Clear the old SQx bits for the selected rank */
  hadc->Instance->JSQR &= ~ADC_JSQR(ADC_JSQR_JSQ1, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
 80031cc:	687b      	ldr	r3, [r7, #4]
 80031ce:	6819      	ldr	r1, [r3, #0]
 80031d0:	687b      	ldr	r3, [r7, #4]
 80031d2:	681b      	ldr	r3, [r3, #0]
 80031d4:	6b98      	ldr	r0, [r3, #56]	; 0x38
 80031d6:	683b      	ldr	r3, [r7, #0]
 80031d8:	685b      	ldr	r3, [r3, #4]
 80031da:	b2da      	uxtb	r2, r3
 80031dc:	683b      	ldr	r3, [r7, #0]
 80031de:	691b      	ldr	r3, [r3, #16]
 80031e0:	b2db      	uxtb	r3, r3
 80031e2:	1ad3      	subs	r3, r2, r3
 80031e4:	b2db      	uxtb	r3, r3
 80031e6:	3303      	adds	r3, #3
 80031e8:	b2db      	uxtb	r3, r3
 80031ea:	461a      	mov	r2, r3
 80031ec:	4613      	mov	r3, r2
 80031ee:	009b      	lsls	r3, r3, #2
 80031f0:	4413      	add	r3, r2
 80031f2:	221f      	movs	r2, #31
 80031f4:	fa02 f303 	lsl.w	r3, r2, r3
 80031f8:	43db      	mvns	r3, r3
 80031fa:	4003      	ands	r3, r0
 80031fc:	638b      	str	r3, [r1, #56]	; 0x38
   
  /* Set the SQx bits for the selected rank */
  hadc->Instance->JSQR |= ADC_JSQR(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
 80031fe:	687b      	ldr	r3, [r7, #4]
 8003200:	6819      	ldr	r1, [r3, #0]
 8003202:	687b      	ldr	r3, [r7, #4]
 8003204:	681b      	ldr	r3, [r3, #0]
 8003206:	6b98      	ldr	r0, [r3, #56]	; 0x38
 8003208:	683b      	ldr	r3, [r7, #0]
 800320a:	681b      	ldr	r3, [r3, #0]
 800320c:	b29b      	uxth	r3, r3
 800320e:	461c      	mov	r4, r3
 8003210:	683b      	ldr	r3, [r7, #0]
 8003212:	685b      	ldr	r3, [r3, #4]
 8003214:	b2da      	uxtb	r2, r3
 8003216:	683b      	ldr	r3, [r7, #0]
 8003218:	691b      	ldr	r3, [r3, #16]
 800321a:	b2db      	uxtb	r3, r3
 800321c:	1ad3      	subs	r3, r2, r3
 800321e:	b2db      	uxtb	r3, r3
 8003220:	3303      	adds	r3, #3
 8003222:	b2db      	uxtb	r3, r3
 8003224:	461a      	mov	r2, r3
 8003226:	4613      	mov	r3, r2
 8003228:	009b      	lsls	r3, r3, #2
 800322a:	4413      	add	r3, r2
 800322c:	fa04 f303 	lsl.w	r3, r4, r3
 8003230:	4303      	orrs	r3, r0
 8003232:	638b      	str	r3, [r1, #56]	; 0x38
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */ 
  if(sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 8003234:	683b      	ldr	r3, [r7, #0]
 8003236:	6a1a      	ldr	r2, [r3, #32]
 8003238:	2301      	movs	r3, #1
 800323a:	f2c0 030f 	movt	r3, #15
 800323e:	429a      	cmp	r2, r3
 8003240:	d022      	beq.n	8003288 <HAL_ADCEx_InjectedConfigChannel+0x1a0>
  {  
    /* Select external trigger to start conversion */
    hadc->Instance->CR2 &= ~(ADC_CR2_JEXTSEL);
 8003242:	687b      	ldr	r3, [r7, #4]
 8003244:	681b      	ldr	r3, [r3, #0]
 8003246:	687a      	ldr	r2, [r7, #4]
 8003248:	6812      	ldr	r2, [r2, #0]
 800324a:	6892      	ldr	r2, [r2, #8]
 800324c:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
 8003250:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |=  sConfigInjected->ExternalTrigInjecConv;
 8003252:	687b      	ldr	r3, [r7, #4]
 8003254:	681b      	ldr	r3, [r3, #0]
 8003256:	687a      	ldr	r2, [r7, #4]
 8003258:	6812      	ldr	r2, [r2, #0]
 800325a:	6891      	ldr	r1, [r2, #8]
 800325c:	683a      	ldr	r2, [r7, #0]
 800325e:	6a12      	ldr	r2, [r2, #32]
 8003260:	430a      	orrs	r2, r1
 8003262:	609a      	str	r2, [r3, #8]
    
    /* Select external trigger polarity */
    hadc->Instance->CR2 &= ~(ADC_CR2_JEXTEN);
 8003264:	687b      	ldr	r3, [r7, #4]
 8003266:	681b      	ldr	r3, [r3, #0]
 8003268:	687a      	ldr	r2, [r7, #4]
 800326a:	6812      	ldr	r2, [r2, #0]
 800326c:	6892      	ldr	r2, [r2, #8]
 800326e:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8003272:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |= sConfigInjected->ExternalTrigInjecConvEdge;
 8003274:	687b      	ldr	r3, [r7, #4]
 8003276:	681b      	ldr	r3, [r3, #0]
 8003278:	687a      	ldr	r2, [r7, #4]
 800327a:	6812      	ldr	r2, [r2, #0]
 800327c:	6891      	ldr	r1, [r2, #8]
 800327e:	683a      	ldr	r2, [r7, #0]
 8003280:	69d2      	ldr	r2, [r2, #28]
 8003282:	430a      	orrs	r2, r1
 8003284:	609a      	str	r2, [r3, #8]
 8003286:	e00f      	b.n	80032a8 <HAL_ADCEx_InjectedConfigChannel+0x1c0>
  }
  else
  {
    /* Reset the external trigger */
    hadc->Instance->CR2 &= ~(ADC_CR2_JEXTSEL);
 8003288:	687b      	ldr	r3, [r7, #4]
 800328a:	681b      	ldr	r3, [r3, #0]
 800328c:	687a      	ldr	r2, [r7, #4]
 800328e:	6812      	ldr	r2, [r2, #0]
 8003290:	6892      	ldr	r2, [r2, #8]
 8003292:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
 8003296:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_JEXTEN);  
 8003298:	687b      	ldr	r3, [r7, #4]
 800329a:	681b      	ldr	r3, [r3, #0]
 800329c:	687a      	ldr	r2, [r7, #4]
 800329e:	6812      	ldr	r2, [r2, #0]
 80032a0:	6892      	ldr	r2, [r2, #8]
 80032a2:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 80032a6:	609a      	str	r2, [r3, #8]
  }
  
  if (sConfigInjected->AutoInjectedConv != DISABLE)
 80032a8:	683b      	ldr	r3, [r7, #0]
 80032aa:	695b      	ldr	r3, [r3, #20]
 80032ac:	2b00      	cmp	r3, #0
 80032ae:	d008      	beq.n	80032c2 <HAL_ADCEx_InjectedConfigChannel+0x1da>
  {
    /* Enable the selected ADC automatic injected group conversion */
    hadc->Instance->CR1 |= ADC_CR1_JAUTO;
 80032b0:	687b      	ldr	r3, [r7, #4]
 80032b2:	681b      	ldr	r3, [r3, #0]
 80032b4:	687a      	ldr	r2, [r7, #4]
 80032b6:	6812      	ldr	r2, [r2, #0]
 80032b8:	6852      	ldr	r2, [r2, #4]
 80032ba:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80032be:	605a      	str	r2, [r3, #4]
 80032c0:	e007      	b.n	80032d2 <HAL_ADCEx_InjectedConfigChannel+0x1ea>
  }
  else
  {
    /* Disable the selected ADC automatic injected group conversion */
    hadc->Instance->CR1 &= ~(ADC_CR1_JAUTO);
 80032c2:	687b      	ldr	r3, [r7, #4]
 80032c4:	681b      	ldr	r3, [r3, #0]
 80032c6:	687a      	ldr	r2, [r7, #4]
 80032c8:	6812      	ldr	r2, [r2, #0]
 80032ca:	6852      	ldr	r2, [r2, #4]
 80032cc:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80032d0:	605a      	str	r2, [r3, #4]
  }
  
  if (sConfigInjected->InjectedDiscontinuousConvMode != DISABLE)
 80032d2:	683b      	ldr	r3, [r7, #0]
 80032d4:	699b      	ldr	r3, [r3, #24]
 80032d6:	2b00      	cmp	r3, #0
 80032d8:	d008      	beq.n	80032ec <HAL_ADCEx_InjectedConfigChannel+0x204>
  {
    /* Enable the selected ADC injected discontinuous mode */
    hadc->Instance->CR1 |= ADC_CR1_JDISCEN;
 80032da:	687b      	ldr	r3, [r7, #4]
 80032dc:	681b      	ldr	r3, [r3, #0]
 80032de:	687a      	ldr	r2, [r7, #4]
 80032e0:	6812      	ldr	r2, [r2, #0]
 80032e2:	6852      	ldr	r2, [r2, #4]
 80032e4:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80032e8:	605a      	str	r2, [r3, #4]
 80032ea:	e007      	b.n	80032fc <HAL_ADCEx_InjectedConfigChannel+0x214>
  }
  else
  {
    /* Disable the selected ADC injected discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_JDISCEN);
 80032ec:	687b      	ldr	r3, [r7, #4]
 80032ee:	681b      	ldr	r3, [r3, #0]
 80032f0:	687a      	ldr	r2, [r7, #4]
 80032f2:	6812      	ldr	r2, [r2, #0]
 80032f4:	6852      	ldr	r2, [r2, #4]
 80032f6:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 80032fa:	605a      	str	r2, [r3, #4]
  }
  
  switch(sConfigInjected->InjectedRank)
 80032fc:	683b      	ldr	r3, [r7, #0]
 80032fe:	685b      	ldr	r3, [r3, #4]
 8003300:	2b02      	cmp	r3, #2
 8003302:	d017      	beq.n	8003334 <HAL_ADCEx_InjectedConfigChannel+0x24c>
 8003304:	2b03      	cmp	r3, #3
 8003306:	d029      	beq.n	800335c <HAL_ADCEx_InjectedConfigChannel+0x274>
 8003308:	2b01      	cmp	r3, #1
 800330a:	d13b      	bne.n	8003384 <HAL_ADCEx_InjectedConfigChannel+0x29c>
  {
    case 1:
      /* Set injected channel 1 offset */
      hadc->Instance->JOFR1 &= ~(ADC_JOFR1_JOFFSET1);
 800330c:	687b      	ldr	r3, [r7, #4]
 800330e:	681a      	ldr	r2, [r3, #0]
 8003310:	687b      	ldr	r3, [r7, #4]
 8003312:	681b      	ldr	r3, [r3, #0]
 8003314:	695b      	ldr	r3, [r3, #20]
 8003316:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 800331a:	f023 030f 	bic.w	r3, r3, #15
 800331e:	6153      	str	r3, [r2, #20]
      hadc->Instance->JOFR1 |= sConfigInjected->InjectedOffset;
 8003320:	687b      	ldr	r3, [r7, #4]
 8003322:	681b      	ldr	r3, [r3, #0]
 8003324:	687a      	ldr	r2, [r7, #4]
 8003326:	6812      	ldr	r2, [r2, #0]
 8003328:	6951      	ldr	r1, [r2, #20]
 800332a:	683a      	ldr	r2, [r7, #0]
 800332c:	68d2      	ldr	r2, [r2, #12]
 800332e:	430a      	orrs	r2, r1
 8003330:	615a      	str	r2, [r3, #20]
      break;
 8003332:	e03b      	b.n	80033ac <HAL_ADCEx_InjectedConfigChannel+0x2c4>
    case 2:
      /* Set injected channel 2 offset */
      hadc->Instance->JOFR2 &= ~(ADC_JOFR2_JOFFSET2);
 8003334:	687b      	ldr	r3, [r7, #4]
 8003336:	681a      	ldr	r2, [r3, #0]
 8003338:	687b      	ldr	r3, [r7, #4]
 800333a:	681b      	ldr	r3, [r3, #0]
 800333c:	699b      	ldr	r3, [r3, #24]
 800333e:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8003342:	f023 030f 	bic.w	r3, r3, #15
 8003346:	6193      	str	r3, [r2, #24]
      hadc->Instance->JOFR2 |= sConfigInjected->InjectedOffset;
 8003348:	687b      	ldr	r3, [r7, #4]
 800334a:	681b      	ldr	r3, [r3, #0]
 800334c:	687a      	ldr	r2, [r7, #4]
 800334e:	6812      	ldr	r2, [r2, #0]
 8003350:	6991      	ldr	r1, [r2, #24]
 8003352:	683a      	ldr	r2, [r7, #0]
 8003354:	68d2      	ldr	r2, [r2, #12]
 8003356:	430a      	orrs	r2, r1
 8003358:	619a      	str	r2, [r3, #24]
      break;
 800335a:	e027      	b.n	80033ac <HAL_ADCEx_InjectedConfigChannel+0x2c4>
    case 3:
      /* Set injected channel 3 offset */
      hadc->Instance->JOFR3 &= ~(ADC_JOFR3_JOFFSET3);
 800335c:	687b      	ldr	r3, [r7, #4]
 800335e:	681a      	ldr	r2, [r3, #0]
 8003360:	687b      	ldr	r3, [r7, #4]
 8003362:	681b      	ldr	r3, [r3, #0]
 8003364:	69db      	ldr	r3, [r3, #28]
 8003366:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 800336a:	f023 030f 	bic.w	r3, r3, #15
 800336e:	61d3      	str	r3, [r2, #28]
      hadc->Instance->JOFR3 |= sConfigInjected->InjectedOffset;
 8003370:	687b      	ldr	r3, [r7, #4]
 8003372:	681b      	ldr	r3, [r3, #0]
 8003374:	687a      	ldr	r2, [r7, #4]
 8003376:	6812      	ldr	r2, [r2, #0]
 8003378:	69d1      	ldr	r1, [r2, #28]
 800337a:	683a      	ldr	r2, [r7, #0]
 800337c:	68d2      	ldr	r2, [r2, #12]
 800337e:	430a      	orrs	r2, r1
 8003380:	61da      	str	r2, [r3, #28]
      break;
 8003382:	e013      	b.n	80033ac <HAL_ADCEx_InjectedConfigChannel+0x2c4>
    default:
      /* Set injected channel 4 offset */
      hadc->Instance->JOFR4 &= ~(ADC_JOFR4_JOFFSET4);
 8003384:	687b      	ldr	r3, [r7, #4]
 8003386:	681a      	ldr	r2, [r3, #0]
 8003388:	687b      	ldr	r3, [r7, #4]
 800338a:	681b      	ldr	r3, [r3, #0]
 800338c:	6a1b      	ldr	r3, [r3, #32]
 800338e:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8003392:	f023 030f 	bic.w	r3, r3, #15
 8003396:	6213      	str	r3, [r2, #32]
      hadc->Instance->JOFR4 |= sConfigInjected->InjectedOffset;
 8003398:	687b      	ldr	r3, [r7, #4]
 800339a:	681b      	ldr	r3, [r3, #0]
 800339c:	687a      	ldr	r2, [r7, #4]
 800339e:	6812      	ldr	r2, [r2, #0]
 80033a0:	6a11      	ldr	r1, [r2, #32]
 80033a2:	683a      	ldr	r2, [r7, #0]
 80033a4:	68d2      	ldr	r2, [r2, #12]
 80033a6:	430a      	orrs	r2, r1
 80033a8:	621a      	str	r2, [r3, #32]
      break;
 80033aa:	bf00      	nop
  }
  
  /* if ADC1 Channel_18 is selected enable VBAT Channel */
  if ((hadc->Instance == ADC1) && (sConfigInjected->InjectedChannel == ADC_CHANNEL_VBAT))
 80033ac:	687b      	ldr	r3, [r7, #4]
 80033ae:	681a      	ldr	r2, [r3, #0]
 80033b0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80033b4:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80033b8:	429a      	cmp	r2, r3
 80033ba:	d10f      	bne.n	80033dc <HAL_ADCEx_InjectedConfigChannel+0x2f4>
 80033bc:	683b      	ldr	r3, [r7, #0]
 80033be:	681b      	ldr	r3, [r3, #0]
 80033c0:	2b12      	cmp	r3, #18
 80033c2:	d10b      	bne.n	80033dc <HAL_ADCEx_InjectedConfigChannel+0x2f4>
  {
    /* Enable the VBAT channel*/
    ADC->CCR |= ADC_CCR_VBATE;
 80033c4:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 80033c8:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80033cc:	f44f 520c 	mov.w	r2, #8960	; 0x2300
 80033d0:	f2c4 0201 	movt	r2, #16385	; 0x4001
 80033d4:	6852      	ldr	r2, [r2, #4]
 80033d6:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 80033da:	605a      	str	r2, [r3, #4]
  }
  
  /* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
  if ((hadc->Instance == ADC1) && ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR) || (sConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT)))
 80033dc:	687b      	ldr	r3, [r7, #4]
 80033de:	681a      	ldr	r2, [r3, #0]
 80033e0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80033e4:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80033e8:	429a      	cmp	r2, r3
 80033ea:	d113      	bne.n	8003414 <HAL_ADCEx_InjectedConfigChannel+0x32c>
 80033ec:	683b      	ldr	r3, [r7, #0]
 80033ee:	681b      	ldr	r3, [r3, #0]
 80033f0:	2b10      	cmp	r3, #16
 80033f2:	d003      	beq.n	80033fc <HAL_ADCEx_InjectedConfigChannel+0x314>
 80033f4:	683b      	ldr	r3, [r7, #0]
 80033f6:	681b      	ldr	r3, [r3, #0]
 80033f8:	2b11      	cmp	r3, #17
 80033fa:	d10b      	bne.n	8003414 <HAL_ADCEx_InjectedConfigChannel+0x32c>
  {
    /* Enable the TSVREFE channel*/
    ADC->CCR |= ADC_CCR_TSVREFE;
 80033fc:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 8003400:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8003404:	f44f 520c 	mov.w	r2, #8960	; 0x2300
 8003408:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800340c:	6852      	ldr	r2, [r2, #4]
 800340e:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8003412:	605a      	str	r2, [r3, #4]
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8003414:	687b      	ldr	r3, [r7, #4]
 8003416:	2200      	movs	r2, #0
 8003418:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 800341c:	2300      	movs	r3, #0
}
 800341e:	4618      	mov	r0, r3
 8003420:	3708      	adds	r7, #8
 8003422:	46bd      	mov	sp, r7
 8003424:	bc90      	pop	{r4, r7}
 8003426:	4770      	bx	lr

08003428 <HAL_ADCEx_MultiModeConfigChannel>:
  * @param  multimode : pointer to an ADC_MultiModeTypeDef structure that contains 
  *                     the configuration information for  multimode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef* hadc, ADC_MultiModeTypeDef* multimode)
{
 8003428:	b480      	push	{r7}
 800342a:	b083      	sub	sp, #12
 800342c:	af00      	add	r7, sp, #0
 800342e:	6078      	str	r0, [r7, #4]
 8003430:	6039      	str	r1, [r7, #0]
  assert_param(IS_ADC_MODE(multimode->Mode));
  assert_param(IS_ADC_DMA_ACCESS_MODE(multimode->DMAAccessMode));
  assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8003432:	687b      	ldr	r3, [r7, #4]
 8003434:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8003438:	2b01      	cmp	r3, #1
 800343a:	d101      	bne.n	8003440 <HAL_ADCEx_MultiModeConfigChannel+0x18>
 800343c:	2302      	movs	r3, #2
 800343e:	e053      	b.n	80034e8 <HAL_ADCEx_MultiModeConfigChannel+0xc0>
 8003440:	687b      	ldr	r3, [r7, #4]
 8003442:	2201      	movs	r2, #1
 8003444:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Set ADC mode */
  ADC->CCR &= ~(ADC_CCR_MULTI);
 8003448:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 800344c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8003450:	f44f 520c 	mov.w	r2, #8960	; 0x2300
 8003454:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8003458:	6852      	ldr	r2, [r2, #4]
 800345a:	f022 021f 	bic.w	r2, r2, #31
 800345e:	605a      	str	r2, [r3, #4]
  ADC->CCR |= multimode->Mode;
 8003460:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 8003464:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8003468:	f44f 520c 	mov.w	r2, #8960	; 0x2300
 800346c:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8003470:	6851      	ldr	r1, [r2, #4]
 8003472:	683a      	ldr	r2, [r7, #0]
 8003474:	6812      	ldr	r2, [r2, #0]
 8003476:	430a      	orrs	r2, r1
 8003478:	605a      	str	r2, [r3, #4]
  
  /* Set the ADC DMA access mode */
  ADC->CCR &= ~(ADC_CCR_DMA);
 800347a:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 800347e:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8003482:	f44f 520c 	mov.w	r2, #8960	; 0x2300
 8003486:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800348a:	6852      	ldr	r2, [r2, #4]
 800348c:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8003490:	605a      	str	r2, [r3, #4]
  ADC->CCR |= multimode->DMAAccessMode;
 8003492:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 8003496:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800349a:	f44f 520c 	mov.w	r2, #8960	; 0x2300
 800349e:	f2c4 0201 	movt	r2, #16385	; 0x4001
 80034a2:	6851      	ldr	r1, [r2, #4]
 80034a4:	683a      	ldr	r2, [r7, #0]
 80034a6:	6852      	ldr	r2, [r2, #4]
 80034a8:	430a      	orrs	r2, r1
 80034aa:	605a      	str	r2, [r3, #4]
  
  /* Set delay between two sampling phases */
  ADC->CCR &= ~(ADC_CCR_DELAY);
 80034ac:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 80034b0:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80034b4:	f44f 520c 	mov.w	r2, #8960	; 0x2300
 80034b8:	f2c4 0201 	movt	r2, #16385	; 0x4001
 80034bc:	6852      	ldr	r2, [r2, #4]
 80034be:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
 80034c2:	605a      	str	r2, [r3, #4]
  ADC->CCR |= multimode->TwoSamplingDelay;
 80034c4:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 80034c8:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80034cc:	f44f 520c 	mov.w	r2, #8960	; 0x2300
 80034d0:	f2c4 0201 	movt	r2, #16385	; 0x4001
 80034d4:	6851      	ldr	r1, [r2, #4]
 80034d6:	683a      	ldr	r2, [r7, #0]
 80034d8:	6892      	ldr	r2, [r2, #8]
 80034da:	430a      	orrs	r2, r1
 80034dc:	605a      	str	r2, [r3, #4]
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80034de:	687b      	ldr	r3, [r7, #4]
 80034e0:	2200      	movs	r2, #0
 80034e2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 80034e6:	2300      	movs	r3, #0
}
 80034e8:	4618      	mov	r0, r3
 80034ea:	370c      	adds	r7, #12
 80034ec:	46bd      	mov	sp, r7
 80034ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80034f2:	4770      	bx	lr

080034f4 <ADC_MultiModeDMAConvCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void ADC_MultiModeDMAConvCplt(DMA_HandleTypeDef *hdma)   
{
 80034f4:	b580      	push	{r7, lr}
 80034f6:	b084      	sub	sp, #16
 80034f8:	af00      	add	r7, sp, #0
 80034fa:	6078      	str	r0, [r7, #4]
    ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 80034fc:	687b      	ldr	r3, [r7, #4]
 80034fe:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003500:	60fb      	str	r3, [r7, #12]
    
  /* Check if an injected conversion is ready */
  if(hadc->State == HAL_ADC_STATE_EOC_INJ)
 8003502:	68fb      	ldr	r3, [r7, #12]
 8003504:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8003508:	b2db      	uxtb	r3, r3
 800350a:	2b25      	cmp	r3, #37	; 0x25
 800350c:	d104      	bne.n	8003518 <ADC_MultiModeDMAConvCplt+0x24>
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
 800350e:	68fb      	ldr	r3, [r7, #12]
 8003510:	2235      	movs	r2, #53	; 0x35
 8003512:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8003516:	e003      	b.n	8003520 <ADC_MultiModeDMAConvCplt+0x2c>
  }
  else
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_EOC_REG;
 8003518:	68fb      	ldr	r3, [r7, #12]
 800351a:	2215      	movs	r2, #21
 800351c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  }
    
    HAL_ADC_ConvCpltCallback(hadc); 
 8003520:	68f8      	ldr	r0, [r7, #12]
 8003522:	f7fe ffa1 	bl	8002468 <HAL_ADC_ConvCpltCallback>
}
 8003526:	3710      	adds	r7, #16
 8003528:	46bd      	mov	sp, r7
 800352a:	bd80      	pop	{r7, pc}

0800352c <ADC_MultiModeDMAHalfConvCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void ADC_MultiModeDMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
{
 800352c:	b580      	push	{r7, lr}
 800352e:	b084      	sub	sp, #16
 8003530:	af00      	add	r7, sp, #0
 8003532:	6078      	str	r0, [r7, #4]
    ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8003534:	687b      	ldr	r3, [r7, #4]
 8003536:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003538:	60fb      	str	r3, [r7, #12]
    /* Conversion complete callback */
    HAL_ADC_ConvHalfCpltCallback(hadc); 
 800353a:	68f8      	ldr	r0, [r7, #12]
 800353c:	f7fe ff9e 	bl	800247c <HAL_ADC_ConvHalfCpltCallback>
}
 8003540:	3710      	adds	r7, #16
 8003542:	46bd      	mov	sp, r7
 8003544:	bd80      	pop	{r7, pc}
 8003546:	bf00      	nop

08003548 <ADC_MultiModeDMAError>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void ADC_MultiModeDMAError(DMA_HandleTypeDef *hdma)   
{
 8003548:	b580      	push	{r7, lr}
 800354a:	b084      	sub	sp, #16
 800354c:	af00      	add	r7, sp, #0
 800354e:	6078      	str	r0, [r7, #4]
    ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8003550:	687b      	ldr	r3, [r7, #4]
 8003552:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003554:	60fb      	str	r3, [r7, #12]
    hadc->State= HAL_ADC_STATE_ERROR;
 8003556:	68fb      	ldr	r3, [r7, #12]
 8003558:	2204      	movs	r2, #4
 800355a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    /* Set ADC error code to DMA error */
    hadc->ErrorCode |= HAL_ADC_ERROR_DMA;
 800355e:	68fb      	ldr	r3, [r7, #12]
 8003560:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003562:	f043 0202 	orr.w	r2, r3, #2
 8003566:	68fb      	ldr	r3, [r7, #12]
 8003568:	641a      	str	r2, [r3, #64]	; 0x40
    HAL_ADC_ErrorCallback(hadc); 
 800356a:	68f8      	ldr	r0, [r7, #12]
 800356c:	f7fe ff9a 	bl	80024a4 <HAL_ADC_ErrorCallback>
}
 8003570:	3710      	adds	r7, #16
 8003572:	46bd      	mov	sp, r7
 8003574:	bd80      	pop	{r7, pc}
 8003576:	bf00      	nop

08003578 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8003578:	b480      	push	{r7}
 800357a:	b085      	sub	sp, #20
 800357c:	af00      	add	r7, sp, #0
 800357e:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8003580:	687b      	ldr	r3, [r7, #4]
 8003582:	f003 0307 	and.w	r3, r3, #7
 8003586:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8003588:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800358c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003590:	68db      	ldr	r3, [r3, #12]
 8003592:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 8003594:	68ba      	ldr	r2, [r7, #8]
 8003596:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800359a:	4013      	ands	r3, r2
 800359c:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
 800359e:	68fb      	ldr	r3, [r7, #12]
 80035a0:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80035a2:	68bb      	ldr	r3, [r7, #8]
 80035a4:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 80035a6:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80035aa:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80035ae:	60bb      	str	r3, [r7, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80035b0:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 80035b4:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80035b8:	68ba      	ldr	r2, [r7, #8]
 80035ba:	60da      	str	r2, [r3, #12]
}
 80035bc:	3714      	adds	r7, #20
 80035be:	46bd      	mov	sp, r7
 80035c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80035c4:	4770      	bx	lr
 80035c6:	bf00      	nop

080035c8 <NVIC_GetPriorityGrouping>:
  The function reads the priority grouping field from the NVIC Interrupt Controller.

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
 80035c8:	b480      	push	{r7}
 80035ca:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80035cc:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 80035d0:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80035d4:	68db      	ldr	r3, [r3, #12]
 80035d6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 80035da:	0a1b      	lsrs	r3, r3, #8
}
 80035dc:	4618      	mov	r0, r3
 80035de:	46bd      	mov	sp, r7
 80035e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80035e4:	4770      	bx	lr
 80035e6:	bf00      	nop

080035e8 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80035e8:	b480      	push	{r7}
 80035ea:	b083      	sub	sp, #12
 80035ec:	af00      	add	r7, sp, #0
 80035ee:	4603      	mov	r3, r0
 80035f0:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80035f2:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 80035f6:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80035fa:	f997 2007 	ldrsb.w	r2, [r7, #7]
 80035fe:	0952      	lsrs	r2, r2, #5
 8003600:	79f9      	ldrb	r1, [r7, #7]
 8003602:	f001 011f 	and.w	r1, r1, #31
 8003606:	2001      	movs	r0, #1
 8003608:	fa00 f101 	lsl.w	r1, r0, r1
 800360c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8003610:	370c      	adds	r7, #12
 8003612:	46bd      	mov	sp, r7
 8003614:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003618:	4770      	bx	lr
 800361a:	bf00      	nop

0800361c <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
 800361c:	b480      	push	{r7}
 800361e:	b083      	sub	sp, #12
 8003620:	af00      	add	r7, sp, #0
 8003622:	4603      	mov	r3, r0
 8003624:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8003626:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 800362a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800362e:	f997 2007 	ldrsb.w	r2, [r7, #7]
 8003632:	0952      	lsrs	r2, r2, #5
 8003634:	79f9      	ldrb	r1, [r7, #7]
 8003636:	f001 011f 	and.w	r1, r1, #31
 800363a:	2001      	movs	r0, #1
 800363c:	fa00 f101 	lsl.w	r1, r0, r1
 8003640:	3220      	adds	r2, #32
 8003642:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8003646:	370c      	adds	r7, #12
 8003648:	46bd      	mov	sp, r7
 800364a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800364e:	4770      	bx	lr

08003650 <NVIC_GetPendingIRQ>:

    \return             0  Interrupt status is not pending.
    \return             1  Interrupt status is pending.
 */
__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
 8003650:	b480      	push	{r7}
 8003652:	b083      	sub	sp, #12
 8003654:	af00      	add	r7, sp, #0
 8003656:	4603      	mov	r3, r0
 8003658:	71fb      	strb	r3, [r7, #7]
  return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
 800365a:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 800365e:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003662:	f997 2007 	ldrsb.w	r2, [r7, #7]
 8003666:	0952      	lsrs	r2, r2, #5
 8003668:	3240      	adds	r2, #64	; 0x40
 800366a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800366e:	79fb      	ldrb	r3, [r7, #7]
 8003670:	f003 031f 	and.w	r3, r3, #31
 8003674:	fa22 f303 	lsr.w	r3, r2, r3
 8003678:	f003 0301 	and.w	r3, r3, #1
}
 800367c:	4618      	mov	r0, r3
 800367e:	370c      	adds	r7, #12
 8003680:	46bd      	mov	sp, r7
 8003682:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003686:	4770      	bx	lr

08003688 <NVIC_SetPendingIRQ>:
    The function sets the pending bit of an external interrupt.

    \param [in]      IRQn  Interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
 8003688:	b480      	push	{r7}
 800368a:	b083      	sub	sp, #12
 800368c:	af00      	add	r7, sp, #0
 800368e:	4603      	mov	r3, r0
 8003690:	71fb      	strb	r3, [r7, #7]
  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8003692:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8003696:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800369a:	f997 2007 	ldrsb.w	r2, [r7, #7]
 800369e:	0952      	lsrs	r2, r2, #5
 80036a0:	79f9      	ldrb	r1, [r7, #7]
 80036a2:	f001 011f 	and.w	r1, r1, #31
 80036a6:	2001      	movs	r0, #1
 80036a8:	fa00 f101 	lsl.w	r1, r0, r1
 80036ac:	3240      	adds	r2, #64	; 0x40
 80036ae:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 80036b2:	370c      	adds	r7, #12
 80036b4:	46bd      	mov	sp, r7
 80036b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80036ba:	4770      	bx	lr

080036bc <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
 80036bc:	b480      	push	{r7}
 80036be:	b083      	sub	sp, #12
 80036c0:	af00      	add	r7, sp, #0
 80036c2:	4603      	mov	r3, r0
 80036c4:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80036c6:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 80036ca:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80036ce:	f997 2007 	ldrsb.w	r2, [r7, #7]
 80036d2:	0952      	lsrs	r2, r2, #5
 80036d4:	79f9      	ldrb	r1, [r7, #7]
 80036d6:	f001 011f 	and.w	r1, r1, #31
 80036da:	2001      	movs	r0, #1
 80036dc:	fa00 f101 	lsl.w	r1, r0, r1
 80036e0:	3260      	adds	r2, #96	; 0x60
 80036e2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 80036e6:	370c      	adds	r7, #12
 80036e8:	46bd      	mov	sp, r7
 80036ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80036ee:	4770      	bx	lr

080036f0 <NVIC_GetActive>:

    \return             0  Interrupt status is not active.
    \return             1  Interrupt status is active.
 */
__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
{
 80036f0:	b480      	push	{r7}
 80036f2:	b083      	sub	sp, #12
 80036f4:	af00      	add	r7, sp, #0
 80036f6:	4603      	mov	r3, r0
 80036f8:	71fb      	strb	r3, [r7, #7]
  return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
 80036fa:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 80036fe:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003702:	f997 2007 	ldrsb.w	r2, [r7, #7]
 8003706:	0952      	lsrs	r2, r2, #5
 8003708:	3280      	adds	r2, #128	; 0x80
 800370a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800370e:	79fb      	ldrb	r3, [r7, #7]
 8003710:	f003 031f 	and.w	r3, r3, #31
 8003714:	fa22 f303 	lsr.w	r3, r2, r3
 8003718:	f003 0301 	and.w	r3, r3, #1
}
 800371c:	4618      	mov	r0, r3
 800371e:	370c      	adds	r7, #12
 8003720:	46bd      	mov	sp, r7
 8003722:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003726:	4770      	bx	lr

08003728 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8003728:	b480      	push	{r7}
 800372a:	b083      	sub	sp, #12
 800372c:	af00      	add	r7, sp, #0
 800372e:	4603      	mov	r3, r0
 8003730:	6039      	str	r1, [r7, #0]
 8003732:	71fb      	strb	r3, [r7, #7]
  if((int32_t)IRQn < 0) {
 8003734:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8003738:	2b00      	cmp	r3, #0
 800373a:	da0e      	bge.n	800375a <NVIC_SetPriority+0x32>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800373c:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8003740:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003744:	79fa      	ldrb	r2, [r7, #7]
 8003746:	f002 020f 	and.w	r2, r2, #15
 800374a:	1f11      	subs	r1, r2, #4
 800374c:	683a      	ldr	r2, [r7, #0]
 800374e:	b2d2      	uxtb	r2, r2
 8003750:	0112      	lsls	r2, r2, #4
 8003752:	b2d2      	uxtb	r2, r2
 8003754:	440b      	add	r3, r1
 8003756:	761a      	strb	r2, [r3, #24]
 8003758:	e00c      	b.n	8003774 <NVIC_SetPriority+0x4c>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800375a:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 800375e:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003762:	f997 1007 	ldrsb.w	r1, [r7, #7]
 8003766:	683a      	ldr	r2, [r7, #0]
 8003768:	b2d2      	uxtb	r2, r2
 800376a:	0112      	lsls	r2, r2, #4
 800376c:	b2d2      	uxtb	r2, r2
 800376e:	440b      	add	r3, r1
 8003770:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 8003774:	370c      	adds	r7, #12
 8003776:	46bd      	mov	sp, r7
 8003778:	f85d 7b04 	ldr.w	r7, [sp], #4
 800377c:	4770      	bx	lr
 800377e:	bf00      	nop

08003780 <NVIC_GetPriority>:
    \param [in]   IRQn  Interrupt number.
    \return             Interrupt Priority. Value is aligned automatically to the implemented
                        priority bits of the microcontroller.
 */
__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
{
 8003780:	b480      	push	{r7}
 8003782:	b083      	sub	sp, #12
 8003784:	af00      	add	r7, sp, #0
 8003786:	4603      	mov	r3, r0
 8003788:	71fb      	strb	r3, [r7, #7]

  if((int32_t)IRQn < 0) {
 800378a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800378e:	2b00      	cmp	r3, #0
 8003790:	da0d      	bge.n	80037ae <NVIC_GetPriority+0x2e>
    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8 - __NVIC_PRIO_BITS)));
 8003792:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8003796:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800379a:	79fa      	ldrb	r2, [r7, #7]
 800379c:	f002 020f 	and.w	r2, r2, #15
 80037a0:	3a04      	subs	r2, #4
 80037a2:	4413      	add	r3, r2
 80037a4:	7e1b      	ldrb	r3, [r3, #24]
 80037a6:	b2db      	uxtb	r3, r3
 80037a8:	091b      	lsrs	r3, r3, #4
 80037aa:	b2db      	uxtb	r3, r3
 80037ac:	e00b      	b.n	80037c6 <NVIC_GetPriority+0x46>
  }
  else {
    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8 - __NVIC_PRIO_BITS)));
 80037ae:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 80037b2:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80037b6:	f997 2007 	ldrsb.w	r2, [r7, #7]
 80037ba:	4413      	add	r3, r2
 80037bc:	f893 3300 	ldrb.w	r3, [r3, #768]	; 0x300
 80037c0:	b2db      	uxtb	r3, r3
 80037c2:	091b      	lsrs	r3, r3, #4
 80037c4:	b2db      	uxtb	r3, r3
  }
}
 80037c6:	4618      	mov	r0, r3
 80037c8:	370c      	adds	r7, #12
 80037ca:	46bd      	mov	sp, r7
 80037cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80037d0:	4770      	bx	lr
 80037d2:	bf00      	nop

080037d4 <NVIC_EncodePriority>:
    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
    \param [in]       SubPriority  Subpriority value (starting from 0).
    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80037d4:	b480      	push	{r7}
 80037d6:	b089      	sub	sp, #36	; 0x24
 80037d8:	af00      	add	r7, sp, #0
 80037da:	60f8      	str	r0, [r7, #12]
 80037dc:	60b9      	str	r1, [r7, #8]
 80037de:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 80037e0:	68fb      	ldr	r3, [r7, #12]
 80037e2:	f003 0307 	and.w	r3, r3, #7
 80037e6:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80037e8:	69fb      	ldr	r3, [r7, #28]
 80037ea:	f1c3 0307 	rsb	r3, r3, #7
 80037ee:	2b04      	cmp	r3, #4
 80037f0:	bf28      	it	cs
 80037f2:	2304      	movcs	r3, #4
 80037f4:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80037f6:	69fb      	ldr	r3, [r7, #28]
 80037f8:	3304      	adds	r3, #4
 80037fa:	2b06      	cmp	r3, #6
 80037fc:	d902      	bls.n	8003804 <NVIC_EncodePriority+0x30>
 80037fe:	69fb      	ldr	r3, [r7, #28]
 8003800:	3b03      	subs	r3, #3
 8003802:	e000      	b.n	8003806 <NVIC_EncodePriority+0x32>
 8003804:	2300      	movs	r3, #0
 8003806:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8003808:	69bb      	ldr	r3, [r7, #24]
 800380a:	2201      	movs	r2, #1
 800380c:	fa02 f303 	lsl.w	r3, r2, r3
 8003810:	1e5a      	subs	r2, r3, #1
 8003812:	68bb      	ldr	r3, [r7, #8]
 8003814:	401a      	ands	r2, r3
 8003816:	697b      	ldr	r3, [r7, #20]
 8003818:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800381a:	697b      	ldr	r3, [r7, #20]
 800381c:	2101      	movs	r1, #1
 800381e:	fa01 f303 	lsl.w	r3, r1, r3
 8003822:	1e59      	subs	r1, r3, #1
 8003824:	687b      	ldr	r3, [r7, #4]
 8003826:	400b      	ands	r3, r1
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8003828:	4313      	orrs	r3, r2
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
         );
}
 800382a:	4618      	mov	r0, r3
 800382c:	3724      	adds	r7, #36	; 0x24
 800382e:	46bd      	mov	sp, r7
 8003830:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003834:	4770      	bx	lr
 8003836:	bf00      	nop

08003838 <NVIC_DecodePriority>:
    \param [in]     PriorityGroup  Used priority group.
    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
    \param [out]     pSubPriority  Subpriority value (starting from 0).
 */
__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
{
 8003838:	b480      	push	{r7}
 800383a:	b089      	sub	sp, #36	; 0x24
 800383c:	af00      	add	r7, sp, #0
 800383e:	60f8      	str	r0, [r7, #12]
 8003840:	60b9      	str	r1, [r7, #8]
 8003842:	607a      	str	r2, [r7, #4]
 8003844:	603b      	str	r3, [r7, #0]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8003846:	68bb      	ldr	r3, [r7, #8]
 8003848:	f003 0307 	and.w	r3, r3, #7
 800384c:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800384e:	69fb      	ldr	r3, [r7, #28]
 8003850:	f1c3 0307 	rsb	r3, r3, #7
 8003854:	2b04      	cmp	r3, #4
 8003856:	bf28      	it	cs
 8003858:	2304      	movcs	r3, #4
 800385a:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800385c:	69fb      	ldr	r3, [r7, #28]
 800385e:	3304      	adds	r3, #4
 8003860:	2b06      	cmp	r3, #6
 8003862:	d902      	bls.n	800386a <NVIC_DecodePriority+0x32>
 8003864:	69fb      	ldr	r3, [r7, #28]
 8003866:	3b03      	subs	r3, #3
 8003868:	e000      	b.n	800386c <NVIC_DecodePriority+0x34>
 800386a:	2300      	movs	r3, #0
 800386c:	617b      	str	r3, [r7, #20]

  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
 800386e:	697b      	ldr	r3, [r7, #20]
 8003870:	68fa      	ldr	r2, [r7, #12]
 8003872:	40da      	lsrs	r2, r3
 8003874:	69bb      	ldr	r3, [r7, #24]
 8003876:	2101      	movs	r1, #1
 8003878:	fa01 f303 	lsl.w	r3, r1, r3
 800387c:	3b01      	subs	r3, #1
 800387e:	401a      	ands	r2, r3
 8003880:	687b      	ldr	r3, [r7, #4]
 8003882:	601a      	str	r2, [r3, #0]
  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
 8003884:	697b      	ldr	r3, [r7, #20]
 8003886:	2201      	movs	r2, #1
 8003888:	fa02 f303 	lsl.w	r3, r2, r3
 800388c:	1e5a      	subs	r2, r3, #1
 800388e:	68fb      	ldr	r3, [r7, #12]
 8003890:	401a      	ands	r2, r3
 8003892:	683b      	ldr	r3, [r7, #0]
 8003894:	601a      	str	r2, [r3, #0]
}
 8003896:	3724      	adds	r7, #36	; 0x24
 8003898:	46bd      	mov	sp, r7
 800389a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800389e:	4770      	bx	lr

080038a0 <NVIC_SystemReset>:
/** \brief  System Reset

    The function initiates a system reset request to reset the MCU.
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
 80038a0:	b480      	push	{r7}
 80038a2:	af00      	add	r7, sp, #0
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80038a4:	f3bf 8f4f 	dsb	sy
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80038a8:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 80038ac:	f2ce 0200 	movt	r2, #57344	; 0xe000
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80038b0:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 80038b4:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80038b8:	68db      	ldr	r3, [r3, #12]
 80038ba:	f403 61e0 	and.w	r1, r3, #1792	; 0x700
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80038be:	2304      	movs	r3, #4
 80038c0:	f2c0 53fa 	movt	r3, #1530	; 0x5fa
 80038c4:	430b      	orrs	r3, r1
 80038c6:	60d3      	str	r3, [r2, #12]
 80038c8:	f3bf 8f4f 	dsb	sy

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 80038cc:	bf00      	nop
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */
  while(1) { __NOP(); }                                             /* wait until reset */
 80038ce:	e7fd      	b.n	80038cc <NVIC_SystemReset+0x2c>

080038d0 <SysTick_Config>:
    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 80038d0:	b580      	push	{r7, lr}
 80038d2:	b082      	sub	sp, #8
 80038d4:	af00      	add	r7, sp, #0
 80038d6:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
 80038d8:	687b      	ldr	r3, [r7, #4]
 80038da:	3b01      	subs	r3, #1
 80038dc:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80038e0:	d301      	bcc.n	80038e6 <SysTick_Config+0x16>
 80038e2:	2301      	movs	r3, #1
 80038e4:	e018      	b.n	8003918 <SysTick_Config+0x48>

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80038e6:	f24e 0310 	movw	r3, #57360	; 0xe010
 80038ea:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80038ee:	687a      	ldr	r2, [r7, #4]
 80038f0:	3a01      	subs	r2, #1
 80038f2:	605a      	str	r2, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 80038f4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80038f8:	210f      	movs	r1, #15
 80038fa:	f7ff ff15 	bl	8003728 <NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80038fe:	f24e 0310 	movw	r3, #57360	; 0xe010
 8003902:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003906:	2200      	movs	r2, #0
 8003908:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800390a:	f24e 0310 	movw	r3, #57360	; 0xe010
 800390e:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003912:	2207      	movs	r2, #7
 8003914:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8003916:	2300      	movs	r3, #0
}
 8003918:	4618      	mov	r0, r3
 800391a:	3708      	adds	r7, #8
 800391c:	46bd      	mov	sp, r7
 800391e:	bd80      	pop	{r7, pc}

08003920 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8003920:	b580      	push	{r7, lr}
 8003922:	b082      	sub	sp, #8
 8003924:	af00      	add	r7, sp, #0
 8003926:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8003928:	6878      	ldr	r0, [r7, #4]
 800392a:	f7ff fe25 	bl	8003578 <NVIC_SetPriorityGrouping>
}
 800392e:	3708      	adds	r7, #8
 8003930:	46bd      	mov	sp, r7
 8003932:	bd80      	pop	{r7, pc}

08003934 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8003934:	b580      	push	{r7, lr}
 8003936:	b086      	sub	sp, #24
 8003938:	af00      	add	r7, sp, #0
 800393a:	4603      	mov	r3, r0
 800393c:	60b9      	str	r1, [r7, #8]
 800393e:	607a      	str	r2, [r7, #4]
 8003940:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00;
 8003942:	2300      	movs	r3, #0
 8003944:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 8003946:	f7ff fe3f 	bl	80035c8 <NVIC_GetPriorityGrouping>
 800394a:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 800394c:	6978      	ldr	r0, [r7, #20]
 800394e:	68b9      	ldr	r1, [r7, #8]
 8003950:	687a      	ldr	r2, [r7, #4]
 8003952:	f7ff ff3f 	bl	80037d4 <NVIC_EncodePriority>
 8003956:	4603      	mov	r3, r0
 8003958:	f997 200f 	ldrsb.w	r2, [r7, #15]
 800395c:	4610      	mov	r0, r2
 800395e:	4619      	mov	r1, r3
 8003960:	f7ff fee2 	bl	8003728 <NVIC_SetPriority>
}
 8003964:	3718      	adds	r7, #24
 8003966:	46bd      	mov	sp, r7
 8003968:	bd80      	pop	{r7, pc}
 800396a:	bf00      	nop

0800396c <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800396c:	b580      	push	{r7, lr}
 800396e:	b082      	sub	sp, #8
 8003970:	af00      	add	r7, sp, #0
 8003972:	4603      	mov	r3, r0
 8003974:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8003976:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800397a:	4618      	mov	r0, r3
 800397c:	f7ff fe34 	bl	80035e8 <NVIC_EnableIRQ>
}
 8003980:	3708      	adds	r7, #8
 8003982:	46bd      	mov	sp, r7
 8003984:	bd80      	pop	{r7, pc}
 8003986:	bf00      	nop

08003988 <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
 8003988:	b580      	push	{r7, lr}
 800398a:	b082      	sub	sp, #8
 800398c:	af00      	add	r7, sp, #0
 800398e:	4603      	mov	r3, r0
 8003990:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
 8003992:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8003996:	4618      	mov	r0, r3
 8003998:	f7ff fe40 	bl	800361c <NVIC_DisableIRQ>
}
 800399c:	3708      	adds	r7, #8
 800399e:	46bd      	mov	sp, r7
 80039a0:	bd80      	pop	{r7, pc}
 80039a2:	bf00      	nop

080039a4 <HAL_NVIC_SystemReset>:
/**
  * @brief  Initiates a system reset request to reset the MCU.
  * @retval None
  */
void HAL_NVIC_SystemReset(void)
{
 80039a4:	b580      	push	{r7, lr}
 80039a6:	af00      	add	r7, sp, #0
  /* System Reset */
  NVIC_SystemReset();
 80039a8:	f7ff ff7a 	bl	80038a0 <NVIC_SystemReset>
}
 80039ac:	bd80      	pop	{r7, pc}
 80039ae:	bf00      	nop

080039b0 <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 80039b0:	b580      	push	{r7, lr}
 80039b2:	b082      	sub	sp, #8
 80039b4:	af00      	add	r7, sp, #0
 80039b6:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 80039b8:	6878      	ldr	r0, [r7, #4]
 80039ba:	f7ff ff89 	bl	80038d0 <SysTick_Config>
 80039be:	4603      	mov	r3, r0
}
 80039c0:	4618      	mov	r0, r3
 80039c2:	3708      	adds	r7, #8
 80039c4:	46bd      	mov	sp, r7
 80039c6:	bd80      	pop	{r7, pc}

080039c8 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init: Pointer to a MPU_Region_InitTypeDef structure that contains
  *                the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
 80039c8:	b480      	push	{r7}
 80039ca:	b083      	sub	sp, #12
 80039cc:	af00      	add	r7, sp, #0
 80039ce:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
 80039d0:	f64e 5390 	movw	r3, #60816	; 0xed90
 80039d4:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80039d8:	687a      	ldr	r2, [r7, #4]
 80039da:	7852      	ldrb	r2, [r2, #1]
 80039dc:	609a      	str	r2, [r3, #8]

  if ((MPU_Init->Enable) != RESET)
 80039de:	687b      	ldr	r3, [r7, #4]
 80039e0:	781b      	ldrb	r3, [r3, #0]
 80039e2:	2b00      	cmp	r3, #0
 80039e4:	d02e      	beq.n	8003a44 <HAL_MPU_ConfigRegion+0x7c>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
 80039e6:	f64e 5390 	movw	r3, #60816	; 0xed90
 80039ea:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80039ee:	687a      	ldr	r2, [r7, #4]
 80039f0:	6852      	ldr	r2, [r2, #4]
 80039f2:	60da      	str	r2, [r3, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 80039f4:	f64e 5390 	movw	r3, #60816	; 0xed90
 80039f8:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80039fc:	687a      	ldr	r2, [r7, #4]
 80039fe:	7b12      	ldrb	r2, [r2, #12]
 8003a00:	0711      	lsls	r1, r2, #28
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 8003a02:	687a      	ldr	r2, [r7, #4]
 8003a04:	7ad2      	ldrb	r2, [r2, #11]
 8003a06:	0612      	lsls	r2, r2, #24
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8003a08:	4311      	orrs	r1, r2
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 8003a0a:	687a      	ldr	r2, [r7, #4]
 8003a0c:	7a92      	ldrb	r2, [r2, #10]
 8003a0e:	04d2      	lsls	r2, r2, #19
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 8003a10:	4311      	orrs	r1, r2
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 8003a12:	687a      	ldr	r2, [r7, #4]
 8003a14:	7b52      	ldrb	r2, [r2, #13]
 8003a16:	0492      	lsls	r2, r2, #18
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 8003a18:	4311      	orrs	r1, r2
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 8003a1a:	687a      	ldr	r2, [r7, #4]
 8003a1c:	7b92      	ldrb	r2, [r2, #14]
 8003a1e:	0452      	lsls	r2, r2, #17
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 8003a20:	4311      	orrs	r1, r2
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 8003a22:	687a      	ldr	r2, [r7, #4]
 8003a24:	7bd2      	ldrb	r2, [r2, #15]
 8003a26:	0412      	lsls	r2, r2, #16
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 8003a28:	4311      	orrs	r1, r2
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 8003a2a:	687a      	ldr	r2, [r7, #4]
 8003a2c:	7a52      	ldrb	r2, [r2, #9]
 8003a2e:	0212      	lsls	r2, r2, #8
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 8003a30:	4311      	orrs	r1, r2
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8003a32:	687a      	ldr	r2, [r7, #4]
 8003a34:	7a12      	ldrb	r2, [r2, #8]
 8003a36:	0052      	lsls	r2, r2, #1
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 8003a38:	4311      	orrs	r1, r2
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
 8003a3a:	687a      	ldr	r2, [r7, #4]
 8003a3c:	7812      	ldrb	r2, [r2, #0]
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8003a3e:	430a      	orrs	r2, r1
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8003a40:	611a      	str	r2, [r3, #16]
 8003a42:	e00b      	b.n	8003a5c <HAL_MPU_ConfigRegion+0x94>
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
  }
  else
  {
    MPU->RBAR = 0x00;
 8003a44:	f64e 5390 	movw	r3, #60816	; 0xed90
 8003a48:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003a4c:	2200      	movs	r2, #0
 8003a4e:	60da      	str	r2, [r3, #12]
    MPU->RASR = 0x00;
 8003a50:	f64e 5390 	movw	r3, #60816	; 0xed90
 8003a54:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003a58:	2200      	movs	r2, #0
 8003a5a:	611a      	str	r2, [r3, #16]
  }
}
 8003a5c:	370c      	adds	r7, #12
 8003a5e:	46bd      	mov	sp, r7
 8003a60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003a64:	4770      	bx	lr
 8003a66:	bf00      	nop

08003a68 <HAL_NVIC_GetPriorityGrouping>:
/**
  * @brief  Gets the priority grouping field from the NVIC Interrupt Controller.
  * @retval Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field)
  */
uint32_t HAL_NVIC_GetPriorityGrouping(void)
{
 8003a68:	b580      	push	{r7, lr}
 8003a6a:	af00      	add	r7, sp, #0
  /* Get the PRIGROUP[10:8] field value */
  return NVIC_GetPriorityGrouping();
 8003a6c:	f7ff fdac 	bl	80035c8 <NVIC_GetPriorityGrouping>
 8003a70:	4603      	mov	r3, r0
}
 8003a72:	4618      	mov	r0, r3
 8003a74:	bd80      	pop	{r7, pc}
 8003a76:	bf00      	nop

08003a78 <HAL_NVIC_GetPriority>:
  * @param  pPreemptPriority: Pointer on the Preemptive priority value (starting from 0).
  * @param  pSubPriority: Pointer on the Subpriority value (starting from 0).
  * @retval None
  */
void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
{
 8003a78:	b580      	push	{r7, lr}
 8003a7a:	b084      	sub	sp, #16
 8003a7c:	af00      	add	r7, sp, #0
 8003a7e:	60b9      	str	r1, [r7, #8]
 8003a80:	607a      	str	r2, [r7, #4]
 8003a82:	603b      	str	r3, [r7, #0]
 8003a84:	4603      	mov	r3, r0
 8003a86:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 /* Get priority for Cortex-M system or device specific interrupts */
  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
 8003a88:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8003a8c:	4618      	mov	r0, r3
 8003a8e:	f7ff fe77 	bl	8003780 <NVIC_GetPriority>
 8003a92:	4603      	mov	r3, r0
 8003a94:	4618      	mov	r0, r3
 8003a96:	68b9      	ldr	r1, [r7, #8]
 8003a98:	687a      	ldr	r2, [r7, #4]
 8003a9a:	683b      	ldr	r3, [r7, #0]
 8003a9c:	f7ff fecc 	bl	8003838 <NVIC_DecodePriority>
}
 8003aa0:	3710      	adds	r7, #16
 8003aa2:	46bd      	mov	sp, r7
 8003aa4:	bd80      	pop	{r7, pc}
 8003aa6:	bf00      	nop

08003aa8 <HAL_NVIC_SetPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
 8003aa8:	b580      	push	{r7, lr}
 8003aaa:	b082      	sub	sp, #8
 8003aac:	af00      	add	r7, sp, #0
 8003aae:	4603      	mov	r3, r0
 8003ab0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Set interrupt pending */
  NVIC_SetPendingIRQ(IRQn);
 8003ab2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8003ab6:	4618      	mov	r0, r3
 8003ab8:	f7ff fde6 	bl	8003688 <NVIC_SetPendingIRQ>
}
 8003abc:	3708      	adds	r7, #8
 8003abe:	46bd      	mov	sp, r7
 8003ac0:	bd80      	pop	{r7, pc}
 8003ac2:	bf00      	nop

08003ac4 <HAL_NVIC_GetPendingIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval status: - 0  Interrupt status is not pending.
  *                 - 1  Interrupt status is pending.
  */
uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
 8003ac4:	b580      	push	{r7, lr}
 8003ac6:	b082      	sub	sp, #8
 8003ac8:	af00      	add	r7, sp, #0
 8003aca:	4603      	mov	r3, r0
 8003acc:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Return 1 if pending else 0 */
  return NVIC_GetPendingIRQ(IRQn);
 8003ace:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8003ad2:	4618      	mov	r0, r3
 8003ad4:	f7ff fdbc 	bl	8003650 <NVIC_GetPendingIRQ>
 8003ad8:	4603      	mov	r3, r0
}
 8003ada:	4618      	mov	r0, r3
 8003adc:	3708      	adds	r7, #8
 8003ade:	46bd      	mov	sp, r7
 8003ae0:	bd80      	pop	{r7, pc}
 8003ae2:	bf00      	nop

08003ae4 <HAL_NVIC_ClearPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
 8003ae4:	b580      	push	{r7, lr}
 8003ae6:	b082      	sub	sp, #8
 8003ae8:	af00      	add	r7, sp, #0
 8003aea:	4603      	mov	r3, r0
 8003aec:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Clear pending interrupt */
  NVIC_ClearPendingIRQ(IRQn);
 8003aee:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8003af2:	4618      	mov	r0, r3
 8003af4:	f7ff fde2 	bl	80036bc <NVIC_ClearPendingIRQ>
}
 8003af8:	3708      	adds	r7, #8
 8003afa:	46bd      	mov	sp, r7
 8003afc:	bd80      	pop	{r7, pc}
 8003afe:	bf00      	nop

08003b00 <HAL_NVIC_GetActive>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval status: - 0  Interrupt status is not pending.
  *                 - 1  Interrupt status is pending.
  */
uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)
{
 8003b00:	b580      	push	{r7, lr}
 8003b02:	b082      	sub	sp, #8
 8003b04:	af00      	add	r7, sp, #0
 8003b06:	4603      	mov	r3, r0
 8003b08:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Return 1 if active else 0 */
  return NVIC_GetActive(IRQn);
 8003b0a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8003b0e:	4618      	mov	r0, r3
 8003b10:	f7ff fdee 	bl	80036f0 <NVIC_GetActive>
 8003b14:	4603      	mov	r3, r0
}
 8003b16:	4618      	mov	r0, r3
 8003b18:	3708      	adds	r7, #8
 8003b1a:	46bd      	mov	sp, r7
 8003b1c:	bd80      	pop	{r7, pc}
 8003b1e:	bf00      	nop

08003b20 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 8003b20:	b480      	push	{r7}
 8003b22:	b083      	sub	sp, #12
 8003b24:	af00      	add	r7, sp, #0
 8003b26:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8003b28:	687b      	ldr	r3, [r7, #4]
 8003b2a:	2b04      	cmp	r3, #4
 8003b2c:	d10c      	bne.n	8003b48 <HAL_SYSTICK_CLKSourceConfig+0x28>
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8003b2e:	f24e 0310 	movw	r3, #57360	; 0xe010
 8003b32:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003b36:	f24e 0210 	movw	r2, #57360	; 0xe010
 8003b3a:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8003b3e:	6812      	ldr	r2, [r2, #0]
 8003b40:	f042 0204 	orr.w	r2, r2, #4
 8003b44:	601a      	str	r2, [r3, #0]
 8003b46:	e00b      	b.n	8003b60 <HAL_SYSTICK_CLKSourceConfig+0x40>
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8003b48:	f24e 0310 	movw	r3, #57360	; 0xe010
 8003b4c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003b50:	f24e 0210 	movw	r2, #57360	; 0xe010
 8003b54:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8003b58:	6812      	ldr	r2, [r2, #0]
 8003b5a:	f022 0204 	bic.w	r2, r2, #4
 8003b5e:	601a      	str	r2, [r3, #0]
  }
}
 8003b60:	370c      	adds	r7, #12
 8003b62:	46bd      	mov	sp, r7
 8003b64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003b68:	4770      	bx	lr
 8003b6a:	bf00      	nop

08003b6c <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 8003b6c:	b580      	push	{r7, lr}
 8003b6e:	af00      	add	r7, sp, #0
  HAL_SYSTICK_Callback();
 8003b70:	f000 f802 	bl	8003b78 <HAL_SYSTICK_Callback>
}
 8003b74:	bd80      	pop	{r7, pc}
 8003b76:	bf00      	nop

08003b78 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 8003b78:	b480      	push	{r7}
 8003b7a:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SYSTICK_Callback could be implemented in the user file
   */
}
 8003b7c:	46bd      	mov	sp, r7
 8003b7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003b82:	4770      	bx	lr

08003b84 <HAL_DAC_Init>:
  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DAC_Init(DAC_HandleTypeDef* hdac)
{ 
 8003b84:	b580      	push	{r7, lr}
 8003b86:	b082      	sub	sp, #8
 8003b88:	af00      	add	r7, sp, #0
 8003b8a:	6078      	str	r0, [r7, #4]
  /* Check DAC handle */
  if(hdac == NULL)
 8003b8c:	687b      	ldr	r3, [r7, #4]
 8003b8e:	2b00      	cmp	r3, #0
 8003b90:	d101      	bne.n	8003b96 <HAL_DAC_Init+0x12>
  {
     return HAL_ERROR;
 8003b92:	2301      	movs	r3, #1
 8003b94:	e014      	b.n	8003bc0 <HAL_DAC_Init+0x3c>
  }
  /* Check the parameters */
  assert_param(IS_DAC_ALL_INSTANCE(hdac->Instance));
  
  if(hdac->State == HAL_DAC_STATE_RESET)
 8003b96:	687b      	ldr	r3, [r7, #4]
 8003b98:	791b      	ldrb	r3, [r3, #4]
 8003b9a:	b2db      	uxtb	r3, r3
 8003b9c:	2b00      	cmp	r3, #0
 8003b9e:	d105      	bne.n	8003bac <HAL_DAC_Init+0x28>
  {  
    /* Allocate lock resource and initialize it */
    hdac->Lock = HAL_UNLOCKED;
 8003ba0:	687b      	ldr	r3, [r7, #4]
 8003ba2:	2200      	movs	r2, #0
 8003ba4:	715a      	strb	r2, [r3, #5]
    /* Init the low level hardware */
    HAL_DAC_MspInit(hdac);
 8003ba6:	6878      	ldr	r0, [r7, #4]
 8003ba8:	f7fc fda4 	bl	80006f4 <HAL_DAC_MspInit>
  }
  
  /* Initialize the DAC state*/
  hdac->State = HAL_DAC_STATE_BUSY;
 8003bac:	687b      	ldr	r3, [r7, #4]
 8003bae:	2202      	movs	r2, #2
 8003bb0:	711a      	strb	r2, [r3, #4]
  
  /* Set DAC error code to none */
  hdac->ErrorCode = HAL_DAC_ERROR_NONE;
 8003bb2:	687b      	ldr	r3, [r7, #4]
 8003bb4:	2200      	movs	r2, #0
 8003bb6:	611a      	str	r2, [r3, #16]
  
  /* Initialize the DAC state*/
  hdac->State = HAL_DAC_STATE_READY;
 8003bb8:	687b      	ldr	r3, [r7, #4]
 8003bba:	2201      	movs	r2, #1
 8003bbc:	711a      	strb	r2, [r3, #4]
  
  /* Return function status */
  return HAL_OK;
 8003bbe:	2300      	movs	r3, #0
}
 8003bc0:	4618      	mov	r0, r3
 8003bc2:	3708      	adds	r7, #8
 8003bc4:	46bd      	mov	sp, r7
 8003bc6:	bd80      	pop	{r7, pc}

08003bc8 <HAL_DAC_DeInit>:
  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DAC_DeInit(DAC_HandleTypeDef* hdac)
{
 8003bc8:	b580      	push	{r7, lr}
 8003bca:	b082      	sub	sp, #8
 8003bcc:	af00      	add	r7, sp, #0
 8003bce:	6078      	str	r0, [r7, #4]
  /* Check DAC handle */
  if(hdac == NULL)
 8003bd0:	687b      	ldr	r3, [r7, #4]
 8003bd2:	2b00      	cmp	r3, #0
 8003bd4:	d101      	bne.n	8003bda <HAL_DAC_DeInit+0x12>
  {
     return HAL_ERROR;
 8003bd6:	2301      	movs	r3, #1
 8003bd8:	e00f      	b.n	8003bfa <HAL_DAC_DeInit+0x32>

  /* Check the parameters */
  assert_param(IS_DAC_ALL_INSTANCE(hdac->Instance));

  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_BUSY;
 8003bda:	687b      	ldr	r3, [r7, #4]
 8003bdc:	2202      	movs	r2, #2
 8003bde:	711a      	strb	r2, [r3, #4]

  /* DeInit the low level hardware */
  HAL_DAC_MspDeInit(hdac);
 8003be0:	6878      	ldr	r0, [r7, #4]
 8003be2:	f7fc fdb9 	bl	8000758 <HAL_DAC_MspDeInit>

  /* Set DAC error code to none */
  hdac->ErrorCode = HAL_DAC_ERROR_NONE;
 8003be6:	687b      	ldr	r3, [r7, #4]
 8003be8:	2200      	movs	r2, #0
 8003bea:	611a      	str	r2, [r3, #16]

  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_RESET;
 8003bec:	687b      	ldr	r3, [r7, #4]
 8003bee:	2200      	movs	r2, #0
 8003bf0:	711a      	strb	r2, [r3, #4]

  /* Release Lock */
  __HAL_UNLOCK(hdac);
 8003bf2:	687b      	ldr	r3, [r7, #4]
 8003bf4:	2200      	movs	r2, #0
 8003bf6:	715a      	strb	r2, [r3, #5]

  /* Return function status */
  return HAL_OK;
 8003bf8:	2300      	movs	r3, #0
}
 8003bfa:	4618      	mov	r0, r3
 8003bfc:	3708      	adds	r7, #8
 8003bfe:	46bd      	mov	sp, r7
 8003c00:	bd80      	pop	{r7, pc}
 8003c02:	bf00      	nop
  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */
__weak void HAL_DAC_MspInit(DAC_HandleTypeDef* hdac)
{
 8003c04:	b480      	push	{r7}
 8003c06:	b083      	sub	sp, #12
 8003c08:	af00      	add	r7, sp, #0
 8003c0a:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DAC_MspInit could be implemented in the user file
   */ 
}
 8003c0c:	370c      	adds	r7, #12
 8003c0e:	46bd      	mov	sp, r7
 8003c10:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003c14:	4770      	bx	lr
 8003c16:	bf00      	nop
  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.  
  * @retval None
  */
__weak void HAL_DAC_MspDeInit(DAC_HandleTypeDef* hdac)
{
 8003c18:	b480      	push	{r7}
 8003c1a:	b083      	sub	sp, #12
 8003c1c:	af00      	add	r7, sp, #0
 8003c1e:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DAC_MspDeInit could be implemented in the user file
   */ 
}
 8003c20:	370c      	adds	r7, #12
 8003c22:	46bd      	mov	sp, r7
 8003c24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003c28:	4770      	bx	lr
 8003c2a:	bf00      	nop

08003c2c <HAL_DAC_Start>:
  *            @arg DAC_CHANNEL_1: DAC Channel1 selected
  *            @arg DAC_CHANNEL_2: DAC Channel2 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DAC_Start(DAC_HandleTypeDef* hdac, uint32_t Channel)
{
 8003c2c:	b480      	push	{r7}
 8003c2e:	b085      	sub	sp, #20
 8003c30:	af00      	add	r7, sp, #0
 8003c32:	6078      	str	r0, [r7, #4]
 8003c34:	6039      	str	r1, [r7, #0]
  uint32_t tmp1 = 0, tmp2 = 0;
 8003c36:	2300      	movs	r3, #0
 8003c38:	60fb      	str	r3, [r7, #12]
 8003c3a:	2300      	movs	r3, #0
 8003c3c:	60bb      	str	r3, [r7, #8]
  
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(Channel));
  
  /* Process locked */
  __HAL_LOCK(hdac);
 8003c3e:	687b      	ldr	r3, [r7, #4]
 8003c40:	795b      	ldrb	r3, [r3, #5]
 8003c42:	2b01      	cmp	r3, #1
 8003c44:	d101      	bne.n	8003c4a <HAL_DAC_Start+0x1e>
 8003c46:	2302      	movs	r3, #2
 8003c48:	e051      	b.n	8003cee <HAL_DAC_Start+0xc2>
 8003c4a:	687b      	ldr	r3, [r7, #4]
 8003c4c:	2201      	movs	r2, #1
 8003c4e:	715a      	strb	r2, [r3, #5]
  
  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_BUSY;
 8003c50:	687b      	ldr	r3, [r7, #4]
 8003c52:	2202      	movs	r2, #2
 8003c54:	711a      	strb	r2, [r3, #4]
  
  /* Enable the Peripheral */
  __HAL_DAC_ENABLE(hdac, Channel);
 8003c56:	687b      	ldr	r3, [r7, #4]
 8003c58:	681b      	ldr	r3, [r3, #0]
 8003c5a:	687a      	ldr	r2, [r7, #4]
 8003c5c:	6812      	ldr	r2, [r2, #0]
 8003c5e:	6811      	ldr	r1, [r2, #0]
 8003c60:	683a      	ldr	r2, [r7, #0]
 8003c62:	2001      	movs	r0, #1
 8003c64:	fa00 f202 	lsl.w	r2, r0, r2
 8003c68:	430a      	orrs	r2, r1
 8003c6a:	601a      	str	r2, [r3, #0]
  
  if(Channel == DAC_CHANNEL_1)
 8003c6c:	683b      	ldr	r3, [r7, #0]
 8003c6e:	2b00      	cmp	r3, #0
 8003c70:	d11a      	bne.n	8003ca8 <HAL_DAC_Start+0x7c>
  {
    tmp1 = hdac->Instance->CR & DAC_CR_TEN1;
 8003c72:	687b      	ldr	r3, [r7, #4]
 8003c74:	681b      	ldr	r3, [r3, #0]
 8003c76:	681b      	ldr	r3, [r3, #0]
 8003c78:	f003 0304 	and.w	r3, r3, #4
 8003c7c:	60fb      	str	r3, [r7, #12]
    tmp2 = hdac->Instance->CR & DAC_CR_TSEL1;
 8003c7e:	687b      	ldr	r3, [r7, #4]
 8003c80:	681b      	ldr	r3, [r3, #0]
 8003c82:	681b      	ldr	r3, [r3, #0]
 8003c84:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8003c88:	60bb      	str	r3, [r7, #8]
    /* Check if software trigger enabled */
    if((tmp1 ==  DAC_CR_TEN1) && (tmp2 ==  DAC_CR_TSEL1))
 8003c8a:	68fb      	ldr	r3, [r7, #12]
 8003c8c:	2b04      	cmp	r3, #4
 8003c8e:	d127      	bne.n	8003ce0 <HAL_DAC_Start+0xb4>
 8003c90:	68bb      	ldr	r3, [r7, #8]
 8003c92:	2b38      	cmp	r3, #56	; 0x38
 8003c94:	d124      	bne.n	8003ce0 <HAL_DAC_Start+0xb4>
    {
      /* Enable the selected DAC software conversion */
      hdac->Instance->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1;
 8003c96:	687b      	ldr	r3, [r7, #4]
 8003c98:	681b      	ldr	r3, [r3, #0]
 8003c9a:	687a      	ldr	r2, [r7, #4]
 8003c9c:	6812      	ldr	r2, [r2, #0]
 8003c9e:	6852      	ldr	r2, [r2, #4]
 8003ca0:	f042 0201 	orr.w	r2, r2, #1
 8003ca4:	605a      	str	r2, [r3, #4]
 8003ca6:	e01b      	b.n	8003ce0 <HAL_DAC_Start+0xb4>
    }
  }
  else
  {
    tmp1 = hdac->Instance->CR & DAC_CR_TEN2;
 8003ca8:	687b      	ldr	r3, [r7, #4]
 8003caa:	681b      	ldr	r3, [r3, #0]
 8003cac:	681b      	ldr	r3, [r3, #0]
 8003cae:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8003cb2:	60fb      	str	r3, [r7, #12]
    tmp2 = hdac->Instance->CR & DAC_CR_TSEL2;    
 8003cb4:	687b      	ldr	r3, [r7, #4]
 8003cb6:	681b      	ldr	r3, [r3, #0]
 8003cb8:	681b      	ldr	r3, [r3, #0]
 8003cba:	f403 1360 	and.w	r3, r3, #3670016	; 0x380000
 8003cbe:	60bb      	str	r3, [r7, #8]
    /* Check if software trigger enabled */
    if((tmp1 == DAC_CR_TEN2) && (tmp2 == DAC_CR_TSEL2))
 8003cc0:	68fb      	ldr	r3, [r7, #12]
 8003cc2:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8003cc6:	d10b      	bne.n	8003ce0 <HAL_DAC_Start+0xb4>
 8003cc8:	68bb      	ldr	r3, [r7, #8]
 8003cca:	f5b3 1f60 	cmp.w	r3, #3670016	; 0x380000
 8003cce:	d107      	bne.n	8003ce0 <HAL_DAC_Start+0xb4>
    {
      /* Enable the selected DAC software conversion*/
      hdac->Instance->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG2;
 8003cd0:	687b      	ldr	r3, [r7, #4]
 8003cd2:	681b      	ldr	r3, [r3, #0]
 8003cd4:	687a      	ldr	r2, [r7, #4]
 8003cd6:	6812      	ldr	r2, [r2, #0]
 8003cd8:	6852      	ldr	r2, [r2, #4]
 8003cda:	f042 0202 	orr.w	r2, r2, #2
 8003cde:	605a      	str	r2, [r3, #4]
    }
  }
  
  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_READY;
 8003ce0:	687b      	ldr	r3, [r7, #4]
 8003ce2:	2201      	movs	r2, #1
 8003ce4:	711a      	strb	r2, [r3, #4]
  
  /* Process unlocked */
  __HAL_UNLOCK(hdac);
 8003ce6:	687b      	ldr	r3, [r7, #4]
 8003ce8:	2200      	movs	r2, #0
 8003cea:	715a      	strb	r2, [r3, #5]
    
  /* Return function status */
  return HAL_OK;
 8003cec:	2300      	movs	r3, #0
}
 8003cee:	4618      	mov	r0, r3
 8003cf0:	3714      	adds	r7, #20
 8003cf2:	46bd      	mov	sp, r7
 8003cf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003cf8:	4770      	bx	lr
 8003cfa:	bf00      	nop

08003cfc <HAL_DAC_Stop>:
  *            @arg DAC_CHANNEL_1: DAC Channel1 selected
  *            @arg DAC_CHANNEL_2: DAC Channel2 selected  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DAC_Stop(DAC_HandleTypeDef* hdac, uint32_t Channel)
{
 8003cfc:	b480      	push	{r7}
 8003cfe:	b083      	sub	sp, #12
 8003d00:	af00      	add	r7, sp, #0
 8003d02:	6078      	str	r0, [r7, #4]
 8003d04:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(Channel));
  
  /* Disable the Peripheral */
  __HAL_DAC_DISABLE(hdac, Channel);
 8003d06:	687b      	ldr	r3, [r7, #4]
 8003d08:	681b      	ldr	r3, [r3, #0]
 8003d0a:	687a      	ldr	r2, [r7, #4]
 8003d0c:	6812      	ldr	r2, [r2, #0]
 8003d0e:	6811      	ldr	r1, [r2, #0]
 8003d10:	683a      	ldr	r2, [r7, #0]
 8003d12:	2001      	movs	r0, #1
 8003d14:	fa00 f202 	lsl.w	r2, r0, r2
 8003d18:	43d2      	mvns	r2, r2
 8003d1a:	400a      	ands	r2, r1
 8003d1c:	601a      	str	r2, [r3, #0]
 
  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_READY;
 8003d1e:	687b      	ldr	r3, [r7, #4]
 8003d20:	2201      	movs	r2, #1
 8003d22:	711a      	strb	r2, [r3, #4]
  
  /* Return function status */
  return HAL_OK;
 8003d24:	2300      	movs	r3, #0
}
 8003d26:	4618      	mov	r0, r3
 8003d28:	370c      	adds	r7, #12
 8003d2a:	46bd      	mov	sp, r7
 8003d2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003d30:	4770      	bx	lr
 8003d32:	bf00      	nop

08003d34 <HAL_DAC_Start_DMA>:
  *            @arg DAC_ALIGN_12B_L: 12bit left data alignment selected
  *            @arg DAC_ALIGN_12B_R: 12bit right data alignment selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DAC_Start_DMA(DAC_HandleTypeDef* hdac, uint32_t Channel, uint32_t* pData, uint32_t Length, uint32_t Alignment)
{
 8003d34:	b580      	push	{r7, lr}
 8003d36:	b086      	sub	sp, #24
 8003d38:	af00      	add	r7, sp, #0
 8003d3a:	60f8      	str	r0, [r7, #12]
 8003d3c:	60b9      	str	r1, [r7, #8]
 8003d3e:	607a      	str	r2, [r7, #4]
 8003d40:	603b      	str	r3, [r7, #0]
  uint32_t tmpreg = 0;
 8003d42:	2300      	movs	r3, #0
 8003d44:	617b      	str	r3, [r7, #20]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(Channel));
  assert_param(IS_DAC_ALIGN(Alignment));
  
  /* Process locked */
  __HAL_LOCK(hdac);
 8003d46:	68fb      	ldr	r3, [r7, #12]
 8003d48:	795b      	ldrb	r3, [r3, #5]
 8003d4a:	2b01      	cmp	r3, #1
 8003d4c:	d101      	bne.n	8003d52 <HAL_DAC_Start_DMA+0x1e>
 8003d4e:	2302      	movs	r3, #2
 8003d50:	e0a6      	b.n	8003ea0 <HAL_DAC_Start_DMA+0x16c>
 8003d52:	68fb      	ldr	r3, [r7, #12]
 8003d54:	2201      	movs	r2, #1
 8003d56:	715a      	strb	r2, [r3, #5]
  
  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_BUSY;
 8003d58:	68fb      	ldr	r3, [r7, #12]
 8003d5a:	2202      	movs	r2, #2
 8003d5c:	711a      	strb	r2, [r3, #4]

  if(Channel == DAC_CHANNEL_1)
 8003d5e:	68bb      	ldr	r3, [r7, #8]
 8003d60:	2b00      	cmp	r3, #0
 8003d62:	d134      	bne.n	8003dce <HAL_DAC_Start_DMA+0x9a>
  {
    /* Set the DMA transfer complete callback for channel1 */
    hdac->DMA_Handle1->XferCpltCallback = DAC_DMAConvCpltCh1;
 8003d64:	68fb      	ldr	r3, [r7, #12]
 8003d66:	689a      	ldr	r2, [r3, #8]
 8003d68:	f244 1351 	movw	r3, #16721	; 0x4151
 8003d6c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003d70:	63d3      	str	r3, [r2, #60]	; 0x3c

    /* Set the DMA half transfer complete callback for channel1 */
    hdac->DMA_Handle1->XferHalfCpltCallback = DAC_DMAHalfConvCpltCh1;
 8003d72:	68fb      	ldr	r3, [r7, #12]
 8003d74:	689a      	ldr	r2, [r3, #8]
 8003d76:	f244 1371 	movw	r3, #16753	; 0x4171
 8003d7a:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003d7e:	6413      	str	r3, [r2, #64]	; 0x40

    /* Set the DMA error callback for channel1 */
    hdac->DMA_Handle1->XferErrorCallback = DAC_DMAErrorCh1;
 8003d80:	68fb      	ldr	r3, [r7, #12]
 8003d82:	689a      	ldr	r2, [r3, #8]
 8003d84:	f244 138d 	movw	r3, #16781	; 0x418d
 8003d88:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003d8c:	6493      	str	r3, [r2, #72]	; 0x48

    /* Enable the selected DAC channel1 DMA request */
    hdac->Instance->CR |= DAC_CR_DMAEN1;
 8003d8e:	68fb      	ldr	r3, [r7, #12]
 8003d90:	681b      	ldr	r3, [r3, #0]
 8003d92:	68fa      	ldr	r2, [r7, #12]
 8003d94:	6812      	ldr	r2, [r2, #0]
 8003d96:	6812      	ldr	r2, [r2, #0]
 8003d98:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8003d9c:	601a      	str	r2, [r3, #0]
    
    /* Case of use of channel 1 */
    switch(Alignment)
 8003d9e:	6a3b      	ldr	r3, [r7, #32]
 8003da0:	2b04      	cmp	r3, #4
 8003da2:	d009      	beq.n	8003db8 <HAL_DAC_Start_DMA+0x84>
 8003da4:	2b08      	cmp	r3, #8
 8003da6:	d00c      	beq.n	8003dc2 <HAL_DAC_Start_DMA+0x8e>
 8003da8:	2b00      	cmp	r3, #0
 8003daa:	d000      	beq.n	8003dae <HAL_DAC_Start_DMA+0x7a>
      case DAC_ALIGN_8B_R:
        /* Get DHR8R1 address */
        tmpreg = (uint32_t)&hdac->Instance->DHR8R1;
        break;
      default:
        break;
 8003dac:	e00e      	b.n	8003dcc <HAL_DAC_Start_DMA+0x98>
    /* Case of use of channel 1 */
    switch(Alignment)
    {
      case DAC_ALIGN_12B_R:
        /* Get DHR12R1 address */
        tmpreg = (uint32_t)&hdac->Instance->DHR12R1;
 8003dae:	68fb      	ldr	r3, [r7, #12]
 8003db0:	681b      	ldr	r3, [r3, #0]
 8003db2:	3308      	adds	r3, #8
 8003db4:	617b      	str	r3, [r7, #20]
        break;
 8003db6:	e009      	b.n	8003dcc <HAL_DAC_Start_DMA+0x98>
      case DAC_ALIGN_12B_L:
        /* Get DHR12L1 address */
        tmpreg = (uint32_t)&hdac->Instance->DHR12L1;
 8003db8:	68fb      	ldr	r3, [r7, #12]
 8003dba:	681b      	ldr	r3, [r3, #0]
 8003dbc:	330c      	adds	r3, #12
 8003dbe:	617b      	str	r3, [r7, #20]
        break;
 8003dc0:	e004      	b.n	8003dcc <HAL_DAC_Start_DMA+0x98>
      case DAC_ALIGN_8B_R:
        /* Get DHR8R1 address */
        tmpreg = (uint32_t)&hdac->Instance->DHR8R1;
 8003dc2:	68fb      	ldr	r3, [r7, #12]
 8003dc4:	681b      	ldr	r3, [r3, #0]
 8003dc6:	3310      	adds	r3, #16
 8003dc8:	617b      	str	r3, [r7, #20]
        break;
 8003dca:	bf00      	nop
 8003dcc:	e033      	b.n	8003e36 <HAL_DAC_Start_DMA+0x102>
    }
  }
  else
  {
    /* Set the DMA transfer complete callback for channel2 */
    hdac->DMA_Handle2->XferCpltCallback = DAC_DMAConvCpltCh2;
 8003dce:	68fb      	ldr	r3, [r7, #12]
 8003dd0:	68da      	ldr	r2, [r3, #12]
 8003dd2:	f244 3365 	movw	r3, #17253	; 0x4365
 8003dd6:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003dda:	63d3      	str	r3, [r2, #60]	; 0x3c

    /* Set the DMA half transfer complete callback for channel2 */
    hdac->DMA_Handle2->XferHalfCpltCallback = DAC_DMAHalfConvCpltCh2;
 8003ddc:	68fb      	ldr	r3, [r7, #12]
 8003dde:	68da      	ldr	r2, [r3, #12]
 8003de0:	f244 3385 	movw	r3, #17285	; 0x4385
 8003de4:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003de8:	6413      	str	r3, [r2, #64]	; 0x40

    /* Set the DMA error callback for channel2 */
    hdac->DMA_Handle2->XferErrorCallback = DAC_DMAErrorCh2;
 8003dea:	68fb      	ldr	r3, [r7, #12]
 8003dec:	68da      	ldr	r2, [r3, #12]
 8003dee:	f244 33a1 	movw	r3, #17313	; 0x43a1
 8003df2:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003df6:	6493      	str	r3, [r2, #72]	; 0x48

    /* Enable the selected DAC channel2 DMA request */
    hdac->Instance->CR |= DAC_CR_DMAEN2;
 8003df8:	68fb      	ldr	r3, [r7, #12]
 8003dfa:	681b      	ldr	r3, [r3, #0]
 8003dfc:	68fa      	ldr	r2, [r7, #12]
 8003dfe:	6812      	ldr	r2, [r2, #0]
 8003e00:	6812      	ldr	r2, [r2, #0]
 8003e02:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8003e06:	601a      	str	r2, [r3, #0]

    /* Case of use of channel 2 */
    switch(Alignment)
 8003e08:	6a3b      	ldr	r3, [r7, #32]
 8003e0a:	2b04      	cmp	r3, #4
 8003e0c:	d009      	beq.n	8003e22 <HAL_DAC_Start_DMA+0xee>
 8003e0e:	2b08      	cmp	r3, #8
 8003e10:	d00c      	beq.n	8003e2c <HAL_DAC_Start_DMA+0xf8>
 8003e12:	2b00      	cmp	r3, #0
 8003e14:	d000      	beq.n	8003e18 <HAL_DAC_Start_DMA+0xe4>
      case DAC_ALIGN_8B_R:
        /* Get DHR8R2 address */
        tmpreg = (uint32_t)&hdac->Instance->DHR8R2;
        break;
      default:
        break;
 8003e16:	e00e      	b.n	8003e36 <HAL_DAC_Start_DMA+0x102>
    /* Case of use of channel 2 */
    switch(Alignment)
    {
      case DAC_ALIGN_12B_R:
        /* Get DHR12R2 address */
        tmpreg = (uint32_t)&hdac->Instance->DHR12R2;
 8003e18:	68fb      	ldr	r3, [r7, #12]
 8003e1a:	681b      	ldr	r3, [r3, #0]
 8003e1c:	3314      	adds	r3, #20
 8003e1e:	617b      	str	r3, [r7, #20]
        break;
 8003e20:	e009      	b.n	8003e36 <HAL_DAC_Start_DMA+0x102>
      case DAC_ALIGN_12B_L:
        /* Get DHR12L2 address */
        tmpreg = (uint32_t)&hdac->Instance->DHR12L2;
 8003e22:	68fb      	ldr	r3, [r7, #12]
 8003e24:	681b      	ldr	r3, [r3, #0]
 8003e26:	3318      	adds	r3, #24
 8003e28:	617b      	str	r3, [r7, #20]
        break;
 8003e2a:	e004      	b.n	8003e36 <HAL_DAC_Start_DMA+0x102>
      case DAC_ALIGN_8B_R:
        /* Get DHR8R2 address */
        tmpreg = (uint32_t)&hdac->Instance->DHR8R2;
 8003e2c:	68fb      	ldr	r3, [r7, #12]
 8003e2e:	681b      	ldr	r3, [r3, #0]
 8003e30:	331c      	adds	r3, #28
 8003e32:	617b      	str	r3, [r7, #20]
        break;
 8003e34:	bf00      	nop
        break;
    }
  }
  
  /* Enable the DMA Stream */
  if(Channel == DAC_CHANNEL_1)
 8003e36:	68bb      	ldr	r3, [r7, #8]
 8003e38:	2b00      	cmp	r3, #0
 8003e3a:	d111      	bne.n	8003e60 <HAL_DAC_Start_DMA+0x12c>
  {
    /* Enable the DAC DMA underrun interrupt */
    __HAL_DAC_ENABLE_IT(hdac, DAC_IT_DMAUDR1);
 8003e3c:	68fb      	ldr	r3, [r7, #12]
 8003e3e:	681b      	ldr	r3, [r3, #0]
 8003e40:	68fa      	ldr	r2, [r7, #12]
 8003e42:	6812      	ldr	r2, [r2, #0]
 8003e44:	6812      	ldr	r2, [r2, #0]
 8003e46:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8003e4a:	601a      	str	r2, [r3, #0]
    
    /* Enable the DMA Stream */
    HAL_DMA_Start_IT(hdac->DMA_Handle1, (uint32_t)pData, tmpreg, Length);
 8003e4c:	68fb      	ldr	r3, [r7, #12]
 8003e4e:	689a      	ldr	r2, [r3, #8]
 8003e50:	687b      	ldr	r3, [r7, #4]
 8003e52:	4610      	mov	r0, r2
 8003e54:	4619      	mov	r1, r3
 8003e56:	697a      	ldr	r2, [r7, #20]
 8003e58:	683b      	ldr	r3, [r7, #0]
 8003e5a:	f000 fba5 	bl	80045a8 <HAL_DMA_Start_IT>
 8003e5e:	e010      	b.n	8003e82 <HAL_DAC_Start_DMA+0x14e>
  } 
  else
  {
    /* Enable the DAC DMA underrun interrupt */
    __HAL_DAC_ENABLE_IT(hdac, DAC_IT_DMAUDR2);
 8003e60:	68fb      	ldr	r3, [r7, #12]
 8003e62:	681b      	ldr	r3, [r3, #0]
 8003e64:	68fa      	ldr	r2, [r7, #12]
 8003e66:	6812      	ldr	r2, [r2, #0]
 8003e68:	6812      	ldr	r2, [r2, #0]
 8003e6a:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8003e6e:	601a      	str	r2, [r3, #0]
    
    /* Enable the DMA Stream */
    HAL_DMA_Start_IT(hdac->DMA_Handle2, (uint32_t)pData, tmpreg, Length);
 8003e70:	68fb      	ldr	r3, [r7, #12]
 8003e72:	68da      	ldr	r2, [r3, #12]
 8003e74:	687b      	ldr	r3, [r7, #4]
 8003e76:	4610      	mov	r0, r2
 8003e78:	4619      	mov	r1, r3
 8003e7a:	697a      	ldr	r2, [r7, #20]
 8003e7c:	683b      	ldr	r3, [r7, #0]
 8003e7e:	f000 fb93 	bl	80045a8 <HAL_DMA_Start_IT>
  }
  
  /* Enable the Peripheral */
  __HAL_DAC_ENABLE(hdac, Channel);
 8003e82:	68fb      	ldr	r3, [r7, #12]
 8003e84:	681b      	ldr	r3, [r3, #0]
 8003e86:	68fa      	ldr	r2, [r7, #12]
 8003e88:	6812      	ldr	r2, [r2, #0]
 8003e8a:	6811      	ldr	r1, [r2, #0]
 8003e8c:	68ba      	ldr	r2, [r7, #8]
 8003e8e:	2001      	movs	r0, #1
 8003e90:	fa00 f202 	lsl.w	r2, r0, r2
 8003e94:	430a      	orrs	r2, r1
 8003e96:	601a      	str	r2, [r3, #0]
  
  /* Process Unlocked */
  __HAL_UNLOCK(hdac);
 8003e98:	68fb      	ldr	r3, [r7, #12]
 8003e9a:	2200      	movs	r2, #0
 8003e9c:	715a      	strb	r2, [r3, #5]
  
  /* Return function status */
  return HAL_OK;
 8003e9e:	2300      	movs	r3, #0
}
 8003ea0:	4618      	mov	r0, r3
 8003ea2:	3718      	adds	r7, #24
 8003ea4:	46bd      	mov	sp, r7
 8003ea6:	bd80      	pop	{r7, pc}

08003ea8 <HAL_DAC_Stop_DMA>:
  *            @arg DAC_CHANNEL_1: DAC Channel1 selected
  *            @arg DAC_CHANNEL_2: DAC Channel2 selected   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DAC_Stop_DMA(DAC_HandleTypeDef* hdac, uint32_t Channel)
{
 8003ea8:	b580      	push	{r7, lr}
 8003eaa:	b084      	sub	sp, #16
 8003eac:	af00      	add	r7, sp, #0
 8003eae:	6078      	str	r0, [r7, #4]
 8003eb0:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8003eb2:	2300      	movs	r3, #0
 8003eb4:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(Channel));
  
  /* Disable the selected DAC channel DMA request */
   hdac->Instance->CR &= ~(DAC_CR_DMAEN1 << Channel);
 8003eb6:	687b      	ldr	r3, [r7, #4]
 8003eb8:	681b      	ldr	r3, [r3, #0]
 8003eba:	687a      	ldr	r2, [r7, #4]
 8003ebc:	6812      	ldr	r2, [r2, #0]
 8003ebe:	6811      	ldr	r1, [r2, #0]
 8003ec0:	683a      	ldr	r2, [r7, #0]
 8003ec2:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8003ec6:	fa00 f202 	lsl.w	r2, r0, r2
 8003eca:	43d2      	mvns	r2, r2
 8003ecc:	400a      	ands	r2, r1
 8003ece:	601a      	str	r2, [r3, #0]
    
  /* Disable the Peripheral */
  __HAL_DAC_DISABLE(hdac, Channel);
 8003ed0:	687b      	ldr	r3, [r7, #4]
 8003ed2:	681b      	ldr	r3, [r3, #0]
 8003ed4:	687a      	ldr	r2, [r7, #4]
 8003ed6:	6812      	ldr	r2, [r2, #0]
 8003ed8:	6811      	ldr	r1, [r2, #0]
 8003eda:	683a      	ldr	r2, [r7, #0]
 8003edc:	2001      	movs	r0, #1
 8003ede:	fa00 f202 	lsl.w	r2, r0, r2
 8003ee2:	43d2      	mvns	r2, r2
 8003ee4:	400a      	ands	r2, r1
 8003ee6:	601a      	str	r2, [r3, #0]
  
  /* Disable the DMA Channel */
  /* Channel1 is used */
  if(Channel == DAC_CHANNEL_1)
 8003ee8:	683b      	ldr	r3, [r7, #0]
 8003eea:	2b00      	cmp	r3, #0
 8003eec:	d107      	bne.n	8003efe <HAL_DAC_Stop_DMA+0x56>
  { 
    status = HAL_DMA_Abort(hdac->DMA_Handle1);
 8003eee:	687b      	ldr	r3, [r7, #4]
 8003ef0:	689b      	ldr	r3, [r3, #8]
 8003ef2:	4618      	mov	r0, r3
 8003ef4:	f000 fb9a 	bl	800462c <HAL_DMA_Abort>
 8003ef8:	4603      	mov	r3, r0
 8003efa:	73fb      	strb	r3, [r7, #15]
 8003efc:	e006      	b.n	8003f0c <HAL_DAC_Stop_DMA+0x64>
  }
  else /* Channel2 is used for */
  { 
    status = HAL_DMA_Abort(hdac->DMA_Handle2); 
 8003efe:	687b      	ldr	r3, [r7, #4]
 8003f00:	68db      	ldr	r3, [r3, #12]
 8003f02:	4618      	mov	r0, r3
 8003f04:	f000 fb92 	bl	800462c <HAL_DMA_Abort>
 8003f08:	4603      	mov	r3, r0
 8003f0a:	73fb      	strb	r3, [r7, #15]
  }

  /* Check if DMA Channel effectively disabled */
  if(status != HAL_OK)
 8003f0c:	7bfb      	ldrb	r3, [r7, #15]
 8003f0e:	2b00      	cmp	r3, #0
 8003f10:	d003      	beq.n	8003f1a <HAL_DAC_Stop_DMA+0x72>
  {
    /* Update DAC state machine to error */
    hdac->State = HAL_DAC_STATE_ERROR;      
 8003f12:	687b      	ldr	r3, [r7, #4]
 8003f14:	2204      	movs	r2, #4
 8003f16:	711a      	strb	r2, [r3, #4]
 8003f18:	e002      	b.n	8003f20 <HAL_DAC_Stop_DMA+0x78>
  }
  else
  {
    /* Change DAC state */
    hdac->State = HAL_DAC_STATE_READY;
 8003f1a:	687b      	ldr	r3, [r7, #4]
 8003f1c:	2201      	movs	r2, #1
 8003f1e:	711a      	strb	r2, [r3, #4]
  }

  /* Return function status */
  return status;
 8003f20:	7bfb      	ldrb	r3, [r7, #15]
}
 8003f22:	4618      	mov	r0, r3
 8003f24:	3710      	adds	r7, #16
 8003f26:	46bd      	mov	sp, r7
 8003f28:	bd80      	pop	{r7, pc}
 8003f2a:	bf00      	nop

08003f2c <HAL_DAC_GetValue>:
  *            @arg DAC_CHANNEL_1: DAC Channel1 selected
  *            @arg DAC_CHANNEL_2: DAC Channel2 selected
  * @retval The selected DAC channel data output value.
  */
uint32_t HAL_DAC_GetValue(DAC_HandleTypeDef* hdac, uint32_t Channel)
{
 8003f2c:	b480      	push	{r7}
 8003f2e:	b083      	sub	sp, #12
 8003f30:	af00      	add	r7, sp, #0
 8003f32:	6078      	str	r0, [r7, #4]
 8003f34:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(Channel));
  
  /* Returns the DAC channel data output register value */
  if(Channel == DAC_CHANNEL_1)
 8003f36:	683b      	ldr	r3, [r7, #0]
 8003f38:	2b00      	cmp	r3, #0
 8003f3a:	d103      	bne.n	8003f44 <HAL_DAC_GetValue+0x18>
  {
    return hdac->Instance->DOR1;
 8003f3c:	687b      	ldr	r3, [r7, #4]
 8003f3e:	681b      	ldr	r3, [r3, #0]
 8003f40:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003f42:	e002      	b.n	8003f4a <HAL_DAC_GetValue+0x1e>
  }
  else
  {
    return hdac->Instance->DOR2;
 8003f44:	687b      	ldr	r3, [r7, #4]
 8003f46:	681b      	ldr	r3, [r3, #0]
 8003f48:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  }
}
 8003f4a:	4618      	mov	r0, r3
 8003f4c:	370c      	adds	r7, #12
 8003f4e:	46bd      	mov	sp, r7
 8003f50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003f54:	4770      	bx	lr
 8003f56:	bf00      	nop

08003f58 <HAL_DAC_IRQHandler>:
  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */
void HAL_DAC_IRQHandler(DAC_HandleTypeDef* hdac)
{
 8003f58:	b580      	push	{r7, lr}
 8003f5a:	b082      	sub	sp, #8
 8003f5c:	af00      	add	r7, sp, #0
 8003f5e:	6078      	str	r0, [r7, #4]
  /* Check underrun channel 1 flag */
  if(__HAL_DAC_GET_FLAG(hdac, DAC_FLAG_DMAUDR1))
 8003f60:	687b      	ldr	r3, [r7, #4]
 8003f62:	681b      	ldr	r3, [r3, #0]
 8003f64:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003f66:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8003f6a:	2b00      	cmp	r3, #0
 8003f6c:	d018      	beq.n	8003fa0 <HAL_DAC_IRQHandler+0x48>
  {
    /* Change DAC state to error state */
    hdac->State = HAL_DAC_STATE_ERROR;
 8003f6e:	687b      	ldr	r3, [r7, #4]
 8003f70:	2204      	movs	r2, #4
 8003f72:	711a      	strb	r2, [r3, #4]
    
    /* Set DAC error code to channel1 DMA underrun error */
    hdac->ErrorCode |= HAL_DAC_ERROR_DMAUNDERRUNCH1;
 8003f74:	687b      	ldr	r3, [r7, #4]
 8003f76:	691b      	ldr	r3, [r3, #16]
 8003f78:	f043 0201 	orr.w	r2, r3, #1
 8003f7c:	687b      	ldr	r3, [r7, #4]
 8003f7e:	611a      	str	r2, [r3, #16]
    
    /* Clear the underrun flag */
    __HAL_DAC_CLEAR_FLAG(hdac,DAC_FLAG_DMAUDR1);
 8003f80:	687b      	ldr	r3, [r7, #4]
 8003f82:	681b      	ldr	r3, [r3, #0]
 8003f84:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8003f88:	635a      	str	r2, [r3, #52]	; 0x34
    
    /* Disable the selected DAC channel1 DMA request */
    hdac->Instance->CR &= ~DAC_CR_DMAEN1;
 8003f8a:	687b      	ldr	r3, [r7, #4]
 8003f8c:	681b      	ldr	r3, [r3, #0]
 8003f8e:	687a      	ldr	r2, [r7, #4]
 8003f90:	6812      	ldr	r2, [r2, #0]
 8003f92:	6812      	ldr	r2, [r2, #0]
 8003f94:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8003f98:	601a      	str	r2, [r3, #0]
    
    /* Error callback */ 
    HAL_DAC_DMAUnderrunCallbackCh1(hdac);
 8003f9a:	6878      	ldr	r0, [r7, #4]
 8003f9c:	f000 f842 	bl	8004024 <HAL_DAC_DMAUnderrunCallbackCh1>
  }
  /* Check underrun channel 2 flag */
  if(__HAL_DAC_GET_FLAG(hdac, DAC_FLAG_DMAUDR2))
 8003fa0:	687b      	ldr	r3, [r7, #4]
 8003fa2:	681b      	ldr	r3, [r3, #0]
 8003fa4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003fa6:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8003faa:	2b00      	cmp	r3, #0
 8003fac:	d018      	beq.n	8003fe0 <HAL_DAC_IRQHandler+0x88>
  {
    /* Change DAC state to error state */
    hdac->State = HAL_DAC_STATE_ERROR;
 8003fae:	687b      	ldr	r3, [r7, #4]
 8003fb0:	2204      	movs	r2, #4
 8003fb2:	711a      	strb	r2, [r3, #4]
    
    /* Set DAC error code to channel2 DMA underrun error */
    hdac->ErrorCode |= HAL_DAC_ERROR_DMAUNDERRUNCH2;
 8003fb4:	687b      	ldr	r3, [r7, #4]
 8003fb6:	691b      	ldr	r3, [r3, #16]
 8003fb8:	f043 0202 	orr.w	r2, r3, #2
 8003fbc:	687b      	ldr	r3, [r7, #4]
 8003fbe:	611a      	str	r2, [r3, #16]
    
    /* Clear the underrun flag */
    __HAL_DAC_CLEAR_FLAG(hdac,DAC_FLAG_DMAUDR2);
 8003fc0:	687b      	ldr	r3, [r7, #4]
 8003fc2:	681b      	ldr	r3, [r3, #0]
 8003fc4:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
 8003fc8:	635a      	str	r2, [r3, #52]	; 0x34
    
    /* Disable the selected DAC channel1 DMA request */
    hdac->Instance->CR &= ~DAC_CR_DMAEN2;
 8003fca:	687b      	ldr	r3, [r7, #4]
 8003fcc:	681b      	ldr	r3, [r3, #0]
 8003fce:	687a      	ldr	r2, [r7, #4]
 8003fd0:	6812      	ldr	r2, [r2, #0]
 8003fd2:	6812      	ldr	r2, [r2, #0]
 8003fd4:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 8003fd8:	601a      	str	r2, [r3, #0]
    
    /* Error callback */ 
    HAL_DACEx_DMAUnderrunCallbackCh2(hdac);
 8003fda:	6878      	ldr	r0, [r7, #4]
 8003fdc:	f000 f9b8 	bl	8004350 <HAL_DACEx_DMAUnderrunCallbackCh2>
  }
}
 8003fe0:	3708      	adds	r7, #8
 8003fe2:	46bd      	mov	sp, r7
 8003fe4:	bd80      	pop	{r7, pc}
 8003fe6:	bf00      	nop

08003fe8 <HAL_DAC_ConvCpltCallbackCh1>:
  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */
__weak void HAL_DAC_ConvCpltCallbackCh1(DAC_HandleTypeDef* hdac)
{
 8003fe8:	b480      	push	{r7}
 8003fea:	b083      	sub	sp, #12
 8003fec:	af00      	add	r7, sp, #0
 8003fee:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DAC_ConvCpltCallback could be implemented in the user file
   */
}
 8003ff0:	370c      	adds	r7, #12
 8003ff2:	46bd      	mov	sp, r7
 8003ff4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003ff8:	4770      	bx	lr
 8003ffa:	bf00      	nop

08003ffc <HAL_DAC_ConvHalfCpltCallbackCh1>:
  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */
__weak void HAL_DAC_ConvHalfCpltCallbackCh1(DAC_HandleTypeDef* hdac)
{
 8003ffc:	b480      	push	{r7}
 8003ffe:	b083      	sub	sp, #12
 8004000:	af00      	add	r7, sp, #0
 8004002:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DAC_ConvHalfCpltCallbackCh1 could be implemented in the user file
   */
}
 8004004:	370c      	adds	r7, #12
 8004006:	46bd      	mov	sp, r7
 8004008:	f85d 7b04 	ldr.w	r7, [sp], #4
 800400c:	4770      	bx	lr
 800400e:	bf00      	nop

08004010 <HAL_DAC_ErrorCallbackCh1>:
  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */
__weak void HAL_DAC_ErrorCallbackCh1(DAC_HandleTypeDef *hdac)
{
 8004010:	b480      	push	{r7}
 8004012:	b083      	sub	sp, #12
 8004014:	af00      	add	r7, sp, #0
 8004016:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DAC_ErrorCallbackCh1 could be implemented in the user file
   */
}
 8004018:	370c      	adds	r7, #12
 800401a:	46bd      	mov	sp, r7
 800401c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004020:	4770      	bx	lr
 8004022:	bf00      	nop

08004024 <HAL_DAC_DMAUnderrunCallbackCh1>:
  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */
__weak void HAL_DAC_DMAUnderrunCallbackCh1(DAC_HandleTypeDef *hdac)
{
 8004024:	b480      	push	{r7}
 8004026:	b083      	sub	sp, #12
 8004028:	af00      	add	r7, sp, #0
 800402a:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DAC_DMAUnderrunCallbackCh1 could be implemented in the user file
   */
}
 800402c:	370c      	adds	r7, #12
 800402e:	46bd      	mov	sp, r7
 8004030:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004034:	4770      	bx	lr
 8004036:	bf00      	nop

08004038 <HAL_DAC_ConfigChannel>:
  *            @arg DAC_CHANNEL_1: DAC Channel1 selected
  *            @arg DAC_CHANNEL_2: DAC Channel2 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DAC_ConfigChannel(DAC_HandleTypeDef* hdac, DAC_ChannelConfTypeDef* sConfig, uint32_t Channel)
{
 8004038:	b480      	push	{r7}
 800403a:	b087      	sub	sp, #28
 800403c:	af00      	add	r7, sp, #0
 800403e:	60f8      	str	r0, [r7, #12]
 8004040:	60b9      	str	r1, [r7, #8]
 8004042:	607a      	str	r2, [r7, #4]
  uint32_t tmpreg1 = 0, tmpreg2 = 0;
 8004044:	2300      	movs	r3, #0
 8004046:	617b      	str	r3, [r7, #20]
 8004048:	2300      	movs	r3, #0
 800404a:	613b      	str	r3, [r7, #16]
  assert_param(IS_DAC_TRIGGER(sConfig->DAC_Trigger));
  assert_param(IS_DAC_OUTPUT_BUFFER_STATE(sConfig->DAC_OutputBuffer));
  assert_param(IS_DAC_CHANNEL(Channel));
  
  /* Process locked */
  __HAL_LOCK(hdac);
 800404c:	68fb      	ldr	r3, [r7, #12]
 800404e:	795b      	ldrb	r3, [r3, #5]
 8004050:	2b01      	cmp	r3, #1
 8004052:	d101      	bne.n	8004058 <HAL_DAC_ConfigChannel+0x20>
 8004054:	2302      	movs	r3, #2
 8004056:	e036      	b.n	80040c6 <HAL_DAC_ConfigChannel+0x8e>
 8004058:	68fb      	ldr	r3, [r7, #12]
 800405a:	2201      	movs	r2, #1
 800405c:	715a      	strb	r2, [r3, #5]
  
  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_BUSY;
 800405e:	68fb      	ldr	r3, [r7, #12]
 8004060:	2202      	movs	r2, #2
 8004062:	711a      	strb	r2, [r3, #4]
  
  /* Get the DAC CR value */
  tmpreg1 = hdac->Instance->CR;
 8004064:	68fb      	ldr	r3, [r7, #12]
 8004066:	681b      	ldr	r3, [r3, #0]
 8004068:	681b      	ldr	r3, [r3, #0]
 800406a:	617b      	str	r3, [r7, #20]
  /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
  tmpreg1 &= ~(((uint32_t)(DAC_CR_MAMP1 | DAC_CR_WAVE1 | DAC_CR_TSEL1 | DAC_CR_TEN1 | DAC_CR_BOFF1)) << Channel);
 800406c:	687b      	ldr	r3, [r7, #4]
 800406e:	f640 72fe 	movw	r2, #4094	; 0xffe
 8004072:	fa02 f303 	lsl.w	r3, r2, r3
 8004076:	43db      	mvns	r3, r3
 8004078:	697a      	ldr	r2, [r7, #20]
 800407a:	4013      	ands	r3, r2
 800407c:	617b      	str	r3, [r7, #20]
  /* Configure for the selected DAC channel: buffer output, trigger */
  /* Set TSELx and TENx bits according to DAC_Trigger value */
  /* Set BOFFx bit according to DAC_OutputBuffer value */   
  tmpreg2 = (sConfig->DAC_Trigger | sConfig->DAC_OutputBuffer);
 800407e:	68bb      	ldr	r3, [r7, #8]
 8004080:	681a      	ldr	r2, [r3, #0]
 8004082:	68bb      	ldr	r3, [r7, #8]
 8004084:	685b      	ldr	r3, [r3, #4]
 8004086:	4313      	orrs	r3, r2
 8004088:	613b      	str	r3, [r7, #16]
  /* Calculate CR register value depending on DAC_Channel */
  tmpreg1 |= tmpreg2 << Channel;
 800408a:	687b      	ldr	r3, [r7, #4]
 800408c:	693a      	ldr	r2, [r7, #16]
 800408e:	fa02 f303 	lsl.w	r3, r2, r3
 8004092:	697a      	ldr	r2, [r7, #20]
 8004094:	4313      	orrs	r3, r2
 8004096:	617b      	str	r3, [r7, #20]
  /* Write to DAC CR */
  hdac->Instance->CR = tmpreg1;
 8004098:	68fb      	ldr	r3, [r7, #12]
 800409a:	681b      	ldr	r3, [r3, #0]
 800409c:	697a      	ldr	r2, [r7, #20]
 800409e:	601a      	str	r2, [r3, #0]
  /* Disable wave generation */
  hdac->Instance->CR &= ~(DAC_CR_WAVE1 << Channel);
 80040a0:	68fb      	ldr	r3, [r7, #12]
 80040a2:	681b      	ldr	r3, [r3, #0]
 80040a4:	68fa      	ldr	r2, [r7, #12]
 80040a6:	6812      	ldr	r2, [r2, #0]
 80040a8:	6811      	ldr	r1, [r2, #0]
 80040aa:	687a      	ldr	r2, [r7, #4]
 80040ac:	20c0      	movs	r0, #192	; 0xc0
 80040ae:	fa00 f202 	lsl.w	r2, r0, r2
 80040b2:	43d2      	mvns	r2, r2
 80040b4:	400a      	ands	r2, r1
 80040b6:	601a      	str	r2, [r3, #0]
  
  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_READY;
 80040b8:	68fb      	ldr	r3, [r7, #12]
 80040ba:	2201      	movs	r2, #1
 80040bc:	711a      	strb	r2, [r3, #4]
  
  /* Process unlocked */
  __HAL_UNLOCK(hdac);
 80040be:	68fb      	ldr	r3, [r7, #12]
 80040c0:	2200      	movs	r2, #0
 80040c2:	715a      	strb	r2, [r3, #5]
  
  /* Return function status */
  return HAL_OK;
 80040c4:	2300      	movs	r3, #0
}
 80040c6:	4618      	mov	r0, r3
 80040c8:	371c      	adds	r7, #28
 80040ca:	46bd      	mov	sp, r7
 80040cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80040d0:	4770      	bx	lr
 80040d2:	bf00      	nop

080040d4 <HAL_DAC_SetValue>:
  *            @arg DAC_ALIGN_12B_R: 12bit right data alignment selected
  * @param  Data: Data to be loaded in the selected data holding register.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DAC_SetValue(DAC_HandleTypeDef* hdac, uint32_t Channel, uint32_t Alignment, uint32_t Data)
{  
 80040d4:	b480      	push	{r7}
 80040d6:	b087      	sub	sp, #28
 80040d8:	af00      	add	r7, sp, #0
 80040da:	60f8      	str	r0, [r7, #12]
 80040dc:	60b9      	str	r1, [r7, #8]
 80040de:	607a      	str	r2, [r7, #4]
 80040e0:	603b      	str	r3, [r7, #0]
  __IO uint32_t tmp = 0;
 80040e2:	2300      	movs	r3, #0
 80040e4:	617b      	str	r3, [r7, #20]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(Channel));
  assert_param(IS_DAC_ALIGN(Alignment));
  assert_param(IS_DAC_DATA(Data));
  
  tmp = (uint32_t)hdac->Instance; 
 80040e6:	68fb      	ldr	r3, [r7, #12]
 80040e8:	681b      	ldr	r3, [r3, #0]
 80040ea:	617b      	str	r3, [r7, #20]
  if(Channel == DAC_CHANNEL_1)
 80040ec:	68bb      	ldr	r3, [r7, #8]
 80040ee:	2b00      	cmp	r3, #0
 80040f0:	d105      	bne.n	80040fe <HAL_DAC_SetValue+0x2a>
  {
    tmp += DAC_DHR12R1_ALIGNMENT(Alignment);
 80040f2:	697a      	ldr	r2, [r7, #20]
 80040f4:	687b      	ldr	r3, [r7, #4]
 80040f6:	4413      	add	r3, r2
 80040f8:	3308      	adds	r3, #8
 80040fa:	617b      	str	r3, [r7, #20]
 80040fc:	e004      	b.n	8004108 <HAL_DAC_SetValue+0x34>
  }
  else
  {
    tmp += DAC_DHR12R2_ALIGNMENT(Alignment);
 80040fe:	697a      	ldr	r2, [r7, #20]
 8004100:	687b      	ldr	r3, [r7, #4]
 8004102:	4413      	add	r3, r2
 8004104:	3314      	adds	r3, #20
 8004106:	617b      	str	r3, [r7, #20]
  }

  /* Set the DAC channel1 selected data holding register */
  *(__IO uint32_t *) tmp = Data;
 8004108:	697b      	ldr	r3, [r7, #20]
 800410a:	683a      	ldr	r2, [r7, #0]
 800410c:	601a      	str	r2, [r3, #0]
  
  /* Return function status */
  return HAL_OK;
 800410e:	2300      	movs	r3, #0
}
 8004110:	4618      	mov	r0, r3
 8004112:	371c      	adds	r7, #28
 8004114:	46bd      	mov	sp, r7
 8004116:	f85d 7b04 	ldr.w	r7, [sp], #4
 800411a:	4770      	bx	lr

0800411c <HAL_DAC_GetState>:
  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval HAL state
  */
HAL_DAC_StateTypeDef HAL_DAC_GetState(DAC_HandleTypeDef* hdac)
{
 800411c:	b480      	push	{r7}
 800411e:	b083      	sub	sp, #12
 8004120:	af00      	add	r7, sp, #0
 8004122:	6078      	str	r0, [r7, #4]
  /* Return DAC state */
  return hdac->State;
 8004124:	687b      	ldr	r3, [r7, #4]
 8004126:	791b      	ldrb	r3, [r3, #4]
 8004128:	b2db      	uxtb	r3, r3
}
 800412a:	4618      	mov	r0, r3
 800412c:	370c      	adds	r7, #12
 800412e:	46bd      	mov	sp, r7
 8004130:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004134:	4770      	bx	lr
 8004136:	bf00      	nop

08004138 <HAL_DAC_GetError>:
  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval DAC Error Code
  */
uint32_t HAL_DAC_GetError(DAC_HandleTypeDef *hdac)
{
 8004138:	b480      	push	{r7}
 800413a:	b083      	sub	sp, #12
 800413c:	af00      	add	r7, sp, #0
 800413e:	6078      	str	r0, [r7, #4]
  return hdac->ErrorCode;
 8004140:	687b      	ldr	r3, [r7, #4]
 8004142:	691b      	ldr	r3, [r3, #16]
}
 8004144:	4618      	mov	r0, r3
 8004146:	370c      	adds	r7, #12
 8004148:	46bd      	mov	sp, r7
 800414a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800414e:	4770      	bx	lr

08004150 <DAC_DMAConvCpltCh1>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void DAC_DMAConvCpltCh1(DMA_HandleTypeDef *hdma)   
{
 8004150:	b580      	push	{r7, lr}
 8004152:	b084      	sub	sp, #16
 8004154:	af00      	add	r7, sp, #0
 8004156:	6078      	str	r0, [r7, #4]
  DAC_HandleTypeDef* hdac = ( DAC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8004158:	687b      	ldr	r3, [r7, #4]
 800415a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800415c:	60fb      	str	r3, [r7, #12]
  
  HAL_DAC_ConvCpltCallbackCh1(hdac); 
 800415e:	68f8      	ldr	r0, [r7, #12]
 8004160:	f7ff ff42 	bl	8003fe8 <HAL_DAC_ConvCpltCallbackCh1>
  
  hdac->State= HAL_DAC_STATE_READY;
 8004164:	68fb      	ldr	r3, [r7, #12]
 8004166:	2201      	movs	r2, #1
 8004168:	711a      	strb	r2, [r3, #4]
}
 800416a:	3710      	adds	r7, #16
 800416c:	46bd      	mov	sp, r7
 800416e:	bd80      	pop	{r7, pc}

08004170 <DAC_DMAHalfConvCpltCh1>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void DAC_DMAHalfConvCpltCh1(DMA_HandleTypeDef *hdma)   
{
 8004170:	b580      	push	{r7, lr}
 8004172:	b084      	sub	sp, #16
 8004174:	af00      	add	r7, sp, #0
 8004176:	6078      	str	r0, [r7, #4]
    DAC_HandleTypeDef* hdac = ( DAC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8004178:	687b      	ldr	r3, [r7, #4]
 800417a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800417c:	60fb      	str	r3, [r7, #12]
    /* Conversion complete callback */
    HAL_DAC_ConvHalfCpltCallbackCh1(hdac); 
 800417e:	68f8      	ldr	r0, [r7, #12]
 8004180:	f7ff ff3c 	bl	8003ffc <HAL_DAC_ConvHalfCpltCallbackCh1>
}
 8004184:	3710      	adds	r7, #16
 8004186:	46bd      	mov	sp, r7
 8004188:	bd80      	pop	{r7, pc}
 800418a:	bf00      	nop

0800418c <DAC_DMAErrorCh1>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void DAC_DMAErrorCh1(DMA_HandleTypeDef *hdma)   
{
 800418c:	b580      	push	{r7, lr}
 800418e:	b084      	sub	sp, #16
 8004190:	af00      	add	r7, sp, #0
 8004192:	6078      	str	r0, [r7, #4]
  DAC_HandleTypeDef* hdac = ( DAC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8004194:	687b      	ldr	r3, [r7, #4]
 8004196:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004198:	60fb      	str	r3, [r7, #12]
    
  /* Set DAC error code to DMA error */
  hdac->ErrorCode |= HAL_DAC_ERROR_DMA;
 800419a:	68fb      	ldr	r3, [r7, #12]
 800419c:	691b      	ldr	r3, [r3, #16]
 800419e:	f043 0204 	orr.w	r2, r3, #4
 80041a2:	68fb      	ldr	r3, [r7, #12]
 80041a4:	611a      	str	r2, [r3, #16]
    
  HAL_DAC_ErrorCallbackCh1(hdac); 
 80041a6:	68f8      	ldr	r0, [r7, #12]
 80041a8:	f7ff ff32 	bl	8004010 <HAL_DAC_ErrorCallbackCh1>
    
  hdac->State= HAL_DAC_STATE_READY;
 80041ac:	68fb      	ldr	r3, [r7, #12]
 80041ae:	2201      	movs	r2, #1
 80041b0:	711a      	strb	r2, [r3, #4]
}
 80041b2:	3710      	adds	r7, #16
 80041b4:	46bd      	mov	sp, r7
 80041b6:	bd80      	pop	{r7, pc}

080041b8 <HAL_DACEx_DualGetValue>:
  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval The selected DAC channel data output value.
  */
uint32_t HAL_DACEx_DualGetValue(DAC_HandleTypeDef* hdac)
{
 80041b8:	b480      	push	{r7}
 80041ba:	b085      	sub	sp, #20
 80041bc:	af00      	add	r7, sp, #0
 80041be:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0;
 80041c0:	2300      	movs	r3, #0
 80041c2:	60fb      	str	r3, [r7, #12]
  
  tmp |= hdac->Instance->DOR1;
 80041c4:	687b      	ldr	r3, [r7, #4]
 80041c6:	681b      	ldr	r3, [r3, #0]
 80041c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80041ca:	68fa      	ldr	r2, [r7, #12]
 80041cc:	4313      	orrs	r3, r2
 80041ce:	60fb      	str	r3, [r7, #12]
  
  tmp |= hdac->Instance->DOR2 << 16;
 80041d0:	687b      	ldr	r3, [r7, #4]
 80041d2:	681b      	ldr	r3, [r3, #0]
 80041d4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80041d6:	041b      	lsls	r3, r3, #16
 80041d8:	68fa      	ldr	r2, [r7, #12]
 80041da:	4313      	orrs	r3, r2
 80041dc:	60fb      	str	r3, [r7, #12]
  
  /* Returns the DAC channel data output register value */
  return tmp;
 80041de:	68fb      	ldr	r3, [r7, #12]
}
 80041e0:	4618      	mov	r0, r3
 80041e2:	3714      	adds	r7, #20
 80041e4:	46bd      	mov	sp, r7
 80041e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80041ea:	4770      	bx	lr

080041ec <HAL_DACEx_TriangleWaveGenerate>:
  *            @arg DAC_TRIANGLEAMPLITUDE_2047: Select max triangle amplitude of 2047
  *            @arg DAC_TRIANGLEAMPLITUDE_4095: Select max triangle amplitude of 4095                               
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DACEx_TriangleWaveGenerate(DAC_HandleTypeDef* hdac, uint32_t Channel, uint32_t Amplitude)
{  
 80041ec:	b480      	push	{r7}
 80041ee:	b085      	sub	sp, #20
 80041f0:	af00      	add	r7, sp, #0
 80041f2:	60f8      	str	r0, [r7, #12]
 80041f4:	60b9      	str	r1, [r7, #8]
 80041f6:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(Channel));
  assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(Amplitude));
  
  /* Process locked */
  __HAL_LOCK(hdac);
 80041f8:	68fb      	ldr	r3, [r7, #12]
 80041fa:	795b      	ldrb	r3, [r3, #5]
 80041fc:	2b01      	cmp	r3, #1
 80041fe:	d101      	bne.n	8004204 <HAL_DACEx_TriangleWaveGenerate+0x18>
 8004200:	2302      	movs	r3, #2
 8004202:	e020      	b.n	8004246 <HAL_DACEx_TriangleWaveGenerate+0x5a>
 8004204:	68fb      	ldr	r3, [r7, #12]
 8004206:	2201      	movs	r2, #1
 8004208:	715a      	strb	r2, [r3, #5]
  
  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_BUSY;
 800420a:	68fb      	ldr	r3, [r7, #12]
 800420c:	2202      	movs	r2, #2
 800420e:	711a      	strb	r2, [r3, #4]
  
  /* Enable the selected wave generation for the selected DAC channel */
  MODIFY_REG(hdac->Instance->CR, (DAC_CR_WAVE1 | DAC_CR_MAMP1) << Channel, (DAC_CR_WAVE1_1 | Amplitude) << Channel);
 8004210:	68fb      	ldr	r3, [r7, #12]
 8004212:	681b      	ldr	r3, [r3, #0]
 8004214:	68fa      	ldr	r2, [r7, #12]
 8004216:	6812      	ldr	r2, [r2, #0]
 8004218:	6811      	ldr	r1, [r2, #0]
 800421a:	68ba      	ldr	r2, [r7, #8]
 800421c:	f44f 607c 	mov.w	r0, #4032	; 0xfc0
 8004220:	fa00 f202 	lsl.w	r2, r0, r2
 8004224:	43d2      	mvns	r2, r2
 8004226:	4011      	ands	r1, r2
 8004228:	687a      	ldr	r2, [r7, #4]
 800422a:	f042 0080 	orr.w	r0, r2, #128	; 0x80
 800422e:	68ba      	ldr	r2, [r7, #8]
 8004230:	fa00 f202 	lsl.w	r2, r0, r2
 8004234:	430a      	orrs	r2, r1
 8004236:	601a      	str	r2, [r3, #0]
  
  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_READY;
 8004238:	68fb      	ldr	r3, [r7, #12]
 800423a:	2201      	movs	r2, #1
 800423c:	711a      	strb	r2, [r3, #4]
  
  /* Process unlocked */
  __HAL_UNLOCK(hdac);
 800423e:	68fb      	ldr	r3, [r7, #12]
 8004240:	2200      	movs	r2, #0
 8004242:	715a      	strb	r2, [r3, #5]
  
  /* Return function status */
  return HAL_OK;
 8004244:	2300      	movs	r3, #0
}
 8004246:	4618      	mov	r0, r3
 8004248:	3714      	adds	r7, #20
 800424a:	46bd      	mov	sp, r7
 800424c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004250:	4770      	bx	lr
 8004252:	bf00      	nop

08004254 <HAL_DACEx_NoiseWaveGenerate>:
  *            @arg DAC_LFSRUNMASK_BITS10_0: Unmask DAC channel LFSR bit[10:0] for noise wave generation 
  *            @arg DAC_LFSRUNMASK_BITS11_0: Unmask DAC channel LFSR bit[11:0] for noise wave generation 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DACEx_NoiseWaveGenerate(DAC_HandleTypeDef* hdac, uint32_t Channel, uint32_t Amplitude)
{  
 8004254:	b480      	push	{r7}
 8004256:	b085      	sub	sp, #20
 8004258:	af00      	add	r7, sp, #0
 800425a:	60f8      	str	r0, [r7, #12]
 800425c:	60b9      	str	r1, [r7, #8]
 800425e:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(Channel));
  assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(Amplitude));
  
  /* Process locked */
  __HAL_LOCK(hdac);
 8004260:	68fb      	ldr	r3, [r7, #12]
 8004262:	795b      	ldrb	r3, [r3, #5]
 8004264:	2b01      	cmp	r3, #1
 8004266:	d101      	bne.n	800426c <HAL_DACEx_NoiseWaveGenerate+0x18>
 8004268:	2302      	movs	r3, #2
 800426a:	e020      	b.n	80042ae <HAL_DACEx_NoiseWaveGenerate+0x5a>
 800426c:	68fb      	ldr	r3, [r7, #12]
 800426e:	2201      	movs	r2, #1
 8004270:	715a      	strb	r2, [r3, #5]
  
  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_BUSY;
 8004272:	68fb      	ldr	r3, [r7, #12]
 8004274:	2202      	movs	r2, #2
 8004276:	711a      	strb	r2, [r3, #4]
  
  /* Enable the selected wave generation for the selected DAC channel */
  MODIFY_REG(hdac->Instance->CR, (DAC_CR_WAVE1 | DAC_CR_MAMP1) << Channel, (DAC_CR_WAVE1_0 | Amplitude) << Channel);
 8004278:	68fb      	ldr	r3, [r7, #12]
 800427a:	681b      	ldr	r3, [r3, #0]
 800427c:	68fa      	ldr	r2, [r7, #12]
 800427e:	6812      	ldr	r2, [r2, #0]
 8004280:	6811      	ldr	r1, [r2, #0]
 8004282:	68ba      	ldr	r2, [r7, #8]
 8004284:	f44f 607c 	mov.w	r0, #4032	; 0xfc0
 8004288:	fa00 f202 	lsl.w	r2, r0, r2
 800428c:	43d2      	mvns	r2, r2
 800428e:	4011      	ands	r1, r2
 8004290:	687a      	ldr	r2, [r7, #4]
 8004292:	f042 0040 	orr.w	r0, r2, #64	; 0x40
 8004296:	68ba      	ldr	r2, [r7, #8]
 8004298:	fa00 f202 	lsl.w	r2, r0, r2
 800429c:	430a      	orrs	r2, r1
 800429e:	601a      	str	r2, [r3, #0]
  
  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_READY;
 80042a0:	68fb      	ldr	r3, [r7, #12]
 80042a2:	2201      	movs	r2, #1
 80042a4:	711a      	strb	r2, [r3, #4]
  
  /* Process unlocked */
  __HAL_UNLOCK(hdac);
 80042a6:	68fb      	ldr	r3, [r7, #12]
 80042a8:	2200      	movs	r2, #0
 80042aa:	715a      	strb	r2, [r3, #5]
  
  /* Return function status */
  return HAL_OK;
 80042ac:	2300      	movs	r3, #0
}
 80042ae:	4618      	mov	r0, r3
 80042b0:	3714      	adds	r7, #20
 80042b2:	46bd      	mov	sp, r7
 80042b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80042b8:	4770      	bx	lr
 80042ba:	bf00      	nop

080042bc <HAL_DACEx_DualSetValue>:
  * @note   In dual mode, a unique register access is required to write in both
  *          DAC channels at the same time.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DACEx_DualSetValue(DAC_HandleTypeDef* hdac, uint32_t Alignment, uint32_t Data1, uint32_t Data2)
{  
 80042bc:	b480      	push	{r7}
 80042be:	b087      	sub	sp, #28
 80042c0:	af00      	add	r7, sp, #0
 80042c2:	60f8      	str	r0, [r7, #12]
 80042c4:	60b9      	str	r1, [r7, #8]
 80042c6:	607a      	str	r2, [r7, #4]
 80042c8:	603b      	str	r3, [r7, #0]
  uint32_t data = 0, tmp = 0;
 80042ca:	2300      	movs	r3, #0
 80042cc:	617b      	str	r3, [r7, #20]
 80042ce:	2300      	movs	r3, #0
 80042d0:	613b      	str	r3, [r7, #16]
  assert_param(IS_DAC_ALIGN(Alignment));
  assert_param(IS_DAC_DATA(Data1));
  assert_param(IS_DAC_DATA(Data2));
  
  /* Calculate and set dual DAC data holding register value */
  if (Alignment == DAC_ALIGN_8B_R)
 80042d2:	68bb      	ldr	r3, [r7, #8]
 80042d4:	2b08      	cmp	r3, #8
 80042d6:	d105      	bne.n	80042e4 <HAL_DACEx_DualSetValue+0x28>
  {
    data = ((uint32_t)Data2 << 8) | Data1; 
 80042d8:	683b      	ldr	r3, [r7, #0]
 80042da:	021a      	lsls	r2, r3, #8
 80042dc:	687b      	ldr	r3, [r7, #4]
 80042de:	4313      	orrs	r3, r2
 80042e0:	617b      	str	r3, [r7, #20]
 80042e2:	e004      	b.n	80042ee <HAL_DACEx_DualSetValue+0x32>
  }
  else
  {
    data = ((uint32_t)Data2 << 16) | Data1;
 80042e4:	683b      	ldr	r3, [r7, #0]
 80042e6:	041a      	lsls	r2, r3, #16
 80042e8:	687b      	ldr	r3, [r7, #4]
 80042ea:	4313      	orrs	r3, r2
 80042ec:	617b      	str	r3, [r7, #20]
  }
  
  tmp = (uint32_t)hdac->Instance;
 80042ee:	68fb      	ldr	r3, [r7, #12]
 80042f0:	681b      	ldr	r3, [r3, #0]
 80042f2:	613b      	str	r3, [r7, #16]
  tmp += DAC_DHR12RD_ALIGNMENT(Alignment);
 80042f4:	68ba      	ldr	r2, [r7, #8]
 80042f6:	693b      	ldr	r3, [r7, #16]
 80042f8:	4413      	add	r3, r2
 80042fa:	3320      	adds	r3, #32
 80042fc:	613b      	str	r3, [r7, #16]

  /* Set the dual DAC selected data holding register */
  *(__IO uint32_t *)tmp = data;
 80042fe:	693b      	ldr	r3, [r7, #16]
 8004300:	697a      	ldr	r2, [r7, #20]
 8004302:	601a      	str	r2, [r3, #0]
  
  /* Return function status */
  return HAL_OK;
 8004304:	2300      	movs	r3, #0
}
 8004306:	4618      	mov	r0, r3
 8004308:	371c      	adds	r7, #28
 800430a:	46bd      	mov	sp, r7
 800430c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004310:	4770      	bx	lr
 8004312:	bf00      	nop

08004314 <HAL_DACEx_ConvCpltCallbackCh2>:
  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */
__weak void HAL_DACEx_ConvCpltCallbackCh2(DAC_HandleTypeDef* hdac)
{
 8004314:	b480      	push	{r7}
 8004316:	b083      	sub	sp, #12
 8004318:	af00      	add	r7, sp, #0
 800431a:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DAC_ConvCpltCallback could be implemented in the user file
   */
}
 800431c:	370c      	adds	r7, #12
 800431e:	46bd      	mov	sp, r7
 8004320:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004324:	4770      	bx	lr
 8004326:	bf00      	nop

08004328 <HAL_DACEx_ConvHalfCpltCallbackCh2>:
  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */
__weak void HAL_DACEx_ConvHalfCpltCallbackCh2(DAC_HandleTypeDef* hdac)
{
 8004328:	b480      	push	{r7}
 800432a:	b083      	sub	sp, #12
 800432c:	af00      	add	r7, sp, #0
 800432e:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DAC_ConvHalfCpltCallbackCh2 could be implemented in the user file
   */
}
 8004330:	370c      	adds	r7, #12
 8004332:	46bd      	mov	sp, r7
 8004334:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004338:	4770      	bx	lr
 800433a:	bf00      	nop

0800433c <HAL_DACEx_ErrorCallbackCh2>:
  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */
__weak void HAL_DACEx_ErrorCallbackCh2(DAC_HandleTypeDef *hdac)
{
 800433c:	b480      	push	{r7}
 800433e:	b083      	sub	sp, #12
 8004340:	af00      	add	r7, sp, #0
 8004342:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DAC_ErrorCallback could be implemented in the user file
   */
}
 8004344:	370c      	adds	r7, #12
 8004346:	46bd      	mov	sp, r7
 8004348:	f85d 7b04 	ldr.w	r7, [sp], #4
 800434c:	4770      	bx	lr
 800434e:	bf00      	nop

08004350 <HAL_DACEx_DMAUnderrunCallbackCh2>:
  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */
__weak void HAL_DACEx_DMAUnderrunCallbackCh2(DAC_HandleTypeDef *hdac)
{
 8004350:	b480      	push	{r7}
 8004352:	b083      	sub	sp, #12
 8004354:	af00      	add	r7, sp, #0
 8004356:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DAC_DMAUnderrunCallbackCh2 could be implemented in the user file
   */
}
 8004358:	370c      	adds	r7, #12
 800435a:	46bd      	mov	sp, r7
 800435c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004360:	4770      	bx	lr
 8004362:	bf00      	nop

08004364 <DAC_DMAConvCpltCh2>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
void DAC_DMAConvCpltCh2(DMA_HandleTypeDef *hdma)   
{
 8004364:	b580      	push	{r7, lr}
 8004366:	b084      	sub	sp, #16
 8004368:	af00      	add	r7, sp, #0
 800436a:	6078      	str	r0, [r7, #4]
  DAC_HandleTypeDef* hdac = ( DAC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800436c:	687b      	ldr	r3, [r7, #4]
 800436e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004370:	60fb      	str	r3, [r7, #12]
  
  HAL_DACEx_ConvCpltCallbackCh2(hdac); 
 8004372:	68f8      	ldr	r0, [r7, #12]
 8004374:	f7ff ffce 	bl	8004314 <HAL_DACEx_ConvCpltCallbackCh2>
  
  hdac->State= HAL_DAC_STATE_READY;
 8004378:	68fb      	ldr	r3, [r7, #12]
 800437a:	2201      	movs	r2, #1
 800437c:	711a      	strb	r2, [r3, #4]
}
 800437e:	3710      	adds	r7, #16
 8004380:	46bd      	mov	sp, r7
 8004382:	bd80      	pop	{r7, pc}

08004384 <DAC_DMAHalfConvCpltCh2>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
void DAC_DMAHalfConvCpltCh2(DMA_HandleTypeDef *hdma)   
{
 8004384:	b580      	push	{r7, lr}
 8004386:	b084      	sub	sp, #16
 8004388:	af00      	add	r7, sp, #0
 800438a:	6078      	str	r0, [r7, #4]
    DAC_HandleTypeDef* hdac = ( DAC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800438c:	687b      	ldr	r3, [r7, #4]
 800438e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004390:	60fb      	str	r3, [r7, #12]
    /* Conversion complete callback */
    HAL_DACEx_ConvHalfCpltCallbackCh2(hdac); 
 8004392:	68f8      	ldr	r0, [r7, #12]
 8004394:	f7ff ffc8 	bl	8004328 <HAL_DACEx_ConvHalfCpltCallbackCh2>
}
 8004398:	3710      	adds	r7, #16
 800439a:	46bd      	mov	sp, r7
 800439c:	bd80      	pop	{r7, pc}
 800439e:	bf00      	nop

080043a0 <DAC_DMAErrorCh2>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
void DAC_DMAErrorCh2(DMA_HandleTypeDef *hdma)   
{
 80043a0:	b580      	push	{r7, lr}
 80043a2:	b084      	sub	sp, #16
 80043a4:	af00      	add	r7, sp, #0
 80043a6:	6078      	str	r0, [r7, #4]
  DAC_HandleTypeDef* hdac = ( DAC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 80043a8:	687b      	ldr	r3, [r7, #4]
 80043aa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80043ac:	60fb      	str	r3, [r7, #12]
    
  /* Set DAC error code to DMA error */
  hdac->ErrorCode |= HAL_DAC_ERROR_DMA;
 80043ae:	68fb      	ldr	r3, [r7, #12]
 80043b0:	691b      	ldr	r3, [r3, #16]
 80043b2:	f043 0204 	orr.w	r2, r3, #4
 80043b6:	68fb      	ldr	r3, [r7, #12]
 80043b8:	611a      	str	r2, [r3, #16]
    
  HAL_DACEx_ErrorCallbackCh2(hdac); 
 80043ba:	68f8      	ldr	r0, [r7, #12]
 80043bc:	f7ff ffbe 	bl	800433c <HAL_DACEx_ErrorCallbackCh2>
    
  hdac->State= HAL_DAC_STATE_READY;
 80043c0:	68fb      	ldr	r3, [r7, #12]
 80043c2:	2201      	movs	r2, #1
 80043c4:	711a      	strb	r2, [r3, #4]
}
 80043c6:	3710      	adds	r7, #16
 80043c8:	46bd      	mov	sp, r7
 80043ca:	bd80      	pop	{r7, pc}

080043cc <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 80043cc:	b580      	push	{r7, lr}
 80043ce:	b084      	sub	sp, #16
 80043d0:	af00      	add	r7, sp, #0
 80043d2:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0;
 80043d4:	2300      	movs	r3, #0
 80043d6:	60fb      	str	r3, [r7, #12]

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 80043d8:	687b      	ldr	r3, [r7, #4]
 80043da:	2b00      	cmp	r3, #0
 80043dc:	d101      	bne.n	80043e2 <HAL_DMA_Init+0x16>
  {
    return HAL_ERROR;
 80043de:	2301      	movs	r3, #1
 80043e0:	e05d      	b.n	800449e <HAL_DMA_Init+0xd2>
    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
  }

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 80043e2:	687b      	ldr	r3, [r7, #4]
 80043e4:	2202      	movs	r2, #2
 80043e6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  /* Get the CR register value */
  tmp = hdma->Instance->CR;
 80043ea:	687b      	ldr	r3, [r7, #4]
 80043ec:	681b      	ldr	r3, [r3, #0]
 80043ee:	681b      	ldr	r3, [r3, #0]
 80043f0:	60fb      	str	r3, [r7, #12]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 80043f2:	68fa      	ldr	r2, [r7, #12]
 80043f4:	f248 033f 	movw	r3, #32831	; 0x803f
 80043f8:	f2cf 0310 	movt	r3, #61456	; 0xf010
 80043fc:	4013      	ands	r3, r2
 80043fe:	60fb      	str	r3, [r7, #12]
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8004400:	687b      	ldr	r3, [r7, #4]
 8004402:	685a      	ldr	r2, [r3, #4]
 8004404:	687b      	ldr	r3, [r7, #4]
 8004406:	689b      	ldr	r3, [r3, #8]
 8004408:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800440a:	687b      	ldr	r3, [r7, #4]
 800440c:	68db      	ldr	r3, [r3, #12]
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 800440e:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8004410:	687b      	ldr	r3, [r7, #4]
 8004412:	691b      	ldr	r3, [r3, #16]
 8004414:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8004416:	687b      	ldr	r3, [r7, #4]
 8004418:	695b      	ldr	r3, [r3, #20]
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800441a:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800441c:	687b      	ldr	r3, [r7, #4]
 800441e:	699b      	ldr	r3, [r3, #24]
 8004420:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 8004422:	687b      	ldr	r3, [r7, #4]
 8004424:	69db      	ldr	r3, [r3, #28]
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8004426:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 8004428:	687b      	ldr	r3, [r7, #4]
 800442a:	6a1b      	ldr	r3, [r3, #32]
 800442c:	4313      	orrs	r3, r2
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 800442e:	68fa      	ldr	r2, [r7, #12]
 8004430:	4313      	orrs	r3, r2
 8004432:	60fb      	str	r3, [r7, #12]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
          hdma->Init.Mode                | hdma->Init.Priority;

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8004434:	687b      	ldr	r3, [r7, #4]
 8004436:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004438:	2b04      	cmp	r3, #4
 800443a:	d107      	bne.n	800444c <HAL_DMA_Init+0x80>
  {
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 800443c:	687b      	ldr	r3, [r7, #4]
 800443e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8004440:	687b      	ldr	r3, [r7, #4]
 8004442:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004444:	4313      	orrs	r3, r2
 8004446:	68fa      	ldr	r2, [r7, #12]
 8004448:	4313      	orrs	r3, r2
 800444a:	60fb      	str	r3, [r7, #12]
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 800444c:	687b      	ldr	r3, [r7, #4]
 800444e:	681b      	ldr	r3, [r3, #0]
 8004450:	68fa      	ldr	r2, [r7, #12]
 8004452:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 8004454:	687b      	ldr	r3, [r7, #4]
 8004456:	681b      	ldr	r3, [r3, #0]
 8004458:	695b      	ldr	r3, [r3, #20]
 800445a:	60fb      	str	r3, [r7, #12]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 800445c:	68fb      	ldr	r3, [r7, #12]
 800445e:	f023 0307 	bic.w	r3, r3, #7
 8004462:	60fb      	str	r3, [r7, #12]

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 8004464:	687b      	ldr	r3, [r7, #4]
 8004466:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004468:	68fa      	ldr	r2, [r7, #12]
 800446a:	4313      	orrs	r3, r2
 800446c:	60fb      	str	r3, [r7, #12]

  /* the FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 800446e:	687b      	ldr	r3, [r7, #4]
 8004470:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004472:	2b04      	cmp	r3, #4
 8004474:	d104      	bne.n	8004480 <HAL_DMA_Init+0xb4>
  {
    /* Get the FIFO threshold */
    tmp |= hdma->Init.FIFOThreshold;
 8004476:	687b      	ldr	r3, [r7, #4]
 8004478:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800447a:	68fa      	ldr	r2, [r7, #12]
 800447c:	4313      	orrs	r3, r2
 800447e:	60fb      	str	r3, [r7, #12]
  }
  
  /* Write to DMA Stream FCR */
  hdma->Instance->FCR = tmp;
 8004480:	687b      	ldr	r3, [r7, #4]
 8004482:	681b      	ldr	r3, [r3, #0]
 8004484:	68fa      	ldr	r2, [r7, #12]
 8004486:	615a      	str	r2, [r3, #20]

  /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
     DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
  DMA_CalcBaseAndBitshift(hdma);
 8004488:	6878      	ldr	r0, [r7, #4]
 800448a:	f000 fbd5 	bl	8004c38 <DMA_CalcBaseAndBitshift>

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800448e:	687b      	ldr	r3, [r7, #4]
 8004490:	2200      	movs	r2, #0
 8004492:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 8004494:	687b      	ldr	r3, [r7, #4]
 8004496:	2201      	movs	r2, #1
 8004498:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
 800449c:	2300      	movs	r3, #0
}
 800449e:	4618      	mov	r0, r3
 80044a0:	3710      	adds	r7, #16
 80044a2:	46bd      	mov	sp, r7
 80044a4:	bd80      	pop	{r7, pc}
 80044a6:	bf00      	nop

080044a8 <HAL_DMA_DeInit>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
 80044a8:	b580      	push	{r7, lr}
 80044aa:	b084      	sub	sp, #16
 80044ac:	af00      	add	r7, sp, #0
 80044ae:	6078      	str	r0, [r7, #4]
  DMA_Base_Registers *regs;
  
  /* Check the DMA peripheral state */
  if(hdma == NULL)
 80044b0:	687b      	ldr	r3, [r7, #4]
 80044b2:	2b00      	cmp	r3, #0
 80044b4:	d101      	bne.n	80044ba <HAL_DMA_DeInit+0x12>
  {
    return HAL_ERROR;
 80044b6:	2301      	movs	r3, #1
 80044b8:	e040      	b.n	800453c <HAL_DMA_DeInit+0x94>
  }
  
  /* Check the DMA peripheral state */
  if(hdma->State == HAL_DMA_STATE_BUSY)
 80044ba:	687b      	ldr	r3, [r7, #4]
 80044bc:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 80044c0:	b2db      	uxtb	r3, r3
 80044c2:	2b02      	cmp	r3, #2
 80044c4:	d101      	bne.n	80044ca <HAL_DMA_DeInit+0x22>
  {
     return HAL_ERROR;
 80044c6:	2301      	movs	r3, #1
 80044c8:	e038      	b.n	800453c <HAL_DMA_DeInit+0x94>
  }

  /* Disable the selected DMA Streamx */
  __HAL_DMA_DISABLE(hdma);
 80044ca:	687b      	ldr	r3, [r7, #4]
 80044cc:	681b      	ldr	r3, [r3, #0]
 80044ce:	687a      	ldr	r2, [r7, #4]
 80044d0:	6812      	ldr	r2, [r2, #0]
 80044d2:	6812      	ldr	r2, [r2, #0]
 80044d4:	f022 0201 	bic.w	r2, r2, #1
 80044d8:	601a      	str	r2, [r3, #0]

  /* Reset DMA Streamx control register */
  hdma->Instance->CR   = 0;
 80044da:	687b      	ldr	r3, [r7, #4]
 80044dc:	681b      	ldr	r3, [r3, #0]
 80044de:	2200      	movs	r2, #0
 80044e0:	601a      	str	r2, [r3, #0]

  /* Reset DMA Streamx number of data to transfer register */
  hdma->Instance->NDTR = 0;
 80044e2:	687b      	ldr	r3, [r7, #4]
 80044e4:	681b      	ldr	r3, [r3, #0]
 80044e6:	2200      	movs	r2, #0
 80044e8:	605a      	str	r2, [r3, #4]

  /* Reset DMA Streamx peripheral address register */
  hdma->Instance->PAR  = 0;
 80044ea:	687b      	ldr	r3, [r7, #4]
 80044ec:	681b      	ldr	r3, [r3, #0]
 80044ee:	2200      	movs	r2, #0
 80044f0:	609a      	str	r2, [r3, #8]

  /* Reset DMA Streamx memory 0 address register */
  hdma->Instance->M0AR = 0;
 80044f2:	687b      	ldr	r3, [r7, #4]
 80044f4:	681b      	ldr	r3, [r3, #0]
 80044f6:	2200      	movs	r2, #0
 80044f8:	60da      	str	r2, [r3, #12]
  
  /* Reset DMA Streamx memory 1 address register */
  hdma->Instance->M1AR = 0;
 80044fa:	687b      	ldr	r3, [r7, #4]
 80044fc:	681b      	ldr	r3, [r3, #0]
 80044fe:	2200      	movs	r2, #0
 8004500:	611a      	str	r2, [r3, #16]
  
  /* Reset DMA Streamx FIFO control register */
  hdma->Instance->FCR  = (uint32_t)0x00000021;
 8004502:	687b      	ldr	r3, [r7, #4]
 8004504:	681b      	ldr	r3, [r3, #0]
 8004506:	2221      	movs	r2, #33	; 0x21
 8004508:	615a      	str	r2, [r3, #20]
  
  /* Get DMA steam Base Address */  
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 800450a:	6878      	ldr	r0, [r7, #4]
 800450c:	f000 fb94 	bl	8004c38 <DMA_CalcBaseAndBitshift>
 8004510:	4603      	mov	r3, r0
 8004512:	60fb      	str	r3, [r7, #12]
  
  /* Clear all interrupt flags at correct offset within the register */
  regs->IFCR = 0x3F << hdma->StreamIndex;
 8004514:	687b      	ldr	r3, [r7, #4]
 8004516:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004518:	223f      	movs	r2, #63	; 0x3f
 800451a:	fa02 f303 	lsl.w	r3, r2, r3
 800451e:	461a      	mov	r2, r3
 8004520:	68fb      	ldr	r3, [r7, #12]
 8004522:	609a      	str	r2, [r3, #8]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8004524:	687b      	ldr	r3, [r7, #4]
 8004526:	2200      	movs	r2, #0
 8004528:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;
 800452a:	687b      	ldr	r3, [r7, #4]
 800452c:	2200      	movs	r2, #0
 800452e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  /* Release Lock */
  __HAL_UNLOCK(hdma);
 8004532:	687b      	ldr	r3, [r7, #4]
 8004534:	2200      	movs	r2, #0
 8004536:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return HAL_OK;
 800453a:	2300      	movs	r3, #0
}
 800453c:	4618      	mov	r0, r3
 800453e:	3710      	adds	r7, #16
 8004540:	46bd      	mov	sp, r7
 8004542:	bd80      	pop	{r7, pc}

08004544 <HAL_DMA_Start>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8004544:	b580      	push	{r7, lr}
 8004546:	b084      	sub	sp, #16
 8004548:	af00      	add	r7, sp, #0
 800454a:	60f8      	str	r0, [r7, #12]
 800454c:	60b9      	str	r1, [r7, #8]
 800454e:	607a      	str	r2, [r7, #4]
 8004550:	603b      	str	r3, [r7, #0]
  /* Process locked */
  __HAL_LOCK(hdma);
 8004552:	68fb      	ldr	r3, [r7, #12]
 8004554:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8004558:	2b01      	cmp	r3, #1
 800455a:	d101      	bne.n	8004560 <HAL_DMA_Start+0x1c>
 800455c:	2302      	movs	r3, #2
 800455e:	e01e      	b.n	800459e <HAL_DMA_Start+0x5a>
 8004560:	68fb      	ldr	r3, [r7, #12]
 8004562:	2201      	movs	r2, #1
 8004564:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8004568:	68fb      	ldr	r3, [r7, #12]
 800456a:	2202      	movs	r2, #2
 800456c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

   /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 8004570:	68fb      	ldr	r3, [r7, #12]
 8004572:	681b      	ldr	r3, [r3, #0]
 8004574:	68fa      	ldr	r2, [r7, #12]
 8004576:	6812      	ldr	r2, [r2, #0]
 8004578:	6812      	ldr	r2, [r2, #0]
 800457a:	f022 0201 	bic.w	r2, r2, #1
 800457e:	601a      	str	r2, [r3, #0]

  /* Configure the source, destination address and the data length */
  DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 8004580:	68f8      	ldr	r0, [r7, #12]
 8004582:	68b9      	ldr	r1, [r7, #8]
 8004584:	687a      	ldr	r2, [r7, #4]
 8004586:	683b      	ldr	r3, [r7, #0]
 8004588:	f000 fb28 	bl	8004bdc <DMA_SetConfig>

  /* Enable the Peripheral */
  __HAL_DMA_ENABLE(hdma);
 800458c:	68fb      	ldr	r3, [r7, #12]
 800458e:	681b      	ldr	r3, [r3, #0]
 8004590:	68fa      	ldr	r2, [r7, #12]
 8004592:	6812      	ldr	r2, [r2, #0]
 8004594:	6812      	ldr	r2, [r2, #0]
 8004596:	f042 0201 	orr.w	r2, r2, #1
 800459a:	601a      	str	r2, [r3, #0]

  return HAL_OK; 
 800459c:	2300      	movs	r3, #0
}
 800459e:	4618      	mov	r0, r3
 80045a0:	3710      	adds	r7, #16
 80045a2:	46bd      	mov	sp, r7
 80045a4:	bd80      	pop	{r7, pc}
 80045a6:	bf00      	nop

080045a8 <HAL_DMA_Start_IT>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 80045a8:	b580      	push	{r7, lr}
 80045aa:	b084      	sub	sp, #16
 80045ac:	af00      	add	r7, sp, #0
 80045ae:	60f8      	str	r0, [r7, #12]
 80045b0:	60b9      	str	r1, [r7, #8]
 80045b2:	607a      	str	r2, [r7, #4]
 80045b4:	603b      	str	r3, [r7, #0]
  /* Process locked */
  __HAL_LOCK(hdma);
 80045b6:	68fb      	ldr	r3, [r7, #12]
 80045b8:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 80045bc:	2b01      	cmp	r3, #1
 80045be:	d101      	bne.n	80045c4 <HAL_DMA_Start_IT+0x1c>
 80045c0:	2302      	movs	r3, #2
 80045c2:	e02e      	b.n	8004622 <HAL_DMA_Start_IT+0x7a>
 80045c4:	68fb      	ldr	r3, [r7, #12]
 80045c6:	2201      	movs	r2, #1
 80045c8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 80045cc:	68fb      	ldr	r3, [r7, #12]
 80045ce:	2202      	movs	r2, #2
 80045d0:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

   /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 80045d4:	68fb      	ldr	r3, [r7, #12]
 80045d6:	681b      	ldr	r3, [r3, #0]
 80045d8:	68fa      	ldr	r2, [r7, #12]
 80045da:	6812      	ldr	r2, [r2, #0]
 80045dc:	6812      	ldr	r2, [r2, #0]
 80045de:	f022 0201 	bic.w	r2, r2, #1
 80045e2:	601a      	str	r2, [r3, #0]

  /* Configure the source, destination address and the data length */
  DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 80045e4:	68f8      	ldr	r0, [r7, #12]
 80045e6:	68b9      	ldr	r1, [r7, #8]
 80045e8:	687a      	ldr	r2, [r7, #4]
 80045ea:	683b      	ldr	r3, [r7, #0]
 80045ec:	f000 faf6 	bl	8004bdc <DMA_SetConfig>

  /* Enable all interrupts */
  hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_HT | DMA_IT_TE | DMA_IT_DME;
 80045f0:	68fb      	ldr	r3, [r7, #12]
 80045f2:	681b      	ldr	r3, [r3, #0]
 80045f4:	68fa      	ldr	r2, [r7, #12]
 80045f6:	6812      	ldr	r2, [r2, #0]
 80045f8:	6812      	ldr	r2, [r2, #0]
 80045fa:	f042 021e 	orr.w	r2, r2, #30
 80045fe:	601a      	str	r2, [r3, #0]
  hdma->Instance->FCR |= DMA_IT_FE;
 8004600:	68fb      	ldr	r3, [r7, #12]
 8004602:	681b      	ldr	r3, [r3, #0]
 8004604:	68fa      	ldr	r2, [r7, #12]
 8004606:	6812      	ldr	r2, [r2, #0]
 8004608:	6952      	ldr	r2, [r2, #20]
 800460a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800460e:	615a      	str	r2, [r3, #20]

   /* Enable the Peripheral */
  __HAL_DMA_ENABLE(hdma);
 8004610:	68fb      	ldr	r3, [r7, #12]
 8004612:	681b      	ldr	r3, [r3, #0]
 8004614:	68fa      	ldr	r2, [r7, #12]
 8004616:	6812      	ldr	r2, [r2, #0]
 8004618:	6812      	ldr	r2, [r2, #0]
 800461a:	f042 0201 	orr.w	r2, r2, #1
 800461e:	601a      	str	r2, [r3, #0]

  return HAL_OK;
 8004620:	2300      	movs	r3, #0
} 
 8004622:	4618      	mov	r0, r3
 8004624:	3710      	adds	r7, #16
 8004626:	46bd      	mov	sp, r7
 8004628:	bd80      	pop	{r7, pc}
 800462a:	bf00      	nop

0800462c <HAL_DMA_Abort>:
  *        and the Stream will be effectively disabled only after the transfer of
  *        this single data is finished.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
 800462c:	b580      	push	{r7, lr}
 800462e:	b084      	sub	sp, #16
 8004630:	af00      	add	r7, sp, #0
 8004632:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0;
 8004634:	2300      	movs	r3, #0
 8004636:	60fb      	str	r3, [r7, #12]

  /* Disable the stream */
  __HAL_DMA_DISABLE(hdma);
 8004638:	687b      	ldr	r3, [r7, #4]
 800463a:	681b      	ldr	r3, [r3, #0]
 800463c:	687a      	ldr	r2, [r7, #4]
 800463e:	6812      	ldr	r2, [r2, #0]
 8004640:	6812      	ldr	r2, [r2, #0]
 8004642:	f022 0201 	bic.w	r2, r2, #1
 8004646:	601a      	str	r2, [r3, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8004648:	f7fd f9be 	bl	80019c8 <HAL_GetTick>
 800464c:	60f8      	str	r0, [r7, #12]

  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != 0)
 800464e:	e017      	b.n	8004680 <HAL_DMA_Abort+0x54>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8004650:	f7fd f9ba 	bl	80019c8 <HAL_GetTick>
 8004654:	4602      	mov	r2, r0
 8004656:	68fb      	ldr	r3, [r7, #12]
 8004658:	1ad3      	subs	r3, r2, r3
 800465a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800465e:	d90f      	bls.n	8004680 <HAL_DMA_Abort+0x54>
    {
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
 8004660:	687b      	ldr	r3, [r7, #4]
 8004662:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004664:	f043 0220 	orr.w	r2, r3, #32
 8004668:	687b      	ldr	r3, [r7, #4]
 800466a:	64da      	str	r2, [r3, #76]	; 0x4c
      
      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 800466c:	687b      	ldr	r3, [r7, #4]
 800466e:	2200      	movs	r2, #0
 8004670:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
      
      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 8004674:	687b      	ldr	r3, [r7, #4]
 8004676:	2203      	movs	r2, #3
 8004678:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
      
      return HAL_TIMEOUT;
 800467c:	2303      	movs	r3, #3
 800467e:	e00f      	b.n	80046a0 <HAL_DMA_Abort+0x74>

  /* Get tick */
  tickstart = HAL_GetTick();

  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != 0)
 8004680:	687b      	ldr	r3, [r7, #4]
 8004682:	681b      	ldr	r3, [r3, #0]
 8004684:	681b      	ldr	r3, [r3, #0]
 8004686:	f003 0301 	and.w	r3, r3, #1
 800468a:	2b00      	cmp	r3, #0
 800468c:	d1e0      	bne.n	8004650 <HAL_DMA_Abort+0x24>
      
      return HAL_TIMEOUT;
    }
  }
  /* Process Unlocked */
  __HAL_UNLOCK(hdma);
 800468e:	687b      	ldr	r3, [r7, #4]
 8004690:	2200      	movs	r2, #0
 8004692:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  /* Change the DMA state*/
  hdma->State = HAL_DMA_STATE_READY;
 8004696:	687b      	ldr	r3, [r7, #4]
 8004698:	2201      	movs	r2, #1
 800469a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
 800469e:	2300      	movs	r3, #0
}
 80046a0:	4618      	mov	r0, r3
 80046a2:	3710      	adds	r7, #16
 80046a4:	46bd      	mov	sp, r7
 80046a6:	bd80      	pop	{r7, pc}

080046a8 <HAL_DMA_PollForTransfer>:
  * @param  CompleteLevel: Specifies the DMA level complete.  
  * @param  Timeout:       Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, uint32_t CompleteLevel, uint32_t Timeout)
{
 80046a8:	b580      	push	{r7, lr}
 80046aa:	b08a      	sub	sp, #40	; 0x28
 80046ac:	af00      	add	r7, sp, #0
 80046ae:	60f8      	str	r0, [r7, #12]
 80046b0:	60b9      	str	r1, [r7, #8]
 80046b2:	607a      	str	r2, [r7, #4]
  uint32_t temp, tmp, tmp1, tmp2;
  uint32_t tickstart = 0;
 80046b4:	2300      	movs	r3, #0
 80046b6:	623b      	str	r3, [r7, #32]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs;
  
  regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 80046b8:	68fb      	ldr	r3, [r7, #12]
 80046ba:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80046bc:	61fb      	str	r3, [r7, #28]

  /* Get the level transfer complete flag */
  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
 80046be:	68bb      	ldr	r3, [r7, #8]
 80046c0:	2b00      	cmp	r3, #0
 80046c2:	d106      	bne.n	80046d2 <HAL_DMA_PollForTransfer+0x2a>
  {
    /* Transfer Complete flag */
    temp = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 80046c4:	68fb      	ldr	r3, [r7, #12]
 80046c6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80046c8:	2220      	movs	r2, #32
 80046ca:	fa02 f303 	lsl.w	r3, r2, r3
 80046ce:	627b      	str	r3, [r7, #36]	; 0x24
 80046d0:	e005      	b.n	80046de <HAL_DMA_PollForTransfer+0x36>
  }
  else
  {
    /* Half Transfer Complete flag */
    temp = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 80046d2:	68fb      	ldr	r3, [r7, #12]
 80046d4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80046d6:	2210      	movs	r2, #16
 80046d8:	fa02 f303 	lsl.w	r3, r2, r3
 80046dc:	627b      	str	r3, [r7, #36]	; 0x24
  }

  /* Get tick */
  tickstart = HAL_GetTick();
 80046de:	f7fd f973 	bl	80019c8 <HAL_GetTick>
 80046e2:	6238      	str	r0, [r7, #32]

  while((regs->ISR & temp) == RESET)
 80046e4:	e085      	b.n	80047f2 <HAL_DMA_PollForTransfer+0x14a>
  {
    tmp  = regs->ISR & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex);
 80046e6:	69fb      	ldr	r3, [r7, #28]
 80046e8:	681a      	ldr	r2, [r3, #0]
 80046ea:	68fb      	ldr	r3, [r7, #12]
 80046ec:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80046ee:	2108      	movs	r1, #8
 80046f0:	fa01 f303 	lsl.w	r3, r1, r3
 80046f4:	4013      	ands	r3, r2
 80046f6:	61bb      	str	r3, [r7, #24]
    tmp1 = regs->ISR & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex);
 80046f8:	69fb      	ldr	r3, [r7, #28]
 80046fa:	681a      	ldr	r2, [r3, #0]
 80046fc:	68fb      	ldr	r3, [r7, #12]
 80046fe:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004700:	4619      	mov	r1, r3
 8004702:	2301      	movs	r3, #1
 8004704:	f2c0 0380 	movt	r3, #128	; 0x80
 8004708:	408b      	lsls	r3, r1
 800470a:	4013      	ands	r3, r2
 800470c:	617b      	str	r3, [r7, #20]
    tmp2 = regs->ISR & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex);
 800470e:	69fb      	ldr	r3, [r7, #28]
 8004710:	681a      	ldr	r2, [r3, #0]
 8004712:	68fb      	ldr	r3, [r7, #12]
 8004714:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004716:	4619      	mov	r1, r3
 8004718:	2304      	movs	r3, #4
 800471a:	f2c0 0380 	movt	r3, #128	; 0x80
 800471e:	408b      	lsls	r3, r1
 8004720:	4013      	ands	r3, r2
 8004722:	613b      	str	r3, [r7, #16]
    if((tmp != RESET) || (tmp1 != RESET) || (tmp2 != RESET))
 8004724:	69bb      	ldr	r3, [r7, #24]
 8004726:	2b00      	cmp	r3, #0
 8004728:	d105      	bne.n	8004736 <HAL_DMA_PollForTransfer+0x8e>
 800472a:	697b      	ldr	r3, [r7, #20]
 800472c:	2b00      	cmp	r3, #0
 800472e:	d102      	bne.n	8004736 <HAL_DMA_PollForTransfer+0x8e>
 8004730:	693b      	ldr	r3, [r7, #16]
 8004732:	2b00      	cmp	r3, #0
 8004734:	d03e      	beq.n	80047b4 <HAL_DMA_PollForTransfer+0x10c>
    {
      if(tmp != RESET)
 8004736:	69bb      	ldr	r3, [r7, #24]
 8004738:	2b00      	cmp	r3, #0
 800473a:	d00b      	beq.n	8004754 <HAL_DMA_PollForTransfer+0xac>
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 800473c:	68fb      	ldr	r3, [r7, #12]
 800473e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004740:	f043 0201 	orr.w	r2, r3, #1
 8004744:	68fb      	ldr	r3, [r7, #12]
 8004746:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Clear the transfer error flag */
        regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 8004748:	68fb      	ldr	r3, [r7, #12]
 800474a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800474c:	2208      	movs	r2, #8
 800474e:	409a      	lsls	r2, r3
 8004750:	69fb      	ldr	r3, [r7, #28]
 8004752:	609a      	str	r2, [r3, #8]
      }
      if(tmp1 != RESET)
 8004754:	697b      	ldr	r3, [r7, #20]
 8004756:	2b00      	cmp	r3, #0
 8004758:	d00f      	beq.n	800477a <HAL_DMA_PollForTransfer+0xd2>
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 800475a:	68fb      	ldr	r3, [r7, #12]
 800475c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800475e:	f043 0202 	orr.w	r2, r3, #2
 8004762:	68fb      	ldr	r3, [r7, #12]
 8004764:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Clear the FIFO error flag */
        regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 8004766:	68fb      	ldr	r3, [r7, #12]
 8004768:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800476a:	461a      	mov	r2, r3
 800476c:	2301      	movs	r3, #1
 800476e:	f2c0 0380 	movt	r3, #128	; 0x80
 8004772:	fa03 f202 	lsl.w	r2, r3, r2
 8004776:	69fb      	ldr	r3, [r7, #28]
 8004778:	609a      	str	r2, [r3, #8]
      }
      if(tmp2 != RESET)
 800477a:	693b      	ldr	r3, [r7, #16]
 800477c:	2b00      	cmp	r3, #0
 800477e:	d00f      	beq.n	80047a0 <HAL_DMA_PollForTransfer+0xf8>
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8004780:	68fb      	ldr	r3, [r7, #12]
 8004782:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004784:	f043 0204 	orr.w	r2, r3, #4
 8004788:	68fb      	ldr	r3, [r7, #12]
 800478a:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Clear the Direct Mode error flag */
        regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 800478c:	68fb      	ldr	r3, [r7, #12]
 800478e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004790:	461a      	mov	r2, r3
 8004792:	2304      	movs	r3, #4
 8004794:	f2c0 0380 	movt	r3, #128	; 0x80
 8004798:	fa03 f202 	lsl.w	r2, r3, r2
 800479c:	69fb      	ldr	r3, [r7, #28]
 800479e:	609a      	str	r2, [r3, #8]
      }
      /* Change the DMA state */
      hdma->State= HAL_DMA_STATE_ERROR;
 80047a0:	68fb      	ldr	r3, [r7, #12]
 80047a2:	2204      	movs	r2, #4
 80047a4:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 80047a8:	68fb      	ldr	r3, [r7, #12]
 80047aa:	2200      	movs	r2, #0
 80047ac:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      return HAL_ERROR;
 80047b0:	2301      	movs	r3, #1
 80047b2:	e080      	b.n	80048b6 <HAL_DMA_PollForTransfer+0x20e>
    }
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 80047b4:	687b      	ldr	r3, [r7, #4]
 80047b6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80047ba:	d01a      	beq.n	80047f2 <HAL_DMA_PollForTransfer+0x14a>
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 80047bc:	687b      	ldr	r3, [r7, #4]
 80047be:	2b00      	cmp	r3, #0
 80047c0:	d007      	beq.n	80047d2 <HAL_DMA_PollForTransfer+0x12a>
 80047c2:	f7fd f901 	bl	80019c8 <HAL_GetTick>
 80047c6:	4602      	mov	r2, r0
 80047c8:	6a3b      	ldr	r3, [r7, #32]
 80047ca:	1ad2      	subs	r2, r2, r3
 80047cc:	687b      	ldr	r3, [r7, #4]
 80047ce:	429a      	cmp	r2, r3
 80047d0:	d90f      	bls.n	80047f2 <HAL_DMA_PollForTransfer+0x14a>
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
 80047d2:	68fb      	ldr	r3, [r7, #12]
 80047d4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80047d6:	f043 0220 	orr.w	r2, r3, #32
 80047da:	68fb      	ldr	r3, [r7, #12]
 80047dc:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_TIMEOUT;
 80047de:	68fb      	ldr	r3, [r7, #12]
 80047e0:	2203      	movs	r2, #3
 80047e2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 80047e6:	68fb      	ldr	r3, [r7, #12]
 80047e8:	2200      	movs	r2, #0
 80047ea:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        return HAL_TIMEOUT;
 80047ee:	2303      	movs	r3, #3
 80047f0:	e061      	b.n	80048b6 <HAL_DMA_PollForTransfer+0x20e>
  }

  /* Get tick */
  tickstart = HAL_GetTick();

  while((regs->ISR & temp) == RESET)
 80047f2:	69fb      	ldr	r3, [r7, #28]
 80047f4:	681a      	ldr	r2, [r3, #0]
 80047f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80047f8:	4013      	ands	r3, r2
 80047fa:	2b00      	cmp	r3, #0
 80047fc:	f43f af73 	beq.w	80046e6 <HAL_DMA_PollForTransfer+0x3e>
        return HAL_TIMEOUT;
      }
    }
  }

  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
 8004800:	68bb      	ldr	r3, [r7, #8]
 8004802:	2b00      	cmp	r3, #0
 8004804:	d12d      	bne.n	8004862 <HAL_DMA_PollForTransfer+0x1ba>
  {
    /* Clear the half transfer and transfer complete flags */
    regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
 8004806:	68fb      	ldr	r3, [r7, #12]
 8004808:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800480a:	2230      	movs	r2, #48	; 0x30
 800480c:	409a      	lsls	r2, r3
 800480e:	69fb      	ldr	r3, [r7, #28]
 8004810:	609a      	str	r2, [r3, #8]

    /* Multi_Buffering mode enabled */
    if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
 8004812:	68fb      	ldr	r3, [r7, #12]
 8004814:	681b      	ldr	r3, [r3, #0]
 8004816:	681b      	ldr	r3, [r3, #0]
 8004818:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800481c:	2b00      	cmp	r3, #0
 800481e:	d017      	beq.n	8004850 <HAL_DMA_PollForTransfer+0x1a8>
    {
      /* Current memory buffer used is Memory 0 */
      if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
 8004820:	68fb      	ldr	r3, [r7, #12]
 8004822:	681b      	ldr	r3, [r3, #0]
 8004824:	681b      	ldr	r3, [r3, #0]
 8004826:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800482a:	2b00      	cmp	r3, #0
 800482c:	d104      	bne.n	8004838 <HAL_DMA_PollForTransfer+0x190>
      {
        /* Change DMA peripheral state */
        hdma->State = HAL_DMA_STATE_READY_MEM0;
 800482e:	68fb      	ldr	r3, [r7, #12]
 8004830:	2211      	movs	r2, #17
 8004832:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 8004836:	e00f      	b.n	8004858 <HAL_DMA_PollForTransfer+0x1b0>
      }
      /* Current memory buffer used is Memory 1 */
      else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
 8004838:	68fb      	ldr	r3, [r7, #12]
 800483a:	681b      	ldr	r3, [r3, #0]
 800483c:	681b      	ldr	r3, [r3, #0]
 800483e:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8004842:	2b00      	cmp	r3, #0
 8004844:	d008      	beq.n	8004858 <HAL_DMA_PollForTransfer+0x1b0>
      {
        /* Change DMA peripheral state */
        hdma->State = HAL_DMA_STATE_READY_MEM1;
 8004846:	68fb      	ldr	r3, [r7, #12]
 8004848:	2221      	movs	r2, #33	; 0x21
 800484a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 800484e:	e003      	b.n	8004858 <HAL_DMA_PollForTransfer+0x1b0>
    }
    else
    {
      /* The selected Streamx EN bit is cleared (DMA is disabled and all transfers
         are complete) */
      hdma->State = HAL_DMA_STATE_READY_MEM0;
 8004850:	68fb      	ldr	r3, [r7, #12]
 8004852:	2211      	movs	r2, #17
 8004854:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    }
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8004858:	68fb      	ldr	r3, [r7, #12]
 800485a:	2200      	movs	r2, #0
 800485c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
 8004860:	e028      	b.n	80048b4 <HAL_DMA_PollForTransfer+0x20c>
  }
  else
  {
    /* Clear the half transfer complete flag */
    regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 8004862:	68fb      	ldr	r3, [r7, #12]
 8004864:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004866:	2210      	movs	r2, #16
 8004868:	409a      	lsls	r2, r3
 800486a:	69fb      	ldr	r3, [r7, #28]
 800486c:	609a      	str	r2, [r3, #8]

    /* Multi_Buffering mode enabled */
    if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
 800486e:	68fb      	ldr	r3, [r7, #12]
 8004870:	681b      	ldr	r3, [r3, #0]
 8004872:	681b      	ldr	r3, [r3, #0]
 8004874:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8004878:	2b00      	cmp	r3, #0
 800487a:	d017      	beq.n	80048ac <HAL_DMA_PollForTransfer+0x204>
    {
      /* Current memory buffer used is Memory 0 */
      if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
 800487c:	68fb      	ldr	r3, [r7, #12]
 800487e:	681b      	ldr	r3, [r3, #0]
 8004880:	681b      	ldr	r3, [r3, #0]
 8004882:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8004886:	2b00      	cmp	r3, #0
 8004888:	d104      	bne.n	8004894 <HAL_DMA_PollForTransfer+0x1ec>
      {
        /* Change DMA peripheral state */
        hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
 800488a:	68fb      	ldr	r3, [r7, #12]
 800488c:	2231      	movs	r2, #49	; 0x31
 800488e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 8004892:	e00f      	b.n	80048b4 <HAL_DMA_PollForTransfer+0x20c>
      }
      /* Current memory buffer used is Memory 1 */
      else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
 8004894:	68fb      	ldr	r3, [r7, #12]
 8004896:	681b      	ldr	r3, [r3, #0]
 8004898:	681b      	ldr	r3, [r3, #0]
 800489a:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800489e:	2b00      	cmp	r3, #0
 80048a0:	d008      	beq.n	80048b4 <HAL_DMA_PollForTransfer+0x20c>
      {
        /* Change DMA peripheral state */
        hdma->State = HAL_DMA_STATE_READY_HALF_MEM1;
 80048a2:	68fb      	ldr	r3, [r7, #12]
 80048a4:	2241      	movs	r2, #65	; 0x41
 80048a6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 80048aa:	e003      	b.n	80048b4 <HAL_DMA_PollForTransfer+0x20c>
      }
    }
    else
    {
      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
 80048ac:	68fb      	ldr	r3, [r7, #12]
 80048ae:	2231      	movs	r2, #49	; 0x31
 80048b0:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    }
  }
  return HAL_OK;
 80048b4:	2300      	movs	r3, #0
}
 80048b6:	4618      	mov	r0, r3
 80048b8:	3728      	adds	r7, #40	; 0x28
 80048ba:	46bd      	mov	sp, r7
 80048bc:	bd80      	pop	{r7, pc}
 80048be:	bf00      	nop

080048c0 <HAL_DMA_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 80048c0:	b580      	push	{r7, lr}
 80048c2:	b084      	sub	sp, #16
 80048c4:	af00      	add	r7, sp, #0
 80048c6:	6078      	str	r0, [r7, #4]
  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs;

  regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 80048c8:	687b      	ldr	r3, [r7, #4]
 80048ca:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80048cc:	60fb      	str	r3, [r7, #12]

  /* Transfer Error Interrupt management ***************************************/
  if ((regs->ISR & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 80048ce:	68fb      	ldr	r3, [r7, #12]
 80048d0:	681a      	ldr	r2, [r3, #0]
 80048d2:	687b      	ldr	r3, [r7, #4]
 80048d4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80048d6:	2108      	movs	r1, #8
 80048d8:	fa01 f303 	lsl.w	r3, r1, r3
 80048dc:	4013      	ands	r3, r2
 80048de:	2b00      	cmp	r3, #0
 80048e0:	d02a      	beq.n	8004938 <HAL_DMA_IRQHandler+0x78>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 80048e2:	687b      	ldr	r3, [r7, #4]
 80048e4:	681b      	ldr	r3, [r3, #0]
 80048e6:	681b      	ldr	r3, [r3, #0]
 80048e8:	f003 0304 	and.w	r3, r3, #4
 80048ec:	2b00      	cmp	r3, #0
 80048ee:	d023      	beq.n	8004938 <HAL_DMA_IRQHandler+0x78>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
 80048f0:	687b      	ldr	r3, [r7, #4]
 80048f2:	681b      	ldr	r3, [r3, #0]
 80048f4:	687a      	ldr	r2, [r7, #4]
 80048f6:	6812      	ldr	r2, [r2, #0]
 80048f8:	6812      	ldr	r2, [r2, #0]
 80048fa:	f022 0204 	bic.w	r2, r2, #4
 80048fe:	601a      	str	r2, [r3, #0]

      /* Clear the transfer error flag */
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 8004900:	687b      	ldr	r3, [r7, #4]
 8004902:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004904:	2208      	movs	r2, #8
 8004906:	409a      	lsls	r2, r3
 8004908:	68fb      	ldr	r3, [r7, #12]
 800490a:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 800490c:	687b      	ldr	r3, [r7, #4]
 800490e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004910:	f043 0201 	orr.w	r2, r3, #1
 8004914:	687b      	ldr	r3, [r7, #4]
 8004916:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
 8004918:	687b      	ldr	r3, [r7, #4]
 800491a:	2204      	movs	r2, #4
 800491c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 8004920:	687b      	ldr	r3, [r7, #4]
 8004922:	2200      	movs	r2, #0
 8004924:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      if(hdma->XferErrorCallback != NULL)
 8004928:	687b      	ldr	r3, [r7, #4]
 800492a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800492c:	2b00      	cmp	r3, #0
 800492e:	d003      	beq.n	8004938 <HAL_DMA_IRQHandler+0x78>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 8004930:	687b      	ldr	r3, [r7, #4]
 8004932:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8004934:	6878      	ldr	r0, [r7, #4]
 8004936:	4798      	blx	r3
      }
    }
  }
  /* FIFO Error Interrupt management ******************************************/
  if ((regs->ISR & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 8004938:	68fb      	ldr	r3, [r7, #12]
 800493a:	681a      	ldr	r2, [r3, #0]
 800493c:	687b      	ldr	r3, [r7, #4]
 800493e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004940:	4619      	mov	r1, r3
 8004942:	2301      	movs	r3, #1
 8004944:	f2c0 0380 	movt	r3, #128	; 0x80
 8004948:	408b      	lsls	r3, r1
 800494a:	4013      	ands	r3, r2
 800494c:	2b00      	cmp	r3, #0
 800494e:	d02e      	beq.n	80049ae <HAL_DMA_IRQHandler+0xee>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 8004950:	687b      	ldr	r3, [r7, #4]
 8004952:	681b      	ldr	r3, [r3, #0]
 8004954:	695b      	ldr	r3, [r3, #20]
 8004956:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800495a:	2b00      	cmp	r3, #0
 800495c:	d027      	beq.n	80049ae <HAL_DMA_IRQHandler+0xee>
    {
      /* Disable the FIFO Error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_FE);
 800495e:	687b      	ldr	r3, [r7, #4]
 8004960:	681b      	ldr	r3, [r3, #0]
 8004962:	687a      	ldr	r2, [r7, #4]
 8004964:	6812      	ldr	r2, [r2, #0]
 8004966:	6952      	ldr	r2, [r2, #20]
 8004968:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800496c:	615a      	str	r2, [r3, #20]

      /* Clear the FIFO error flag */
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 800496e:	687b      	ldr	r3, [r7, #4]
 8004970:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004972:	461a      	mov	r2, r3
 8004974:	2301      	movs	r3, #1
 8004976:	f2c0 0380 	movt	r3, #128	; 0x80
 800497a:	fa03 f202 	lsl.w	r2, r3, r2
 800497e:	68fb      	ldr	r3, [r7, #12]
 8004980:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 8004982:	687b      	ldr	r3, [r7, #4]
 8004984:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004986:	f043 0202 	orr.w	r2, r3, #2
 800498a:	687b      	ldr	r3, [r7, #4]
 800498c:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
 800498e:	687b      	ldr	r3, [r7, #4]
 8004990:	2204      	movs	r2, #4
 8004992:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 8004996:	687b      	ldr	r3, [r7, #4]
 8004998:	2200      	movs	r2, #0
 800499a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      if(hdma->XferErrorCallback != NULL)
 800499e:	687b      	ldr	r3, [r7, #4]
 80049a0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80049a2:	2b00      	cmp	r3, #0
 80049a4:	d003      	beq.n	80049ae <HAL_DMA_IRQHandler+0xee>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 80049a6:	687b      	ldr	r3, [r7, #4]
 80049a8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80049aa:	6878      	ldr	r0, [r7, #4]
 80049ac:	4798      	blx	r3
      }
    }
  }
  /* Direct Mode Error Interrupt management ***********************************/
  if ((regs->ISR & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 80049ae:	68fb      	ldr	r3, [r7, #12]
 80049b0:	681a      	ldr	r2, [r3, #0]
 80049b2:	687b      	ldr	r3, [r7, #4]
 80049b4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80049b6:	4619      	mov	r1, r3
 80049b8:	2304      	movs	r3, #4
 80049ba:	f2c0 0380 	movt	r3, #128	; 0x80
 80049be:	408b      	lsls	r3, r1
 80049c0:	4013      	ands	r3, r2
 80049c2:	2b00      	cmp	r3, #0
 80049c4:	d02e      	beq.n	8004a24 <HAL_DMA_IRQHandler+0x164>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 80049c6:	687b      	ldr	r3, [r7, #4]
 80049c8:	681b      	ldr	r3, [r3, #0]
 80049ca:	681b      	ldr	r3, [r3, #0]
 80049cc:	f003 0302 	and.w	r3, r3, #2
 80049d0:	2b00      	cmp	r3, #0
 80049d2:	d027      	beq.n	8004a24 <HAL_DMA_IRQHandler+0x164>
    {
      /* Disable the direct mode Error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_DME);
 80049d4:	687b      	ldr	r3, [r7, #4]
 80049d6:	681b      	ldr	r3, [r3, #0]
 80049d8:	687a      	ldr	r2, [r7, #4]
 80049da:	6812      	ldr	r2, [r2, #0]
 80049dc:	6812      	ldr	r2, [r2, #0]
 80049de:	f022 0202 	bic.w	r2, r2, #2
 80049e2:	601a      	str	r2, [r3, #0]

      /* Clear the direct mode error flag */
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 80049e4:	687b      	ldr	r3, [r7, #4]
 80049e6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80049e8:	461a      	mov	r2, r3
 80049ea:	2304      	movs	r3, #4
 80049ec:	f2c0 0380 	movt	r3, #128	; 0x80
 80049f0:	fa03 f202 	lsl.w	r2, r3, r2
 80049f4:	68fb      	ldr	r3, [r7, #12]
 80049f6:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 80049f8:	687b      	ldr	r3, [r7, #4]
 80049fa:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80049fc:	f043 0204 	orr.w	r2, r3, #4
 8004a00:	687b      	ldr	r3, [r7, #4]
 8004a02:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
 8004a04:	687b      	ldr	r3, [r7, #4]
 8004a06:	2204      	movs	r2, #4
 8004a08:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 8004a0c:	687b      	ldr	r3, [r7, #4]
 8004a0e:	2200      	movs	r2, #0
 8004a10:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      if(hdma->XferErrorCallback != NULL)
 8004a14:	687b      	ldr	r3, [r7, #4]
 8004a16:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8004a18:	2b00      	cmp	r3, #0
 8004a1a:	d003      	beq.n	8004a24 <HAL_DMA_IRQHandler+0x164>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 8004a1c:	687b      	ldr	r3, [r7, #4]
 8004a1e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8004a20:	6878      	ldr	r0, [r7, #4]
 8004a22:	4798      	blx	r3
      }
    }
  }
  /* Half Transfer Complete Interrupt management ******************************/
  if ((regs->ISR & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 8004a24:	68fb      	ldr	r3, [r7, #12]
 8004a26:	681a      	ldr	r2, [r3, #0]
 8004a28:	687b      	ldr	r3, [r7, #4]
 8004a2a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004a2c:	2110      	movs	r1, #16
 8004a2e:	fa01 f303 	lsl.w	r3, r1, r3
 8004a32:	4013      	ands	r3, r2
 8004a34:	2b00      	cmp	r3, #0
 8004a36:	d04c      	beq.n	8004ad2 <HAL_DMA_IRQHandler+0x212>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 8004a38:	687b      	ldr	r3, [r7, #4]
 8004a3a:	681b      	ldr	r3, [r3, #0]
 8004a3c:	681b      	ldr	r3, [r3, #0]
 8004a3e:	f003 0308 	and.w	r3, r3, #8
 8004a42:	2b00      	cmp	r3, #0
 8004a44:	d045      	beq.n	8004ad2 <HAL_DMA_IRQHandler+0x212>
    {
      /* Multi_Buffering mode enabled */
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
 8004a46:	687b      	ldr	r3, [r7, #4]
 8004a48:	681b      	ldr	r3, [r3, #0]
 8004a4a:	681b      	ldr	r3, [r3, #0]
 8004a4c:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8004a50:	2b00      	cmp	r3, #0
 8004a52:	d01d      	beq.n	8004a90 <HAL_DMA_IRQHandler+0x1d0>
      {
        /* Clear the half transfer complete flag */
        regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 8004a54:	687b      	ldr	r3, [r7, #4]
 8004a56:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004a58:	2210      	movs	r2, #16
 8004a5a:	409a      	lsls	r2, r3
 8004a5c:	68fb      	ldr	r3, [r7, #12]
 8004a5e:	609a      	str	r2, [r3, #8]

        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
 8004a60:	687b      	ldr	r3, [r7, #4]
 8004a62:	681b      	ldr	r3, [r3, #0]
 8004a64:	681b      	ldr	r3, [r3, #0]
 8004a66:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8004a6a:	2b00      	cmp	r3, #0
 8004a6c:	d104      	bne.n	8004a78 <HAL_DMA_IRQHandler+0x1b8>
        {
          /* Change DMA peripheral state */
          hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
 8004a6e:	687b      	ldr	r3, [r7, #4]
 8004a70:	2231      	movs	r2, #49	; 0x31
 8004a72:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 8004a76:	e024      	b.n	8004ac2 <HAL_DMA_IRQHandler+0x202>
        }
        /* Current memory buffer used is Memory 1 */
        else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
 8004a78:	687b      	ldr	r3, [r7, #4]
 8004a7a:	681b      	ldr	r3, [r3, #0]
 8004a7c:	681b      	ldr	r3, [r3, #0]
 8004a7e:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8004a82:	2b00      	cmp	r3, #0
 8004a84:	d01d      	beq.n	8004ac2 <HAL_DMA_IRQHandler+0x202>
        {
          /* Change DMA peripheral state */
          hdma->State = HAL_DMA_STATE_READY_HALF_MEM1;
 8004a86:	687b      	ldr	r3, [r7, #4]
 8004a88:	2241      	movs	r2, #65	; 0x41
 8004a8a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 8004a8e:	e018      	b.n	8004ac2 <HAL_DMA_IRQHandler+0x202>
        }
      }
      else
      {
        /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 8004a90:	687b      	ldr	r3, [r7, #4]
 8004a92:	681b      	ldr	r3, [r3, #0]
 8004a94:	681b      	ldr	r3, [r3, #0]
 8004a96:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8004a9a:	2b00      	cmp	r3, #0
 8004a9c:	d107      	bne.n	8004aae <HAL_DMA_IRQHandler+0x1ee>
        {
          /* Disable the half transfer interrupt */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8004a9e:	687b      	ldr	r3, [r7, #4]
 8004aa0:	681b      	ldr	r3, [r3, #0]
 8004aa2:	687a      	ldr	r2, [r7, #4]
 8004aa4:	6812      	ldr	r2, [r2, #0]
 8004aa6:	6812      	ldr	r2, [r2, #0]
 8004aa8:	f022 0208 	bic.w	r2, r2, #8
 8004aac:	601a      	str	r2, [r3, #0]
        }
        /* Clear the half transfer complete flag */
        regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 8004aae:	687b      	ldr	r3, [r7, #4]
 8004ab0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004ab2:	2210      	movs	r2, #16
 8004ab4:	409a      	lsls	r2, r3
 8004ab6:	68fb      	ldr	r3, [r7, #12]
 8004ab8:	609a      	str	r2, [r3, #8]

        /* Change DMA peripheral state */
        hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
 8004aba:	687b      	ldr	r3, [r7, #4]
 8004abc:	2231      	movs	r2, #49	; 0x31
 8004abe:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
      }

      if(hdma->XferHalfCpltCallback != NULL)
 8004ac2:	687b      	ldr	r3, [r7, #4]
 8004ac4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004ac6:	2b00      	cmp	r3, #0
 8004ac8:	d003      	beq.n	8004ad2 <HAL_DMA_IRQHandler+0x212>
      {
        /* Half transfer callback */
        hdma->XferHalfCpltCallback(hdma);
 8004aca:	687b      	ldr	r3, [r7, #4]
 8004acc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004ace:	6878      	ldr	r0, [r7, #4]
 8004ad0:	4798      	blx	r3
      }
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  if ((regs->ISR & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 8004ad2:	68fb      	ldr	r3, [r7, #12]
 8004ad4:	681a      	ldr	r2, [r3, #0]
 8004ad6:	687b      	ldr	r3, [r7, #4]
 8004ad8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004ada:	2120      	movs	r1, #32
 8004adc:	fa01 f303 	lsl.w	r3, r1, r3
 8004ae0:	4013      	ands	r3, r2
 8004ae2:	2b00      	cmp	r3, #0
 8004ae4:	d05c      	beq.n	8004ba0 <HAL_DMA_IRQHandler+0x2e0>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 8004ae6:	687b      	ldr	r3, [r7, #4]
 8004ae8:	681b      	ldr	r3, [r3, #0]
 8004aea:	681b      	ldr	r3, [r3, #0]
 8004aec:	f003 0310 	and.w	r3, r3, #16
 8004af0:	2b00      	cmp	r3, #0
 8004af2:	d055      	beq.n	8004ba0 <HAL_DMA_IRQHandler+0x2e0>
    {
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
 8004af4:	687b      	ldr	r3, [r7, #4]
 8004af6:	681b      	ldr	r3, [r3, #0]
 8004af8:	681b      	ldr	r3, [r3, #0]
 8004afa:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8004afe:	2b00      	cmp	r3, #0
 8004b00:	d025      	beq.n	8004b4e <HAL_DMA_IRQHandler+0x28e>
      {
        /* Clear the transfer complete flag */
        regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 8004b02:	687b      	ldr	r3, [r7, #4]
 8004b04:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004b06:	2220      	movs	r2, #32
 8004b08:	409a      	lsls	r2, r3
 8004b0a:	68fb      	ldr	r3, [r7, #12]
 8004b0c:	609a      	str	r2, [r3, #8]

        /* Current memory buffer used is Memory 1 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
 8004b0e:	687b      	ldr	r3, [r7, #4]
 8004b10:	681b      	ldr	r3, [r3, #0]
 8004b12:	681b      	ldr	r3, [r3, #0]
 8004b14:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8004b18:	2b00      	cmp	r3, #0
 8004b1a:	d108      	bne.n	8004b2e <HAL_DMA_IRQHandler+0x26e>
        {
          if(hdma->XferM1CpltCallback != NULL)
 8004b1c:	687b      	ldr	r3, [r7, #4]
 8004b1e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8004b20:	2b00      	cmp	r3, #0
 8004b22:	d03d      	beq.n	8004ba0 <HAL_DMA_IRQHandler+0x2e0>
          {
            /* Transfer complete Callback for memory1 */
            hdma->XferM1CpltCallback(hdma);
 8004b24:	687b      	ldr	r3, [r7, #4]
 8004b26:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8004b28:	6878      	ldr	r0, [r7, #4]
 8004b2a:	4798      	blx	r3
 8004b2c:	e038      	b.n	8004ba0 <HAL_DMA_IRQHandler+0x2e0>
          }
        }
        /* Current memory buffer used is Memory 0 */
        else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
 8004b2e:	687b      	ldr	r3, [r7, #4]
 8004b30:	681b      	ldr	r3, [r3, #0]
 8004b32:	681b      	ldr	r3, [r3, #0]
 8004b34:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8004b38:	2b00      	cmp	r3, #0
 8004b3a:	d031      	beq.n	8004ba0 <HAL_DMA_IRQHandler+0x2e0>
        {
          if(hdma->XferCpltCallback != NULL)
 8004b3c:	687b      	ldr	r3, [r7, #4]
 8004b3e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004b40:	2b00      	cmp	r3, #0
 8004b42:	d02d      	beq.n	8004ba0 <HAL_DMA_IRQHandler+0x2e0>
          {
            /* Transfer complete Callback for memory0 */
            hdma->XferCpltCallback(hdma);
 8004b44:	687b      	ldr	r3, [r7, #4]
 8004b46:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004b48:	6878      	ldr	r0, [r7, #4]
 8004b4a:	4798      	blx	r3
 8004b4c:	e028      	b.n	8004ba0 <HAL_DMA_IRQHandler+0x2e0>
        }
      }
      /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
      else
      {
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 8004b4e:	687b      	ldr	r3, [r7, #4]
 8004b50:	681b      	ldr	r3, [r3, #0]
 8004b52:	681b      	ldr	r3, [r3, #0]
 8004b54:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8004b58:	2b00      	cmp	r3, #0
 8004b5a:	d107      	bne.n	8004b6c <HAL_DMA_IRQHandler+0x2ac>
        {
          /* Disable the transfer complete interrupt */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
 8004b5c:	687b      	ldr	r3, [r7, #4]
 8004b5e:	681b      	ldr	r3, [r3, #0]
 8004b60:	687a      	ldr	r2, [r7, #4]
 8004b62:	6812      	ldr	r2, [r2, #0]
 8004b64:	6812      	ldr	r2, [r2, #0]
 8004b66:	f022 0210 	bic.w	r2, r2, #16
 8004b6a:	601a      	str	r2, [r3, #0]
        }
        /* Clear the transfer complete flag */
        regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 8004b6c:	687b      	ldr	r3, [r7, #4]
 8004b6e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004b70:	2220      	movs	r2, #32
 8004b72:	409a      	lsls	r2, r3
 8004b74:	68fb      	ldr	r3, [r7, #12]
 8004b76:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_NONE;
 8004b78:	687b      	ldr	r3, [r7, #4]
 8004b7a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004b7c:	687b      	ldr	r3, [r7, #4]
 8004b7e:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY_MEM0;
 8004b80:	687b      	ldr	r3, [r7, #4]
 8004b82:	2211      	movs	r2, #17
 8004b84:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 8004b88:	687b      	ldr	r3, [r7, #4]
 8004b8a:	2200      	movs	r2, #0
 8004b8c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        if(hdma->XferCpltCallback != NULL)
 8004b90:	687b      	ldr	r3, [r7, #4]
 8004b92:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004b94:	2b00      	cmp	r3, #0
 8004b96:	d003      	beq.n	8004ba0 <HAL_DMA_IRQHandler+0x2e0>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
 8004b98:	687b      	ldr	r3, [r7, #4]
 8004b9a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004b9c:	6878      	ldr	r0, [r7, #4]
 8004b9e:	4798      	blx	r3
        }
      }
    }
  }
}
 8004ba0:	3710      	adds	r7, #16
 8004ba2:	46bd      	mov	sp, r7
 8004ba4:	bd80      	pop	{r7, pc}
 8004ba6:	bf00      	nop

08004ba8 <HAL_DMA_GetState>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL state
  */
HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
{
 8004ba8:	b480      	push	{r7}
 8004baa:	b083      	sub	sp, #12
 8004bac:	af00      	add	r7, sp, #0
 8004bae:	6078      	str	r0, [r7, #4]
  return hdma->State;
 8004bb0:	687b      	ldr	r3, [r7, #4]
 8004bb2:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8004bb6:	b2db      	uxtb	r3, r3
}
 8004bb8:	4618      	mov	r0, r3
 8004bba:	370c      	adds	r7, #12
 8004bbc:	46bd      	mov	sp, r7
 8004bbe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004bc2:	4770      	bx	lr

08004bc4 <HAL_DMA_GetError>:
  * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA Stream.
  * @retval DMA Error Code
  */
uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
{
 8004bc4:	b480      	push	{r7}
 8004bc6:	b083      	sub	sp, #12
 8004bc8:	af00      	add	r7, sp, #0
 8004bca:	6078      	str	r0, [r7, #4]
  return hdma->ErrorCode;
 8004bcc:	687b      	ldr	r3, [r7, #4]
 8004bce:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
 8004bd0:	4618      	mov	r0, r3
 8004bd2:	370c      	adds	r7, #12
 8004bd4:	46bd      	mov	sp, r7
 8004bd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004bda:	4770      	bx	lr

08004bdc <DMA_SetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8004bdc:	b480      	push	{r7}
 8004bde:	b085      	sub	sp, #20
 8004be0:	af00      	add	r7, sp, #0
 8004be2:	60f8      	str	r0, [r7, #12]
 8004be4:	60b9      	str	r1, [r7, #8]
 8004be6:	607a      	str	r2, [r7, #4]
 8004be8:	603b      	str	r3, [r7, #0]
  /* Clear DBM bit */
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8004bea:	68fb      	ldr	r3, [r7, #12]
 8004bec:	681b      	ldr	r3, [r3, #0]
 8004bee:	68fa      	ldr	r2, [r7, #12]
 8004bf0:	6812      	ldr	r2, [r2, #0]
 8004bf2:	6812      	ldr	r2, [r2, #0]
 8004bf4:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8004bf8:	601a      	str	r2, [r3, #0]

  /* Configure DMA Stream data length */
  hdma->Instance->NDTR = DataLength;
 8004bfa:	68fb      	ldr	r3, [r7, #12]
 8004bfc:	681b      	ldr	r3, [r3, #0]
 8004bfe:	683a      	ldr	r2, [r7, #0]
 8004c00:	605a      	str	r2, [r3, #4]

  /* Peripheral to Memory */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8004c02:	68fb      	ldr	r3, [r7, #12]
 8004c04:	689b      	ldr	r3, [r3, #8]
 8004c06:	2b40      	cmp	r3, #64	; 0x40
 8004c08:	d108      	bne.n	8004c1c <DMA_SetConfig+0x40>
  {
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;
 8004c0a:	68fb      	ldr	r3, [r7, #12]
 8004c0c:	681b      	ldr	r3, [r3, #0]
 8004c0e:	687a      	ldr	r2, [r7, #4]
 8004c10:	609a      	str	r2, [r3, #8]

    /* Configure DMA Stream source address */
    hdma->Instance->M0AR = SrcAddress;
 8004c12:	68fb      	ldr	r3, [r7, #12]
 8004c14:	681b      	ldr	r3, [r3, #0]
 8004c16:	68ba      	ldr	r2, [r7, #8]
 8004c18:	60da      	str	r2, [r3, #12]
 8004c1a:	e007      	b.n	8004c2c <DMA_SetConfig+0x50>
  }
  /* Memory to Peripheral */
  else
  {
    /* Configure DMA Stream source address */
    hdma->Instance->PAR = SrcAddress;
 8004c1c:	68fb      	ldr	r3, [r7, #12]
 8004c1e:	681b      	ldr	r3, [r3, #0]
 8004c20:	68ba      	ldr	r2, [r7, #8]
 8004c22:	609a      	str	r2, [r3, #8]
    
    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
 8004c24:	68fb      	ldr	r3, [r7, #12]
 8004c26:	681b      	ldr	r3, [r3, #0]
 8004c28:	687a      	ldr	r2, [r7, #4]
 8004c2a:	60da      	str	r2, [r3, #12]
  }
}
 8004c2c:	3714      	adds	r7, #20
 8004c2e:	46bd      	mov	sp, r7
 8004c30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004c34:	4770      	bx	lr
 8004c36:	bf00      	nop

08004c38 <DMA_CalcBaseAndBitshift>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
 8004c38:	b480      	push	{r7}
 8004c3a:	b085      	sub	sp, #20
 8004c3c:	af00      	add	r7, sp, #0
 8004c3e:	6078      	str	r0, [r7, #4]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFF) - 16) / 24;
 8004c40:	687b      	ldr	r3, [r7, #4]
 8004c42:	681b      	ldr	r3, [r3, #0]
 8004c44:	b2db      	uxtb	r3, r3
 8004c46:	f1a3 0210 	sub.w	r2, r3, #16
 8004c4a:	f64a 23ab 	movw	r3, #43691	; 0xaaab
 8004c4e:	f6ca 23aa 	movt	r3, #43690	; 0xaaaa
 8004c52:	fba3 1302 	umull	r1, r3, r3, r2
 8004c56:	091b      	lsrs	r3, r3, #4
 8004c58:	60fb      	str	r3, [r7, #12]
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8] = {0, 6, 16, 22, 0, 6, 16, 22};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8004c5a:	f64b 230c 	movw	r3, #47628	; 0xba0c
 8004c5e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8004c62:	68fa      	ldr	r2, [r7, #12]
 8004c64:	4413      	add	r3, r2
 8004c66:	781b      	ldrb	r3, [r3, #0]
 8004c68:	461a      	mov	r2, r3
 8004c6a:	687b      	ldr	r3, [r7, #4]
 8004c6c:	655a      	str	r2, [r3, #84]	; 0x54
  
  if (stream_number > 3)
 8004c6e:	68fb      	ldr	r3, [r7, #12]
 8004c70:	2b03      	cmp	r3, #3
 8004c72:	d909      	bls.n	8004c88 <DMA_CalcBaseAndBitshift+0x50>
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FF)) + 4);
 8004c74:	687b      	ldr	r3, [r7, #4]
 8004c76:	681b      	ldr	r3, [r3, #0]
 8004c78:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 8004c7c:	f023 0303 	bic.w	r3, r3, #3
 8004c80:	1d1a      	adds	r2, r3, #4
 8004c82:	687b      	ldr	r3, [r7, #4]
 8004c84:	651a      	str	r2, [r3, #80]	; 0x50
 8004c86:	e007      	b.n	8004c98 <DMA_CalcBaseAndBitshift+0x60>
  }
  else
  {
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FF));
 8004c88:	687b      	ldr	r3, [r7, #4]
 8004c8a:	681b      	ldr	r3, [r3, #0]
 8004c8c:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 8004c90:	f023 0303 	bic.w	r3, r3, #3
 8004c94:	687a      	ldr	r2, [r7, #4]
 8004c96:	6513      	str	r3, [r2, #80]	; 0x50
  }
  
  return hdma->StreamBaseAddress;
 8004c98:	687b      	ldr	r3, [r7, #4]
 8004c9a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
}
 8004c9c:	4618      	mov	r0, r3
 8004c9e:	3714      	adds	r7, #20
 8004ca0:	46bd      	mov	sp, r7
 8004ca2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004ca6:	4770      	bx	lr

08004ca8 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8004ca8:	b480      	push	{r7}
 8004caa:	b089      	sub	sp, #36	; 0x24
 8004cac:	af00      	add	r7, sp, #0
 8004cae:	6078      	str	r0, [r7, #4]
 8004cb0:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00;
 8004cb2:	2300      	movs	r3, #0
 8004cb4:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00;
 8004cb6:	2300      	movs	r3, #0
 8004cb8:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00;
 8004cba:	2300      	movs	r3, #0
 8004cbc:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 8004cbe:	2300      	movs	r3, #0
 8004cc0:	61fb      	str	r3, [r7, #28]
 8004cc2:	e1b0      	b.n	8005026 <HAL_GPIO_Init+0x37e>
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 8004cc4:	69fb      	ldr	r3, [r7, #28]
 8004cc6:	2201      	movs	r2, #1
 8004cc8:	fa02 f303 	lsl.w	r3, r2, r3
 8004ccc:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8004cce:	683b      	ldr	r3, [r7, #0]
 8004cd0:	681a      	ldr	r2, [r3, #0]
 8004cd2:	697b      	ldr	r3, [r7, #20]
 8004cd4:	4013      	ands	r3, r2
 8004cd6:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
 8004cd8:	693a      	ldr	r2, [r7, #16]
 8004cda:	697b      	ldr	r3, [r7, #20]
 8004cdc:	429a      	cmp	r2, r3
 8004cde:	f040 819f 	bne.w	8005020 <HAL_GPIO_Init+0x378>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8004ce2:	683b      	ldr	r3, [r7, #0]
 8004ce4:	685b      	ldr	r3, [r3, #4]
 8004ce6:	2b02      	cmp	r3, #2
 8004ce8:	d003      	beq.n	8004cf2 <HAL_GPIO_Init+0x4a>
 8004cea:	683b      	ldr	r3, [r7, #0]
 8004cec:	685b      	ldr	r3, [r3, #4]
 8004cee:	2b12      	cmp	r3, #18
 8004cf0:	d123      	bne.n	8004d3a <HAL_GPIO_Init+0x92>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 8004cf2:	69fb      	ldr	r3, [r7, #28]
 8004cf4:	08da      	lsrs	r2, r3, #3
 8004cf6:	687b      	ldr	r3, [r7, #4]
 8004cf8:	3208      	adds	r2, #8
 8004cfa:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8004cfe:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8004d00:	69fb      	ldr	r3, [r7, #28]
 8004d02:	f003 0307 	and.w	r3, r3, #7
 8004d06:	009b      	lsls	r3, r3, #2
 8004d08:	220f      	movs	r2, #15
 8004d0a:	fa02 f303 	lsl.w	r3, r2, r3
 8004d0e:	43db      	mvns	r3, r3
 8004d10:	69ba      	ldr	r2, [r7, #24]
 8004d12:	4013      	ands	r3, r2
 8004d14:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8004d16:	683b      	ldr	r3, [r7, #0]
 8004d18:	691a      	ldr	r2, [r3, #16]
 8004d1a:	69fb      	ldr	r3, [r7, #28]
 8004d1c:	f003 0307 	and.w	r3, r3, #7
 8004d20:	009b      	lsls	r3, r3, #2
 8004d22:	fa02 f303 	lsl.w	r3, r2, r3
 8004d26:	69ba      	ldr	r2, [r7, #24]
 8004d28:	4313      	orrs	r3, r2
 8004d2a:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3] = temp;
 8004d2c:	69fb      	ldr	r3, [r7, #28]
 8004d2e:	08da      	lsrs	r2, r3, #3
 8004d30:	687b      	ldr	r3, [r7, #4]
 8004d32:	3208      	adds	r2, #8
 8004d34:	69b9      	ldr	r1, [r7, #24]
 8004d36:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8004d3a:	687b      	ldr	r3, [r7, #4]
 8004d3c:	681b      	ldr	r3, [r3, #0]
 8004d3e:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8004d40:	69fb      	ldr	r3, [r7, #28]
 8004d42:	005b      	lsls	r3, r3, #1
 8004d44:	2203      	movs	r2, #3
 8004d46:	fa02 f303 	lsl.w	r3, r2, r3
 8004d4a:	43db      	mvns	r3, r3
 8004d4c:	69ba      	ldr	r2, [r7, #24]
 8004d4e:	4013      	ands	r3, r2
 8004d50:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8004d52:	683b      	ldr	r3, [r7, #0]
 8004d54:	685b      	ldr	r3, [r3, #4]
 8004d56:	f003 0203 	and.w	r2, r3, #3
 8004d5a:	69fb      	ldr	r3, [r7, #28]
 8004d5c:	005b      	lsls	r3, r3, #1
 8004d5e:	fa02 f303 	lsl.w	r3, r2, r3
 8004d62:	69ba      	ldr	r2, [r7, #24]
 8004d64:	4313      	orrs	r3, r2
 8004d66:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 8004d68:	687b      	ldr	r3, [r7, #4]
 8004d6a:	69ba      	ldr	r2, [r7, #24]
 8004d6c:	601a      	str	r2, [r3, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8004d6e:	683b      	ldr	r3, [r7, #0]
 8004d70:	685b      	ldr	r3, [r3, #4]
 8004d72:	2b01      	cmp	r3, #1
 8004d74:	d00b      	beq.n	8004d8e <HAL_GPIO_Init+0xe6>
 8004d76:	683b      	ldr	r3, [r7, #0]
 8004d78:	685b      	ldr	r3, [r3, #4]
 8004d7a:	2b02      	cmp	r3, #2
 8004d7c:	d007      	beq.n	8004d8e <HAL_GPIO_Init+0xe6>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8004d7e:	683b      	ldr	r3, [r7, #0]
 8004d80:	685b      	ldr	r3, [r3, #4]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8004d82:	2b11      	cmp	r3, #17
 8004d84:	d003      	beq.n	8004d8e <HAL_GPIO_Init+0xe6>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8004d86:	683b      	ldr	r3, [r7, #0]
 8004d88:	685b      	ldr	r3, [r3, #4]
 8004d8a:	2b12      	cmp	r3, #18
 8004d8c:	d130      	bne.n	8004df0 <HAL_GPIO_Init+0x148>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8004d8e:	687b      	ldr	r3, [r7, #4]
 8004d90:	689b      	ldr	r3, [r3, #8]
 8004d92:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8004d94:	69fb      	ldr	r3, [r7, #28]
 8004d96:	005b      	lsls	r3, r3, #1
 8004d98:	2203      	movs	r2, #3
 8004d9a:	fa02 f303 	lsl.w	r3, r2, r3
 8004d9e:	43db      	mvns	r3, r3
 8004da0:	69ba      	ldr	r2, [r7, #24]
 8004da2:	4013      	ands	r3, r2
 8004da4:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2));
 8004da6:	683b      	ldr	r3, [r7, #0]
 8004da8:	68da      	ldr	r2, [r3, #12]
 8004daa:	69fb      	ldr	r3, [r7, #28]
 8004dac:	005b      	lsls	r3, r3, #1
 8004dae:	fa02 f303 	lsl.w	r3, r2, r3
 8004db2:	69ba      	ldr	r2, [r7, #24]
 8004db4:	4313      	orrs	r3, r2
 8004db6:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 8004db8:	687b      	ldr	r3, [r7, #4]
 8004dba:	69ba      	ldr	r2, [r7, #24]
 8004dbc:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8004dbe:	687b      	ldr	r3, [r7, #4]
 8004dc0:	685b      	ldr	r3, [r3, #4]
 8004dc2:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8004dc4:	69fb      	ldr	r3, [r7, #28]
 8004dc6:	2201      	movs	r2, #1
 8004dc8:	fa02 f303 	lsl.w	r3, r2, r3
 8004dcc:	43db      	mvns	r3, r3
 8004dce:	69ba      	ldr	r2, [r7, #24]
 8004dd0:	4013      	ands	r3, r2
 8004dd2:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8004dd4:	683b      	ldr	r3, [r7, #0]
 8004dd6:	685b      	ldr	r3, [r3, #4]
 8004dd8:	f003 0310 	and.w	r3, r3, #16
 8004ddc:	091a      	lsrs	r2, r3, #4
 8004dde:	69fb      	ldr	r3, [r7, #28]
 8004de0:	fa02 f303 	lsl.w	r3, r2, r3
 8004de4:	69ba      	ldr	r2, [r7, #24]
 8004de6:	4313      	orrs	r3, r2
 8004de8:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 8004dea:	687b      	ldr	r3, [r7, #4]
 8004dec:	69ba      	ldr	r2, [r7, #24]
 8004dee:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8004df0:	687b      	ldr	r3, [r7, #4]
 8004df2:	68db      	ldr	r3, [r3, #12]
 8004df4:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8004df6:	69fb      	ldr	r3, [r7, #28]
 8004df8:	005b      	lsls	r3, r3, #1
 8004dfa:	2203      	movs	r2, #3
 8004dfc:	fa02 f303 	lsl.w	r3, r2, r3
 8004e00:	43db      	mvns	r3, r3
 8004e02:	69ba      	ldr	r2, [r7, #24]
 8004e04:	4013      	ands	r3, r2
 8004e06:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8004e08:	683b      	ldr	r3, [r7, #0]
 8004e0a:	689a      	ldr	r2, [r3, #8]
 8004e0c:	69fb      	ldr	r3, [r7, #28]
 8004e0e:	005b      	lsls	r3, r3, #1
 8004e10:	fa02 f303 	lsl.w	r3, r2, r3
 8004e14:	69ba      	ldr	r2, [r7, #24]
 8004e16:	4313      	orrs	r3, r2
 8004e18:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
 8004e1a:	687b      	ldr	r3, [r7, #4]
 8004e1c:	69ba      	ldr	r2, [r7, #24]
 8004e1e:	60da      	str	r2, [r3, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8004e20:	683b      	ldr	r3, [r7, #0]
 8004e22:	685b      	ldr	r3, [r3, #4]
 8004e24:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8004e28:	2b00      	cmp	r3, #0
 8004e2a:	f000 80f9 	beq.w	8005020 <HAL_GPIO_Init+0x378>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8004e2e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004e32:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004e36:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8004e3a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8004e3e:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8004e40:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8004e44:	645a      	str	r2, [r3, #68]	; 0x44
 8004e46:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004e4a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004e4e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8004e50:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8004e54:	60fb      	str	r3, [r7, #12]
 8004e56:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2];
 8004e58:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004e5c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8004e60:	69fa      	ldr	r2, [r7, #28]
 8004e62:	0892      	lsrs	r2, r2, #2
 8004e64:	3202      	adds	r2, #2
 8004e66:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8004e6a:	61bb      	str	r3, [r7, #24]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8004e6c:	69fb      	ldr	r3, [r7, #28]
 8004e6e:	f003 0303 	and.w	r3, r3, #3
 8004e72:	009b      	lsls	r3, r3, #2
 8004e74:	220f      	movs	r2, #15
 8004e76:	fa02 f303 	lsl.w	r3, r2, r3
 8004e7a:	43db      	mvns	r3, r3
 8004e7c:	69ba      	ldr	r2, [r7, #24]
 8004e7e:	4013      	ands	r3, r2
 8004e80:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8004e82:	687a      	ldr	r2, [r7, #4]
 8004e84:	2300      	movs	r3, #0
 8004e86:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004e8a:	429a      	cmp	r2, r3
 8004e8c:	d049      	beq.n	8004f22 <HAL_GPIO_Init+0x27a>
 8004e8e:	687a      	ldr	r2, [r7, #4]
 8004e90:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004e94:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004e98:	429a      	cmp	r2, r3
 8004e9a:	d040      	beq.n	8004f1e <HAL_GPIO_Init+0x276>
 8004e9c:	687a      	ldr	r2, [r7, #4]
 8004e9e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8004ea2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004ea6:	429a      	cmp	r2, r3
 8004ea8:	d037      	beq.n	8004f1a <HAL_GPIO_Init+0x272>
 8004eaa:	687a      	ldr	r2, [r7, #4]
 8004eac:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8004eb0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004eb4:	429a      	cmp	r2, r3
 8004eb6:	d02e      	beq.n	8004f16 <HAL_GPIO_Init+0x26e>
 8004eb8:	687a      	ldr	r2, [r7, #4]
 8004eba:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8004ebe:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004ec2:	429a      	cmp	r2, r3
 8004ec4:	d025      	beq.n	8004f12 <HAL_GPIO_Init+0x26a>
 8004ec6:	687a      	ldr	r2, [r7, #4]
 8004ec8:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8004ecc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004ed0:	429a      	cmp	r2, r3
 8004ed2:	d01c      	beq.n	8004f0e <HAL_GPIO_Init+0x266>
 8004ed4:	687a      	ldr	r2, [r7, #4]
 8004ed6:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 8004eda:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004ede:	429a      	cmp	r2, r3
 8004ee0:	d013      	beq.n	8004f0a <HAL_GPIO_Init+0x262>
 8004ee2:	687a      	ldr	r2, [r7, #4]
 8004ee4:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 8004ee8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004eec:	429a      	cmp	r2, r3
 8004eee:	d00a      	beq.n	8004f06 <HAL_GPIO_Init+0x25e>
 8004ef0:	687a      	ldr	r2, [r7, #4]
 8004ef2:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8004ef6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004efa:	429a      	cmp	r2, r3
 8004efc:	d101      	bne.n	8004f02 <HAL_GPIO_Init+0x25a>
 8004efe:	2308      	movs	r3, #8
 8004f00:	e010      	b.n	8004f24 <HAL_GPIO_Init+0x27c>
 8004f02:	2309      	movs	r3, #9
 8004f04:	e00e      	b.n	8004f24 <HAL_GPIO_Init+0x27c>
 8004f06:	2307      	movs	r3, #7
 8004f08:	e00c      	b.n	8004f24 <HAL_GPIO_Init+0x27c>
 8004f0a:	2306      	movs	r3, #6
 8004f0c:	e00a      	b.n	8004f24 <HAL_GPIO_Init+0x27c>
 8004f0e:	2305      	movs	r3, #5
 8004f10:	e008      	b.n	8004f24 <HAL_GPIO_Init+0x27c>
 8004f12:	2304      	movs	r3, #4
 8004f14:	e006      	b.n	8004f24 <HAL_GPIO_Init+0x27c>
 8004f16:	2303      	movs	r3, #3
 8004f18:	e004      	b.n	8004f24 <HAL_GPIO_Init+0x27c>
 8004f1a:	2302      	movs	r3, #2
 8004f1c:	e002      	b.n	8004f24 <HAL_GPIO_Init+0x27c>
 8004f1e:	2301      	movs	r3, #1
 8004f20:	e000      	b.n	8004f24 <HAL_GPIO_Init+0x27c>
 8004f22:	2300      	movs	r3, #0
 8004f24:	69fa      	ldr	r2, [r7, #28]
 8004f26:	f002 0203 	and.w	r2, r2, #3
 8004f2a:	0092      	lsls	r2, r2, #2
 8004f2c:	4093      	lsls	r3, r2
 8004f2e:	69ba      	ldr	r2, [r7, #24]
 8004f30:	4313      	orrs	r3, r2
 8004f32:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2] = temp;
 8004f34:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004f38:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8004f3c:	69fa      	ldr	r2, [r7, #28]
 8004f3e:	0892      	lsrs	r2, r2, #2
 8004f40:	3202      	adds	r2, #2
 8004f42:	69b9      	ldr	r1, [r7, #24]
 8004f44:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8004f48:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8004f4c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8004f50:	681b      	ldr	r3, [r3, #0]
 8004f52:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8004f54:	693b      	ldr	r3, [r7, #16]
 8004f56:	43db      	mvns	r3, r3
 8004f58:	69ba      	ldr	r2, [r7, #24]
 8004f5a:	4013      	ands	r3, r2
 8004f5c:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8004f5e:	683b      	ldr	r3, [r7, #0]
 8004f60:	685b      	ldr	r3, [r3, #4]
 8004f62:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8004f66:	2b00      	cmp	r3, #0
 8004f68:	d003      	beq.n	8004f72 <HAL_GPIO_Init+0x2ca>
        {
          temp |= iocurrent;
 8004f6a:	69ba      	ldr	r2, [r7, #24]
 8004f6c:	693b      	ldr	r3, [r7, #16]
 8004f6e:	4313      	orrs	r3, r2
 8004f70:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
 8004f72:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8004f76:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8004f7a:	69ba      	ldr	r2, [r7, #24]
 8004f7c:	601a      	str	r2, [r3, #0]

        temp = EXTI->EMR;
 8004f7e:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8004f82:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8004f86:	685b      	ldr	r3, [r3, #4]
 8004f88:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8004f8a:	693b      	ldr	r3, [r7, #16]
 8004f8c:	43db      	mvns	r3, r3
 8004f8e:	69ba      	ldr	r2, [r7, #24]
 8004f90:	4013      	ands	r3, r2
 8004f92:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8004f94:	683b      	ldr	r3, [r7, #0]
 8004f96:	685b      	ldr	r3, [r3, #4]
 8004f98:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8004f9c:	2b00      	cmp	r3, #0
 8004f9e:	d003      	beq.n	8004fa8 <HAL_GPIO_Init+0x300>
        {
          temp |= iocurrent;
 8004fa0:	69ba      	ldr	r2, [r7, #24]
 8004fa2:	693b      	ldr	r3, [r7, #16]
 8004fa4:	4313      	orrs	r3, r2
 8004fa6:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
 8004fa8:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8004fac:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8004fb0:	69ba      	ldr	r2, [r7, #24]
 8004fb2:	605a      	str	r2, [r3, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8004fb4:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8004fb8:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8004fbc:	689b      	ldr	r3, [r3, #8]
 8004fbe:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8004fc0:	693b      	ldr	r3, [r7, #16]
 8004fc2:	43db      	mvns	r3, r3
 8004fc4:	69ba      	ldr	r2, [r7, #24]
 8004fc6:	4013      	ands	r3, r2
 8004fc8:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8004fca:	683b      	ldr	r3, [r7, #0]
 8004fcc:	685b      	ldr	r3, [r3, #4]
 8004fce:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8004fd2:	2b00      	cmp	r3, #0
 8004fd4:	d003      	beq.n	8004fde <HAL_GPIO_Init+0x336>
        {
          temp |= iocurrent;
 8004fd6:	69ba      	ldr	r2, [r7, #24]
 8004fd8:	693b      	ldr	r3, [r7, #16]
 8004fda:	4313      	orrs	r3, r2
 8004fdc:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
 8004fde:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8004fe2:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8004fe6:	69ba      	ldr	r2, [r7, #24]
 8004fe8:	609a      	str	r2, [r3, #8]

        temp = EXTI->FTSR;
 8004fea:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8004fee:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8004ff2:	68db      	ldr	r3, [r3, #12]
 8004ff4:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8004ff6:	693b      	ldr	r3, [r7, #16]
 8004ff8:	43db      	mvns	r3, r3
 8004ffa:	69ba      	ldr	r2, [r7, #24]
 8004ffc:	4013      	ands	r3, r2
 8004ffe:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8005000:	683b      	ldr	r3, [r7, #0]
 8005002:	685b      	ldr	r3, [r3, #4]
 8005004:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8005008:	2b00      	cmp	r3, #0
 800500a:	d003      	beq.n	8005014 <HAL_GPIO_Init+0x36c>
        {
          temp |= iocurrent;
 800500c:	69ba      	ldr	r2, [r7, #24]
 800500e:	693b      	ldr	r3, [r7, #16]
 8005010:	4313      	orrs	r3, r2
 8005012:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
 8005014:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8005018:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800501c:	69ba      	ldr	r2, [r7, #24]
 800501e:	60da      	str	r2, [r3, #12]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 8005020:	69fb      	ldr	r3, [r7, #28]
 8005022:	3301      	adds	r3, #1
 8005024:	61fb      	str	r3, [r7, #28]
 8005026:	69fb      	ldr	r3, [r7, #28]
 8005028:	2b0f      	cmp	r3, #15
 800502a:	f67f ae4b 	bls.w	8004cc4 <HAL_GPIO_Init+0x1c>
        }
        EXTI->FTSR = temp;
      }
    }
  }
}
 800502e:	3724      	adds	r7, #36	; 0x24
 8005030:	46bd      	mov	sp, r7
 8005032:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005036:	4770      	bx	lr

08005038 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 8005038:	b480      	push	{r7}
 800503a:	b087      	sub	sp, #28
 800503c:	af00      	add	r7, sp, #0
 800503e:	6078      	str	r0, [r7, #4]
 8005040:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00;
 8005042:	2300      	movs	r3, #0
 8005044:	613b      	str	r3, [r7, #16]
  uint32_t iocurrent = 0x00;
 8005046:	2300      	movs	r3, #0
 8005048:	60fb      	str	r3, [r7, #12]
  uint32_t tmp = 0x00;
 800504a:	2300      	movs	r3, #0
 800504c:	60bb      	str	r3, [r7, #8]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  
  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 800504e:	2300      	movs	r3, #0
 8005050:	617b      	str	r3, [r7, #20]
 8005052:	e10f      	b.n	8005274 <HAL_GPIO_DeInit+0x23c>
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 8005054:	697b      	ldr	r3, [r7, #20]
 8005056:	2201      	movs	r2, #1
 8005058:	fa02 f303 	lsl.w	r3, r2, r3
 800505c:	613b      	str	r3, [r7, #16]
    /* Get the current IO position */
    iocurrent = (GPIO_Pin) & ioposition;
 800505e:	683a      	ldr	r2, [r7, #0]
 8005060:	693b      	ldr	r3, [r7, #16]
 8005062:	4013      	ands	r3, r2
 8005064:	60fb      	str	r3, [r7, #12]

    if(iocurrent == ioposition)
 8005066:	68fa      	ldr	r2, [r7, #12]
 8005068:	693b      	ldr	r3, [r7, #16]
 800506a:	429a      	cmp	r2, r3
 800506c:	f040 80ff 	bne.w	800526e <HAL_GPIO_DeInit+0x236>
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO Direction in Input Floating Mode */
      GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2));
 8005070:	687b      	ldr	r3, [r7, #4]
 8005072:	681a      	ldr	r2, [r3, #0]
 8005074:	697b      	ldr	r3, [r7, #20]
 8005076:	005b      	lsls	r3, r3, #1
 8005078:	2103      	movs	r1, #3
 800507a:	fa01 f303 	lsl.w	r3, r1, r3
 800507e:	43db      	mvns	r3, r3
 8005080:	401a      	ands	r2, r3
 8005082:	687b      	ldr	r3, [r7, #4]
 8005084:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8005086:	697b      	ldr	r3, [r7, #20]
 8005088:	08da      	lsrs	r2, r3, #3
 800508a:	697b      	ldr	r3, [r7, #20]
 800508c:	08d9      	lsrs	r1, r3, #3
 800508e:	687b      	ldr	r3, [r7, #4]
 8005090:	3108      	adds	r1, #8
 8005092:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 8005096:	697b      	ldr	r3, [r7, #20]
 8005098:	f003 0307 	and.w	r3, r3, #7
 800509c:	009b      	lsls	r3, r3, #2
 800509e:	200f      	movs	r0, #15
 80050a0:	fa00 f303 	lsl.w	r3, r0, r3
 80050a4:	43db      	mvns	r3, r3
 80050a6:	4019      	ands	r1, r3
 80050a8:	687b      	ldr	r3, [r7, #4]
 80050aa:	3208      	adds	r2, #8
 80050ac:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 80050b0:	687b      	ldr	r3, [r7, #4]
 80050b2:	689a      	ldr	r2, [r3, #8]
 80050b4:	697b      	ldr	r3, [r7, #20]
 80050b6:	005b      	lsls	r3, r3, #1
 80050b8:	2103      	movs	r1, #3
 80050ba:	fa01 f303 	lsl.w	r3, r1, r3
 80050be:	43db      	mvns	r3, r3
 80050c0:	401a      	ands	r2, r3
 80050c2:	687b      	ldr	r3, [r7, #4]
 80050c4:	609a      	str	r2, [r3, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
 80050c6:	687b      	ldr	r3, [r7, #4]
 80050c8:	685a      	ldr	r2, [r3, #4]
 80050ca:	697b      	ldr	r3, [r7, #20]
 80050cc:	2101      	movs	r1, #1
 80050ce:	fa01 f303 	lsl.w	r3, r1, r3
 80050d2:	43db      	mvns	r3, r3
 80050d4:	401a      	ands	r2, r3
 80050d6:	687b      	ldr	r3, [r7, #4]
 80050d8:	605a      	str	r2, [r3, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 80050da:	687b      	ldr	r3, [r7, #4]
 80050dc:	68da      	ldr	r2, [r3, #12]
 80050de:	697b      	ldr	r3, [r7, #20]
 80050e0:	005b      	lsls	r3, r3, #1
 80050e2:	2103      	movs	r1, #3
 80050e4:	fa01 f303 	lsl.w	r3, r1, r3
 80050e8:	43db      	mvns	r3, r3
 80050ea:	401a      	ands	r2, r3
 80050ec:	687b      	ldr	r3, [r7, #4]
 80050ee:	60da      	str	r2, [r3, #12]

      /*------------------------- EXTI Mode Configuration --------------------*/
      tmp = SYSCFG->EXTICR[position >> 2];
 80050f0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80050f4:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80050f8:	697a      	ldr	r2, [r7, #20]
 80050fa:	0892      	lsrs	r2, r2, #2
 80050fc:	3202      	adds	r2, #2
 80050fe:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8005102:	60bb      	str	r3, [r7, #8]
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8005104:	697b      	ldr	r3, [r7, #20]
 8005106:	f003 0303 	and.w	r3, r3, #3
 800510a:	009b      	lsls	r3, r3, #2
 800510c:	220f      	movs	r2, #15
 800510e:	fa02 f303 	lsl.w	r3, r2, r3
 8005112:	68ba      	ldr	r2, [r7, #8]
 8005114:	4013      	ands	r3, r2
 8005116:	60bb      	str	r3, [r7, #8]
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03))))
 8005118:	687a      	ldr	r2, [r7, #4]
 800511a:	2300      	movs	r3, #0
 800511c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005120:	429a      	cmp	r2, r3
 8005122:	d049      	beq.n	80051b8 <HAL_GPIO_DeInit+0x180>
 8005124:	687a      	ldr	r2, [r7, #4]
 8005126:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800512a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800512e:	429a      	cmp	r2, r3
 8005130:	d040      	beq.n	80051b4 <HAL_GPIO_DeInit+0x17c>
 8005132:	687a      	ldr	r2, [r7, #4]
 8005134:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8005138:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800513c:	429a      	cmp	r2, r3
 800513e:	d037      	beq.n	80051b0 <HAL_GPIO_DeInit+0x178>
 8005140:	687a      	ldr	r2, [r7, #4]
 8005142:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8005146:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800514a:	429a      	cmp	r2, r3
 800514c:	d02e      	beq.n	80051ac <HAL_GPIO_DeInit+0x174>
 800514e:	687a      	ldr	r2, [r7, #4]
 8005150:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8005154:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005158:	429a      	cmp	r2, r3
 800515a:	d025      	beq.n	80051a8 <HAL_GPIO_DeInit+0x170>
 800515c:	687a      	ldr	r2, [r7, #4]
 800515e:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8005162:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005166:	429a      	cmp	r2, r3
 8005168:	d01c      	beq.n	80051a4 <HAL_GPIO_DeInit+0x16c>
 800516a:	687a      	ldr	r2, [r7, #4]
 800516c:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 8005170:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005174:	429a      	cmp	r2, r3
 8005176:	d013      	beq.n	80051a0 <HAL_GPIO_DeInit+0x168>
 8005178:	687a      	ldr	r2, [r7, #4]
 800517a:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 800517e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005182:	429a      	cmp	r2, r3
 8005184:	d00a      	beq.n	800519c <HAL_GPIO_DeInit+0x164>
 8005186:	687a      	ldr	r2, [r7, #4]
 8005188:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800518c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005190:	429a      	cmp	r2, r3
 8005192:	d101      	bne.n	8005198 <HAL_GPIO_DeInit+0x160>
 8005194:	2308      	movs	r3, #8
 8005196:	e010      	b.n	80051ba <HAL_GPIO_DeInit+0x182>
 8005198:	2309      	movs	r3, #9
 800519a:	e00e      	b.n	80051ba <HAL_GPIO_DeInit+0x182>
 800519c:	2307      	movs	r3, #7
 800519e:	e00c      	b.n	80051ba <HAL_GPIO_DeInit+0x182>
 80051a0:	2306      	movs	r3, #6
 80051a2:	e00a      	b.n	80051ba <HAL_GPIO_DeInit+0x182>
 80051a4:	2305      	movs	r3, #5
 80051a6:	e008      	b.n	80051ba <HAL_GPIO_DeInit+0x182>
 80051a8:	2304      	movs	r3, #4
 80051aa:	e006      	b.n	80051ba <HAL_GPIO_DeInit+0x182>
 80051ac:	2303      	movs	r3, #3
 80051ae:	e004      	b.n	80051ba <HAL_GPIO_DeInit+0x182>
 80051b0:	2302      	movs	r3, #2
 80051b2:	e002      	b.n	80051ba <HAL_GPIO_DeInit+0x182>
 80051b4:	2301      	movs	r3, #1
 80051b6:	e000      	b.n	80051ba <HAL_GPIO_DeInit+0x182>
 80051b8:	2300      	movs	r3, #0
 80051ba:	697a      	ldr	r2, [r7, #20]
 80051bc:	f002 0203 	and.w	r2, r2, #3
 80051c0:	0092      	lsls	r2, r2, #2
 80051c2:	fa03 f202 	lsl.w	r2, r3, r2
 80051c6:	68bb      	ldr	r3, [r7, #8]
 80051c8:	429a      	cmp	r2, r3
 80051ca:	d150      	bne.n	800526e <HAL_GPIO_DeInit+0x236>
      {
        /* Configure the External Interrupt or event for the current IO */
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
 80051cc:	697b      	ldr	r3, [r7, #20]
 80051ce:	f003 0303 	and.w	r3, r3, #3
 80051d2:	009b      	lsls	r3, r3, #2
 80051d4:	220f      	movs	r2, #15
 80051d6:	fa02 f303 	lsl.w	r3, r2, r3
 80051da:	60bb      	str	r3, [r7, #8]
        SYSCFG->EXTICR[position >> 2] &= ~tmp;
 80051dc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80051e0:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80051e4:	697a      	ldr	r2, [r7, #20]
 80051e6:	0890      	lsrs	r0, r2, #2
 80051e8:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80051ec:	f2c4 0201 	movt	r2, #16385	; 0x4001
 80051f0:	6979      	ldr	r1, [r7, #20]
 80051f2:	0889      	lsrs	r1, r1, #2
 80051f4:	3102      	adds	r1, #2
 80051f6:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
 80051fa:	68ba      	ldr	r2, [r7, #8]
 80051fc:	43d2      	mvns	r2, r2
 80051fe:	4011      	ands	r1, r2
 8005200:	1c82      	adds	r2, r0, #2
 8005202:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

        /* Clear EXTI line configuration */
        EXTI->IMR &= ~((uint32_t)iocurrent);
 8005206:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 800520a:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800520e:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
 8005212:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8005216:	6811      	ldr	r1, [r2, #0]
 8005218:	68fa      	ldr	r2, [r7, #12]
 800521a:	43d2      	mvns	r2, r2
 800521c:	400a      	ands	r2, r1
 800521e:	601a      	str	r2, [r3, #0]
        EXTI->EMR &= ~((uint32_t)iocurrent);
 8005220:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8005224:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8005228:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
 800522c:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8005230:	6851      	ldr	r1, [r2, #4]
 8005232:	68fa      	ldr	r2, [r7, #12]
 8005234:	43d2      	mvns	r2, r2
 8005236:	400a      	ands	r2, r1
 8005238:	605a      	str	r2, [r3, #4]
        
        /* Clear Rising Falling edge configuration */
        EXTI->RTSR &= ~((uint32_t)iocurrent);
 800523a:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 800523e:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8005242:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
 8005246:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800524a:	6891      	ldr	r1, [r2, #8]
 800524c:	68fa      	ldr	r2, [r7, #12]
 800524e:	43d2      	mvns	r2, r2
 8005250:	400a      	ands	r2, r1
 8005252:	609a      	str	r2, [r3, #8]
        EXTI->FTSR &= ~((uint32_t)iocurrent);
 8005254:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8005258:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800525c:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
 8005260:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8005264:	68d1      	ldr	r1, [r2, #12]
 8005266:	68fa      	ldr	r2, [r7, #12]
 8005268:	43d2      	mvns	r2, r2
 800526a:	400a      	ands	r2, r1
 800526c:	60da      	str	r2, [r3, #12]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  
  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 800526e:	697b      	ldr	r3, [r7, #20]
 8005270:	3301      	adds	r3, #1
 8005272:	617b      	str	r3, [r7, #20]
 8005274:	697b      	ldr	r3, [r7, #20]
 8005276:	2b0f      	cmp	r3, #15
 8005278:	f67f aeec 	bls.w	8005054 <HAL_GPIO_DeInit+0x1c>
        EXTI->RTSR &= ~((uint32_t)iocurrent);
        EXTI->FTSR &= ~((uint32_t)iocurrent);
      }
    }
  }
}
 800527c:	371c      	adds	r7, #28
 800527e:	46bd      	mov	sp, r7
 8005280:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005284:	4770      	bx	lr
 8005286:	bf00      	nop

08005288 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8005288:	b480      	push	{r7}
 800528a:	b085      	sub	sp, #20
 800528c:	af00      	add	r7, sp, #0
 800528e:	6078      	str	r0, [r7, #4]
 8005290:	460b      	mov	r3, r1
 8005292:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 8005294:	687b      	ldr	r3, [r7, #4]
 8005296:	691a      	ldr	r2, [r3, #16]
 8005298:	887b      	ldrh	r3, [r7, #2]
 800529a:	4013      	ands	r3, r2
 800529c:	2b00      	cmp	r3, #0
 800529e:	d002      	beq.n	80052a6 <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
 80052a0:	2301      	movs	r3, #1
 80052a2:	73fb      	strb	r3, [r7, #15]
 80052a4:	e001      	b.n	80052aa <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
 80052a6:	2300      	movs	r3, #0
 80052a8:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 80052aa:	7bfb      	ldrb	r3, [r7, #15]
}
 80052ac:	4618      	mov	r0, r3
 80052ae:	3714      	adds	r7, #20
 80052b0:	46bd      	mov	sp, r7
 80052b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80052b6:	4770      	bx	lr

080052b8 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 80052b8:	b480      	push	{r7}
 80052ba:	b083      	sub	sp, #12
 80052bc:	af00      	add	r7, sp, #0
 80052be:	6078      	str	r0, [r7, #4]
 80052c0:	4613      	mov	r3, r2
 80052c2:	460a      	mov	r2, r1
 80052c4:	807a      	strh	r2, [r7, #2]
 80052c6:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 80052c8:	787b      	ldrb	r3, [r7, #1]
 80052ca:	2b00      	cmp	r3, #0
 80052cc:	d003      	beq.n	80052d6 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 80052ce:	887a      	ldrh	r2, [r7, #2]
 80052d0:	687b      	ldr	r3, [r7, #4]
 80052d2:	619a      	str	r2, [r3, #24]
 80052d4:	e003      	b.n	80052de <HAL_GPIO_WritePin+0x26>
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 80052d6:	887b      	ldrh	r3, [r7, #2]
 80052d8:	041a      	lsls	r2, r3, #16
 80052da:	687b      	ldr	r3, [r7, #4]
 80052dc:	619a      	str	r2, [r3, #24]
  }
}
 80052de:	370c      	adds	r7, #12
 80052e0:	46bd      	mov	sp, r7
 80052e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80052e6:	4770      	bx	lr

080052e8 <HAL_GPIO_TogglePin>:
  *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.
  * @param  GPIO_Pin: Specifies the pins to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 80052e8:	b480      	push	{r7}
 80052ea:	b083      	sub	sp, #12
 80052ec:	af00      	add	r7, sp, #0
 80052ee:	6078      	str	r0, [r7, #4]
 80052f0:	460b      	mov	r3, r1
 80052f2:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 80052f4:	687b      	ldr	r3, [r7, #4]
 80052f6:	695a      	ldr	r2, [r3, #20]
 80052f8:	887b      	ldrh	r3, [r7, #2]
 80052fa:	405a      	eors	r2, r3
 80052fc:	687b      	ldr	r3, [r7, #4]
 80052fe:	615a      	str	r2, [r3, #20]
}
 8005300:	370c      	adds	r7, #12
 8005302:	46bd      	mov	sp, r7
 8005304:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005308:	4770      	bx	lr
 800530a:	bf00      	nop

0800530c <HAL_GPIO_LockPin>:
  * @param  GPIO_Pin: specifies the port bit to be locked.
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800530c:	b480      	push	{r7}
 800530e:	b085      	sub	sp, #20
 8005310:	af00      	add	r7, sp, #0
 8005312:	6078      	str	r0, [r7, #4]
 8005314:	460b      	mov	r3, r1
 8005316:	807b      	strh	r3, [r7, #2]
  __IO uint32_t tmp = GPIO_LCKR_LCKK;
 8005318:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800531c:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Apply lock key write sequence */
  tmp |= GPIO_Pin;
 800531e:	887a      	ldrh	r2, [r7, #2]
 8005320:	68fb      	ldr	r3, [r7, #12]
 8005322:	4313      	orrs	r3, r2
 8005324:	60fb      	str	r3, [r7, #12]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
 8005326:	68fa      	ldr	r2, [r7, #12]
 8005328:	687b      	ldr	r3, [r7, #4]
 800532a:	61da      	str	r2, [r3, #28]
  /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
  GPIOx->LCKR = GPIO_Pin;
 800532c:	887a      	ldrh	r2, [r7, #2]
 800532e:	687b      	ldr	r3, [r7, #4]
 8005330:	61da      	str	r2, [r3, #28]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
 8005332:	68fa      	ldr	r2, [r7, #12]
 8005334:	687b      	ldr	r3, [r7, #4]
 8005336:	61da      	str	r2, [r3, #28]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8005338:	687b      	ldr	r3, [r7, #4]
 800533a:	69db      	ldr	r3, [r3, #28]
 800533c:	60fb      	str	r3, [r7, #12]

 if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)
 800533e:	687b      	ldr	r3, [r7, #4]
 8005340:	69db      	ldr	r3, [r3, #28]
 8005342:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8005346:	2b00      	cmp	r3, #0
 8005348:	d001      	beq.n	800534e <HAL_GPIO_LockPin+0x42>
  {
    return HAL_OK;
 800534a:	2300      	movs	r3, #0
 800534c:	e000      	b.n	8005350 <HAL_GPIO_LockPin+0x44>
  }
  else
  {
    return HAL_ERROR;
 800534e:	2301      	movs	r3, #1
  }
}
 8005350:	4618      	mov	r0, r3
 8005352:	3714      	adds	r7, #20
 8005354:	46bd      	mov	sp, r7
 8005356:	f85d 7b04 	ldr.w	r7, [sp], #4
 800535a:	4770      	bx	lr

0800535c <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  This function handles EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the pins connected EXTI line
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 800535c:	b580      	push	{r7, lr}
 800535e:	b082      	sub	sp, #8
 8005360:	af00      	add	r7, sp, #0
 8005362:	4603      	mov	r3, r0
 8005364:	80fb      	strh	r3, [r7, #6]
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
 8005366:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 800536a:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800536e:	695a      	ldr	r2, [r3, #20]
 8005370:	88fb      	ldrh	r3, [r7, #6]
 8005372:	4013      	ands	r3, r2
 8005374:	2b00      	cmp	r3, #0
 8005376:	d009      	beq.n	800538c <HAL_GPIO_EXTI_IRQHandler+0x30>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8005378:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 800537c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8005380:	88fa      	ldrh	r2, [r7, #6]
 8005382:	615a      	str	r2, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8005384:	88fb      	ldrh	r3, [r7, #6]
 8005386:	4618      	mov	r0, r3
 8005388:	f000 f804 	bl	8005394 <HAL_GPIO_EXTI_Callback>
  }
}
 800538c:	3708      	adds	r7, #8
 800538e:	46bd      	mov	sp, r7
 8005390:	bd80      	pop	{r7, pc}
 8005392:	bf00      	nop

08005394 <HAL_GPIO_EXTI_Callback>:
  * @brief  EXTI line detection callbacks.
  * @param  GPIO_Pin: Specifies the pins connected EXTI line
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
 8005394:	b480      	push	{r7}
 8005396:	b083      	sub	sp, #12
 8005398:	af00      	add	r7, sp, #0
 800539a:	4603      	mov	r3, r0
 800539c:	80fb      	strh	r3, [r7, #6]
  /* NOTE: This function Should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Callback could be implemented in the user file
   */
}
 800539e:	370c      	adds	r7, #12
 80053a0:	46bd      	mov	sp, r7
 80053a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80053a6:	4770      	bx	lr
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_I2S_Init(I2S_HandleTypeDef *hi2s)
{
 80053a8:	b580      	push	{r7, lr}
 80053aa:	b088      	sub	sp, #32
 80053ac:	af00      	add	r7, sp, #0
 80053ae:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
 80053b0:	2300      	movs	r3, #0
 80053b2:	60fb      	str	r3, [r7, #12]
 80053b4:	2302      	movs	r3, #2
 80053b6:	61fb      	str	r3, [r7, #28]
 80053b8:	2300      	movs	r3, #0
 80053ba:	61bb      	str	r3, [r7, #24]
 80053bc:	2301      	movs	r3, #1
 80053be:	617b      	str	r3, [r7, #20]
  uint32_t tmp = 0, i2sclk = 0;
 80053c0:	2300      	movs	r3, #0
 80053c2:	613b      	str	r3, [r7, #16]
 80053c4:	2300      	movs	r3, #0
 80053c6:	60bb      	str	r3, [r7, #8]
  
  /* Check the I2S handle allocation */
  if(hi2s == NULL)
 80053c8:	687b      	ldr	r3, [r7, #4]
 80053ca:	2b00      	cmp	r3, #0
 80053cc:	d101      	bne.n	80053d2 <HAL_GPIO_EXTI_Callback+0x3e>
  {
    return HAL_ERROR;
 80053ce:	2301      	movs	r3, #1
 80053d0:	e097      	b.n	8005502 <HAL_GPIO_EXTI_Callback+0x16e>
  assert_param(IS_I2S_MCLK_OUTPUT(hi2s->Init.MCLKOutput));
  assert_param(IS_I2S_AUDIO_FREQ(hi2s->Init.AudioFreq));
  assert_param(IS_I2S_CPOL(hi2s->Init.CPOL));  
  assert_param(IS_I2S_CLOCKSOURCE(hi2s->Init.ClockSource));
  
  if(hi2s->State == HAL_I2S_STATE_RESET)
 80053d2:	687b      	ldr	r3, [r7, #4]
 80053d4:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80053d8:	b2db      	uxtb	r3, r3
 80053da:	2b00      	cmp	r3, #0
 80053dc:	d106      	bne.n	80053ec <HAL_GPIO_EXTI_Callback+0x58>
  {
    /* Allocate lock resource and initialize it */
    hi2s->Lock = HAL_UNLOCKED;
 80053de:	687b      	ldr	r3, [r7, #4]
 80053e0:	2200      	movs	r2, #0
 80053e2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2S_MspInit(hi2s);
 80053e6:	6878      	ldr	r0, [r7, #4]
 80053e8:	f7fb fb90 	bl	8000b0c <HAL_I2S_MspInit>
  }
  
  hi2s->State = HAL_I2S_STATE_BUSY;
 80053ec:	687b      	ldr	r3, [r7, #4]
 80053ee:	2202      	movs	r2, #2
 80053f0:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /*----------------------- SPIx I2SCFGR & I2SPR Configuration ---------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  hi2s->Instance->I2SCFGR &= ~(SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
 80053f4:	687b      	ldr	r3, [r7, #4]
 80053f6:	681a      	ldr	r2, [r3, #0]
 80053f8:	687b      	ldr	r3, [r7, #4]
 80053fa:	681b      	ldr	r3, [r3, #0]
 80053fc:	69db      	ldr	r3, [r3, #28]
 80053fe:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 8005402:	f023 030f 	bic.w	r3, r3, #15
 8005406:	61d3      	str	r3, [r2, #28]
                               SPI_I2SCFGR_I2SSTD | SPI_I2SCFGR_PCMSYNC | SPI_I2SCFGR_I2SCFG | \
                               SPI_I2SCFGR_I2SE | SPI_I2SCFGR_I2SMOD); 
  hi2s->Instance->I2SPR = 0x0002;
 8005408:	687b      	ldr	r3, [r7, #4]
 800540a:	681b      	ldr	r3, [r3, #0]
 800540c:	2202      	movs	r2, #2
 800540e:	621a      	str	r2, [r3, #32]

  /* Get the I2SCFGR register value */
  tmpreg = hi2s->Instance->I2SCFGR;
 8005410:	687b      	ldr	r3, [r7, #4]
 8005412:	681b      	ldr	r3, [r3, #0]
 8005414:	69db      	ldr	r3, [r3, #28]
 8005416:	60fb      	str	r3, [r7, #12]

  /* If the default frequency value has to be written, reinitialize i2sdiv and i2sodd */
  /* If the requested audio frequency is not the default, compute the prescaler */
  if(hi2s->Init.AudioFreq != I2S_AUDIOFREQ_DEFAULT)
 8005418:	687b      	ldr	r3, [r7, #4]
 800541a:	695b      	ldr	r3, [r3, #20]
 800541c:	2b02      	cmp	r3, #2
 800541e:	d041      	beq.n	80054a4 <HAL_GPIO_EXTI_Callback+0x110>
  {
    /* Check the frame length (For the Prescaler computing) *******************/
    if(hi2s->Init.DataFormat != I2S_DATAFORMAT_16B)
 8005420:	687b      	ldr	r3, [r7, #4]
 8005422:	68db      	ldr	r3, [r3, #12]
 8005424:	2b00      	cmp	r3, #0
 8005426:	d001      	beq.n	800542c <HAL_GPIO_EXTI_Callback+0x98>
    {
      /* Packet length is 32 bits */
      packetlength = 2;
 8005428:	2302      	movs	r3, #2
 800542a:	617b      	str	r3, [r7, #20]
    }

    /* Get I2S source Clock frequency  ****************************************/
    /* If an external I2S clock has to be used, the specific define should be set  
    in the project configuration or in the stm32f4xx_conf.h file */
    i2sclk = I2S_GetInputClock(hi2s);
 800542c:	6878      	ldr	r0, [r7, #4]
 800542e:	f002 fcb5 	bl	8007d9c <I2S_GetInputClock>
 8005432:	60b8      	str	r0, [r7, #8]

    /* Compute the Real divider depending on the MCLK output state, with a floating point */
    if(hi2s->Init.MCLKOutput == I2S_MCLKOUTPUT_ENABLE)
 8005434:	687b      	ldr	r3, [r7, #4]
 8005436:	691b      	ldr	r3, [r3, #16]
 8005438:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800543c:	d10d      	bne.n	800545a <HAL_GPIO_EXTI_Callback+0xc6>
    {
      /* MCLK output is enabled */
      tmp = (uint32_t)(((((i2sclk / 256) * 10) / hi2s->Init.AudioFreq)) + 5);
 800543e:	68bb      	ldr	r3, [r7, #8]
 8005440:	0a1a      	lsrs	r2, r3, #8
 8005442:	4613      	mov	r3, r2
 8005444:	009b      	lsls	r3, r3, #2
 8005446:	4413      	add	r3, r2
 8005448:	005b      	lsls	r3, r3, #1
 800544a:	461a      	mov	r2, r3
 800544c:	687b      	ldr	r3, [r7, #4]
 800544e:	695b      	ldr	r3, [r3, #20]
 8005450:	fbb2 f3f3 	udiv	r3, r2, r3
 8005454:	3305      	adds	r3, #5
 8005456:	613b      	str	r3, [r7, #16]
 8005458:	e00f      	b.n	800547a <HAL_GPIO_EXTI_Callback+0xe6>
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint32_t)(((((i2sclk / (32 * packetlength)) *10 ) / hi2s->Init.AudioFreq)) + 5);
 800545a:	697b      	ldr	r3, [r7, #20]
 800545c:	015b      	lsls	r3, r3, #5
 800545e:	68ba      	ldr	r2, [r7, #8]
 8005460:	fbb2 f2f3 	udiv	r2, r2, r3
 8005464:	4613      	mov	r3, r2
 8005466:	009b      	lsls	r3, r3, #2
 8005468:	4413      	add	r3, r2
 800546a:	005b      	lsls	r3, r3, #1
 800546c:	461a      	mov	r2, r3
 800546e:	687b      	ldr	r3, [r7, #4]
 8005470:	695b      	ldr	r3, [r3, #20]
 8005472:	fbb2 f3f3 	udiv	r3, r2, r3
 8005476:	3305      	adds	r3, #5
 8005478:	613b      	str	r3, [r7, #16]
    }

    /* Remove the flatting point */
    tmp = tmp / 10;  
 800547a:	693a      	ldr	r2, [r7, #16]
 800547c:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 8005480:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
 8005484:	fba3 1302 	umull	r1, r3, r3, r2
 8005488:	08db      	lsrs	r3, r3, #3
 800548a:	613b      	str	r3, [r7, #16]

    /* Check the parity of the divider */
    i2sodd = (uint32_t)(tmp & (uint32_t)1);
 800548c:	693b      	ldr	r3, [r7, #16]
 800548e:	f003 0301 	and.w	r3, r3, #1
 8005492:	61bb      	str	r3, [r7, #24]

    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint32_t)((tmp - i2sodd) / 2);
 8005494:	693a      	ldr	r2, [r7, #16]
 8005496:	69bb      	ldr	r3, [r7, #24]
 8005498:	1ad3      	subs	r3, r2, r3
 800549a:	085b      	lsrs	r3, r3, #1
 800549c:	61fb      	str	r3, [r7, #28]

    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint32_t) (i2sodd << 8);
 800549e:	69bb      	ldr	r3, [r7, #24]
 80054a0:	021b      	lsls	r3, r3, #8
 80054a2:	61bb      	str	r3, [r7, #24]
  }

  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if((i2sdiv < 2) || (i2sdiv > 0xFF))
 80054a4:	69fb      	ldr	r3, [r7, #28]
 80054a6:	2b01      	cmp	r3, #1
 80054a8:	d902      	bls.n	80054b0 <HAL_GPIO_EXTI_Callback+0x11c>
 80054aa:	69fb      	ldr	r3, [r7, #28]
 80054ac:	2bff      	cmp	r3, #255	; 0xff
 80054ae:	d903      	bls.n	80054b8 <HAL_GPIO_EXTI_Callback+0x124>
  {
    /* Set the default values */
    i2sdiv = 2;
 80054b0:	2302      	movs	r3, #2
 80054b2:	61fb      	str	r3, [r7, #28]
    i2sodd = 0;
 80054b4:	2300      	movs	r3, #0
 80054b6:	61bb      	str	r3, [r7, #24]
  }
  
  /* Write to SPIx I2SPR register the computed value */
  hi2s->Instance->I2SPR = (uint32_t)((uint32_t)i2sdiv | (uint32_t)(i2sodd | (uint32_t)hi2s->Init.MCLKOutput));
 80054b8:	687b      	ldr	r3, [r7, #4]
 80054ba:	681b      	ldr	r3, [r3, #0]
 80054bc:	687a      	ldr	r2, [r7, #4]
 80054be:	6911      	ldr	r1, [r2, #16]
 80054c0:	69ba      	ldr	r2, [r7, #24]
 80054c2:	4311      	orrs	r1, r2
 80054c4:	69fa      	ldr	r2, [r7, #28]
 80054c6:	430a      	orrs	r2, r1
 80054c8:	621a      	str	r2, [r3, #32]
  
  /* Configure the I2S with the I2S_InitStruct values */
  tmpreg |= (uint32_t)(SPI_I2SCFGR_I2SMOD | hi2s->Init.Mode | hi2s->Init.Standard | hi2s->Init.DataFormat | hi2s->Init.CPOL);
 80054ca:	687b      	ldr	r3, [r7, #4]
 80054cc:	685a      	ldr	r2, [r3, #4]
 80054ce:	687b      	ldr	r3, [r7, #4]
 80054d0:	689b      	ldr	r3, [r3, #8]
 80054d2:	431a      	orrs	r2, r3
 80054d4:	687b      	ldr	r3, [r7, #4]
 80054d6:	68db      	ldr	r3, [r3, #12]
 80054d8:	431a      	orrs	r2, r3
 80054da:	687b      	ldr	r3, [r7, #4]
 80054dc:	699b      	ldr	r3, [r3, #24]
 80054de:	431a      	orrs	r2, r3
 80054e0:	68fb      	ldr	r3, [r7, #12]
 80054e2:	4313      	orrs	r3, r2
 80054e4:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80054e8:	60fb      	str	r3, [r7, #12]
  /* Write to SPIx I2SCFGR */  
  hi2s->Instance->I2SCFGR = tmpreg;    
  }
#else
  /* Write to SPIx I2SCFGR */  
  hi2s->Instance->I2SCFGR = tmpreg;
 80054ea:	687b      	ldr	r3, [r7, #4]
 80054ec:	681b      	ldr	r3, [r3, #0]
 80054ee:	68fa      	ldr	r2, [r7, #12]
 80054f0:	61da      	str	r2, [r3, #28]
#endif
  
  hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
 80054f2:	687b      	ldr	r3, [r7, #4]
 80054f4:	2200      	movs	r2, #0
 80054f6:	641a      	str	r2, [r3, #64]	; 0x40
  hi2s->State= HAL_I2S_STATE_READY;
 80054f8:	687b      	ldr	r3, [r7, #4]
 80054fa:	2201      	movs	r2, #1
 80054fc:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  return HAL_OK;
 8005500:	2300      	movs	r3, #0
}
 8005502:	4618      	mov	r0, r3
 8005504:	3720      	adds	r7, #32
 8005506:	46bd      	mov	sp, r7
 8005508:	bd80      	pop	{r7, pc}
 800550a:	bf00      	nop

0800550c <HAL_I2S_DeInit>:
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2S_DeInit(I2S_HandleTypeDef *hi2s)
{
 800550c:	b580      	push	{r7, lr}
 800550e:	b082      	sub	sp, #8
 8005510:	af00      	add	r7, sp, #0
 8005512:	6078      	str	r0, [r7, #4]
  /* Check the I2S handle allocation */
  if(hi2s == NULL)
 8005514:	687b      	ldr	r3, [r7, #4]
 8005516:	2b00      	cmp	r3, #0
 8005518:	d101      	bne.n	800551e <HAL_I2S_DeInit+0x12>
  {
    return HAL_ERROR;
 800551a:	2301      	movs	r3, #1
 800551c:	e012      	b.n	8005544 <HAL_I2S_DeInit+0x38>
  }
  
  hi2s->State = HAL_I2S_STATE_BUSY;
 800551e:	687b      	ldr	r3, [r7, #4]
 8005520:	2202      	movs	r2, #2
 8005522:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
  HAL_I2S_MspDeInit(hi2s);
 8005526:	6878      	ldr	r0, [r7, #4]
 8005528:	f7fb fbfc 	bl	8000d24 <HAL_I2S_MspDeInit>

  hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
 800552c:	687b      	ldr	r3, [r7, #4]
 800552e:	2200      	movs	r2, #0
 8005530:	641a      	str	r2, [r3, #64]	; 0x40
  hi2s->State = HAL_I2S_STATE_RESET;
 8005532:	687b      	ldr	r3, [r7, #4]
 8005534:	2200      	movs	r2, #0
 8005536:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(hi2s);
 800553a:	687b      	ldr	r3, [r7, #4]
 800553c:	2200      	movs	r2, #0
 800553e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 8005542:	2300      	movs	r3, #0
}
 8005544:	4618      	mov	r0, r3
 8005546:	3708      	adds	r7, #8
 8005548:	46bd      	mov	sp, r7
 800554a:	bd80      	pop	{r7, pc}
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
 __weak void HAL_I2S_MspInit(I2S_HandleTypeDef *hi2s)
{
 800554c:	b480      	push	{r7}
 800554e:	b083      	sub	sp, #12
 8005550:	af00      	add	r7, sp, #0
 8005552:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_MspInit could be implemented in the user file
   */ 
}
 8005554:	370c      	adds	r7, #12
 8005556:	46bd      	mov	sp, r7
 8005558:	f85d 7b04 	ldr.w	r7, [sp], #4
 800555c:	4770      	bx	lr
 800555e:	bf00      	nop
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
 __weak void HAL_I2S_MspDeInit(I2S_HandleTypeDef *hi2s)
{
 8005560:	b480      	push	{r7}
 8005562:	b083      	sub	sp, #12
 8005564:	af00      	add	r7, sp, #0
 8005566:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_MspDeInit could be implemented in the user file
   */ 
}
 8005568:	370c      	adds	r7, #12
 800556a:	46bd      	mov	sp, r7
 800556c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005570:	4770      	bx	lr
 8005572:	bf00      	nop

08005574 <HAL_I2S_Transmit>:
  * @note The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization 
  *       between Master and Slave(example: audio streaming).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2S_Transmit(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size, uint32_t Timeout)
{
 8005574:	b580      	push	{r7, lr}
 8005576:	b086      	sub	sp, #24
 8005578:	af00      	add	r7, sp, #0
 800557a:	60f8      	str	r0, [r7, #12]
 800557c:	60b9      	str	r1, [r7, #8]
 800557e:	603b      	str	r3, [r7, #0]
 8005580:	4613      	mov	r3, r2
 8005582:	80fb      	strh	r3, [r7, #6]
  uint32_t tmp1 = 0, tmp2 = 0;  
 8005584:	2300      	movs	r3, #0
 8005586:	617b      	str	r3, [r7, #20]
 8005588:	2300      	movs	r3, #0
 800558a:	613b      	str	r3, [r7, #16]
  if((pData == NULL ) || (Size == 0)) 
 800558c:	68bb      	ldr	r3, [r7, #8]
 800558e:	2b00      	cmp	r3, #0
 8005590:	d002      	beq.n	8005598 <HAL_I2S_Transmit+0x24>
 8005592:	88fb      	ldrh	r3, [r7, #6]
 8005594:	2b00      	cmp	r3, #0
 8005596:	d101      	bne.n	800559c <HAL_I2S_Transmit+0x28>
  {
    return  HAL_ERROR;
 8005598:	2301      	movs	r3, #1
 800559a:	e08d      	b.n	80056b8 <HAL_I2S_Transmit+0x144>
  }
  
  if(hi2s->State == HAL_I2S_STATE_READY)
 800559c:	68fb      	ldr	r3, [r7, #12]
 800559e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80055a2:	b2db      	uxtb	r3, r3
 80055a4:	2b01      	cmp	r3, #1
 80055a6:	f040 8086 	bne.w	80056b6 <HAL_I2S_Transmit+0x142>
  { 
    tmp1 = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 80055aa:	68fb      	ldr	r3, [r7, #12]
 80055ac:	681b      	ldr	r3, [r3, #0]
 80055ae:	69db      	ldr	r3, [r3, #28]
 80055b0:	f003 0307 	and.w	r3, r3, #7
 80055b4:	617b      	str	r3, [r7, #20]
    tmp2 = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 80055b6:	68fb      	ldr	r3, [r7, #12]
 80055b8:	681b      	ldr	r3, [r3, #0]
 80055ba:	69db      	ldr	r3, [r3, #28]
 80055bc:	f003 0307 	and.w	r3, r3, #7
 80055c0:	613b      	str	r3, [r7, #16]
    if((tmp1 == I2S_DATAFORMAT_24B)|| \
 80055c2:	697b      	ldr	r3, [r7, #20]
 80055c4:	2b03      	cmp	r3, #3
 80055c6:	d002      	beq.n	80055ce <HAL_I2S_Transmit+0x5a>
 80055c8:	693b      	ldr	r3, [r7, #16]
 80055ca:	2b05      	cmp	r3, #5
 80055cc:	d10a      	bne.n	80055e4 <HAL_I2S_Transmit+0x70>
       (tmp2 == I2S_DATAFORMAT_32B))
    {
      hi2s->TxXferSize = Size*2;
 80055ce:	88fb      	ldrh	r3, [r7, #6]
 80055d0:	005b      	lsls	r3, r3, #1
 80055d2:	b29a      	uxth	r2, r3
 80055d4:	68fb      	ldr	r3, [r7, #12]
 80055d6:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2s->TxXferCount = Size*2;
 80055d8:	88fb      	ldrh	r3, [r7, #6]
 80055da:	005b      	lsls	r3, r3, #1
 80055dc:	b29a      	uxth	r2, r3
 80055de:	68fb      	ldr	r3, [r7, #12]
 80055e0:	855a      	strh	r2, [r3, #42]	; 0x2a
 80055e2:	e005      	b.n	80055f0 <HAL_I2S_Transmit+0x7c>
    }
    else
    {
      hi2s->TxXferSize = Size;
 80055e4:	68fb      	ldr	r3, [r7, #12]
 80055e6:	88fa      	ldrh	r2, [r7, #6]
 80055e8:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2s->TxXferCount = Size;
 80055ea:	68fb      	ldr	r3, [r7, #12]
 80055ec:	88fa      	ldrh	r2, [r7, #6]
 80055ee:	855a      	strh	r2, [r3, #42]	; 0x2a
    }
    
    /* Process Locked */
    __HAL_LOCK(hi2s);
 80055f0:	68fb      	ldr	r3, [r7, #12]
 80055f2:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80055f6:	b2db      	uxtb	r3, r3
 80055f8:	2b01      	cmp	r3, #1
 80055fa:	d101      	bne.n	8005600 <HAL_I2S_Transmit+0x8c>
 80055fc:	2302      	movs	r3, #2
 80055fe:	e05b      	b.n	80056b8 <HAL_I2S_Transmit+0x144>
 8005600:	68fb      	ldr	r3, [r7, #12]
 8005602:	2201      	movs	r2, #1
 8005604:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    
    hi2s->State = HAL_I2S_STATE_BUSY_TX;
 8005608:	68fb      	ldr	r3, [r7, #12]
 800560a:	2212      	movs	r2, #18
 800560c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
   
    /* Check if the I2S is already enabled */ 
    if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
 8005610:	68fb      	ldr	r3, [r7, #12]
 8005612:	681b      	ldr	r3, [r3, #0]
 8005614:	69db      	ldr	r3, [r3, #28]
 8005616:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800561a:	2b00      	cmp	r3, #0
 800561c:	d108      	bne.n	8005630 <HAL_I2S_Transmit+0xbc>
    {
      /* Enable I2S peripheral */
      __HAL_I2S_ENABLE(hi2s);
 800561e:	68fb      	ldr	r3, [r7, #12]
 8005620:	681b      	ldr	r3, [r3, #0]
 8005622:	68fa      	ldr	r2, [r7, #12]
 8005624:	6812      	ldr	r2, [r2, #0]
 8005626:	69d2      	ldr	r2, [r2, #28]
 8005628:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800562c:	61da      	str	r2, [r3, #28]
    }
    
    while(hi2s->TxXferCount > 0)
 800562e:	e019      	b.n	8005664 <HAL_I2S_Transmit+0xf0>
 8005630:	e018      	b.n	8005664 <HAL_I2S_Transmit+0xf0>
    {
      hi2s->Instance->DR = (*pData++);
 8005632:	68fb      	ldr	r3, [r7, #12]
 8005634:	681a      	ldr	r2, [r3, #0]
 8005636:	68bb      	ldr	r3, [r7, #8]
 8005638:	1c99      	adds	r1, r3, #2
 800563a:	60b9      	str	r1, [r7, #8]
 800563c:	881b      	ldrh	r3, [r3, #0]
 800563e:	60d3      	str	r3, [r2, #12]
      hi2s->TxXferCount--;   
 8005640:	68fb      	ldr	r3, [r7, #12]
 8005642:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8005644:	b29b      	uxth	r3, r3
 8005646:	3b01      	subs	r3, #1
 8005648:	b29a      	uxth	r2, r3
 800564a:	68fb      	ldr	r3, [r7, #12]
 800564c:	855a      	strh	r2, [r3, #42]	; 0x2a
      /* Wait until TXE flag is set */
      if (I2S_WaitFlagStateUntilTimeout(hi2s, I2S_FLAG_TXE, RESET, Timeout) != HAL_OK)
 800564e:	68f8      	ldr	r0, [r7, #12]
 8005650:	2102      	movs	r1, #2
 8005652:	2200      	movs	r2, #0
 8005654:	683b      	ldr	r3, [r7, #0]
 8005656:	f000 fdf9 	bl	800624c <I2S_WaitFlagStateUntilTimeout>
 800565a:	4603      	mov	r3, r0
 800565c:	2b00      	cmp	r3, #0
 800565e:	d001      	beq.n	8005664 <HAL_I2S_Transmit+0xf0>
      {
        return HAL_TIMEOUT;
 8005660:	2303      	movs	r3, #3
 8005662:	e029      	b.n	80056b8 <HAL_I2S_Transmit+0x144>
    {
      /* Enable I2S peripheral */
      __HAL_I2S_ENABLE(hi2s);
    }
    
    while(hi2s->TxXferCount > 0)
 8005664:	68fb      	ldr	r3, [r7, #12]
 8005666:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8005668:	b29b      	uxth	r3, r3
 800566a:	2b00      	cmp	r3, #0
 800566c:	d1e1      	bne.n	8005632 <HAL_I2S_Transmit+0xbe>
      {
        return HAL_TIMEOUT;
      }
    } 
    /* Check if Slave mode is selected */
    if(((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG) == I2S_MODE_SLAVE_TX) || ((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG) == I2S_MODE_SLAVE_RX))
 800566e:	68fb      	ldr	r3, [r7, #12]
 8005670:	681b      	ldr	r3, [r3, #0]
 8005672:	69db      	ldr	r3, [r3, #28]
 8005674:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8005678:	2b00      	cmp	r3, #0
 800567a:	d007      	beq.n	800568c <HAL_I2S_Transmit+0x118>
 800567c:	68fb      	ldr	r3, [r7, #12]
 800567e:	681b      	ldr	r3, [r3, #0]
 8005680:	69db      	ldr	r3, [r3, #28]
 8005682:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8005686:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800568a:	d10a      	bne.n	80056a2 <HAL_I2S_Transmit+0x12e>
    {
      /* Wait until Busy flag is reset */
      if (I2S_WaitFlagStateUntilTimeout(hi2s, I2S_FLAG_BSY, SET, Timeout) != HAL_OK)
 800568c:	68f8      	ldr	r0, [r7, #12]
 800568e:	2180      	movs	r1, #128	; 0x80
 8005690:	2201      	movs	r2, #1
 8005692:	683b      	ldr	r3, [r7, #0]
 8005694:	f000 fdda 	bl	800624c <I2S_WaitFlagStateUntilTimeout>
 8005698:	4603      	mov	r3, r0
 800569a:	2b00      	cmp	r3, #0
 800569c:	d001      	beq.n	80056a2 <HAL_I2S_Transmit+0x12e>
      {
        return HAL_TIMEOUT;
 800569e:	2303      	movs	r3, #3
 80056a0:	e00a      	b.n	80056b8 <HAL_I2S_Transmit+0x144>
      }
    }
    hi2s->State = HAL_I2S_STATE_READY; 
 80056a2:	68fb      	ldr	r3, [r7, #12]
 80056a4:	2201      	movs	r2, #1
 80056a6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2s);
 80056aa:	68fb      	ldr	r3, [r7, #12]
 80056ac:	2200      	movs	r2, #0
 80056ae:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    
    return HAL_OK;
 80056b2:	2300      	movs	r3, #0
 80056b4:	e000      	b.n	80056b8 <HAL_I2S_Transmit+0x144>
  }
  else
  {
    return HAL_BUSY;
 80056b6:	2302      	movs	r3, #2
  }
}
 80056b8:	4618      	mov	r0, r3
 80056ba:	3718      	adds	r7, #24
 80056bc:	46bd      	mov	sp, r7
 80056be:	bd80      	pop	{r7, pc}

080056c0 <HAL_I2S_Receive>:
  * @note In I2S Master Receiver mode, just after enabling the peripheral the clock will be generate
  *       in continuous way and as the I2S is not disabled at the end of the I2S transaction.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2S_Receive(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size, uint32_t Timeout)
{
 80056c0:	b580      	push	{r7, lr}
 80056c2:	b088      	sub	sp, #32
 80056c4:	af00      	add	r7, sp, #0
 80056c6:	60f8      	str	r0, [r7, #12]
 80056c8:	60b9      	str	r1, [r7, #8]
 80056ca:	603b      	str	r3, [r7, #0]
 80056cc:	4613      	mov	r3, r2
 80056ce:	80fb      	strh	r3, [r7, #6]
  uint32_t tmp1 = 0, tmp2 = 0;   
 80056d0:	2300      	movs	r3, #0
 80056d2:	61fb      	str	r3, [r7, #28]
 80056d4:	2300      	movs	r3, #0
 80056d6:	61bb      	str	r3, [r7, #24]
  if((pData == NULL ) || (Size == 0)) 
 80056d8:	68bb      	ldr	r3, [r7, #8]
 80056da:	2b00      	cmp	r3, #0
 80056dc:	d002      	beq.n	80056e4 <HAL_I2S_Receive+0x24>
 80056de:	88fb      	ldrh	r3, [r7, #6]
 80056e0:	2b00      	cmp	r3, #0
 80056e2:	d101      	bne.n	80056e8 <HAL_I2S_Receive+0x28>
  {
    return  HAL_ERROR;
 80056e4:	2301      	movs	r3, #1
 80056e6:	e084      	b.n	80057f2 <HAL_I2S_Receive+0x132>
  }
  
  if(hi2s->State == HAL_I2S_STATE_READY)
 80056e8:	68fb      	ldr	r3, [r7, #12]
 80056ea:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80056ee:	b2db      	uxtb	r3, r3
 80056f0:	2b01      	cmp	r3, #1
 80056f2:	d17d      	bne.n	80057f0 <HAL_I2S_Receive+0x130>
  { 
    tmp1 = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 80056f4:	68fb      	ldr	r3, [r7, #12]
 80056f6:	681b      	ldr	r3, [r3, #0]
 80056f8:	69db      	ldr	r3, [r3, #28]
 80056fa:	f003 0307 	and.w	r3, r3, #7
 80056fe:	61fb      	str	r3, [r7, #28]
    tmp2 = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 8005700:	68fb      	ldr	r3, [r7, #12]
 8005702:	681b      	ldr	r3, [r3, #0]
 8005704:	69db      	ldr	r3, [r3, #28]
 8005706:	f003 0307 	and.w	r3, r3, #7
 800570a:	61bb      	str	r3, [r7, #24]
    if((tmp1 == I2S_DATAFORMAT_24B)|| \
 800570c:	69fb      	ldr	r3, [r7, #28]
 800570e:	2b03      	cmp	r3, #3
 8005710:	d002      	beq.n	8005718 <HAL_I2S_Receive+0x58>
 8005712:	69bb      	ldr	r3, [r7, #24]
 8005714:	2b05      	cmp	r3, #5
 8005716:	d10a      	bne.n	800572e <HAL_I2S_Receive+0x6e>
       (tmp2 == I2S_DATAFORMAT_32B))
    {
      hi2s->RxXferSize = Size*2;
 8005718:	88fb      	ldrh	r3, [r7, #6]
 800571a:	005b      	lsls	r3, r3, #1
 800571c:	b29a      	uxth	r2, r3
 800571e:	68fb      	ldr	r3, [r7, #12]
 8005720:	861a      	strh	r2, [r3, #48]	; 0x30
      hi2s->RxXferCount = Size*2;
 8005722:	88fb      	ldrh	r3, [r7, #6]
 8005724:	005b      	lsls	r3, r3, #1
 8005726:	b29a      	uxth	r2, r3
 8005728:	68fb      	ldr	r3, [r7, #12]
 800572a:	865a      	strh	r2, [r3, #50]	; 0x32
 800572c:	e005      	b.n	800573a <HAL_I2S_Receive+0x7a>
    }
    else
    {
      hi2s->RxXferSize = Size;
 800572e:	68fb      	ldr	r3, [r7, #12]
 8005730:	88fa      	ldrh	r2, [r7, #6]
 8005732:	861a      	strh	r2, [r3, #48]	; 0x30
      hi2s->RxXferCount = Size;
 8005734:	68fb      	ldr	r3, [r7, #12]
 8005736:	88fa      	ldrh	r2, [r7, #6]
 8005738:	865a      	strh	r2, [r3, #50]	; 0x32
    }
    /* Process Locked */
    __HAL_LOCK(hi2s);
 800573a:	68fb      	ldr	r3, [r7, #12]
 800573c:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8005740:	b2db      	uxtb	r3, r3
 8005742:	2b01      	cmp	r3, #1
 8005744:	d101      	bne.n	800574a <HAL_I2S_Receive+0x8a>
 8005746:	2302      	movs	r3, #2
 8005748:	e053      	b.n	80057f2 <HAL_I2S_Receive+0x132>
 800574a:	68fb      	ldr	r3, [r7, #12]
 800574c:	2201      	movs	r2, #1
 800574e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    hi2s->State = HAL_I2S_STATE_BUSY_RX;
 8005752:	68fb      	ldr	r3, [r7, #12]
 8005754:	2222      	movs	r2, #34	; 0x22
 8005756:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Check if the I2S is already enabled */ 
    if((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
 800575a:	68fb      	ldr	r3, [r7, #12]
 800575c:	681b      	ldr	r3, [r3, #0]
 800575e:	69db      	ldr	r3, [r3, #28]
 8005760:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8005764:	2b00      	cmp	r3, #0
 8005766:	d107      	bne.n	8005778 <HAL_I2S_Receive+0xb8>
    {
      /* Enable I2S peripheral */
      __HAL_I2S_ENABLE(hi2s);
 8005768:	68fb      	ldr	r3, [r7, #12]
 800576a:	681b      	ldr	r3, [r3, #0]
 800576c:	68fa      	ldr	r2, [r7, #12]
 800576e:	6812      	ldr	r2, [r2, #0]
 8005770:	69d2      	ldr	r2, [r2, #28]
 8005772:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8005776:	61da      	str	r2, [r3, #28]
    }

    /* Check if Master Receiver mode is selected */
    if((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG) == I2S_MODE_MASTER_RX)
 8005778:	68fb      	ldr	r3, [r7, #12]
 800577a:	681b      	ldr	r3, [r3, #0]
 800577c:	69db      	ldr	r3, [r3, #28]
 800577e:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8005782:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8005786:	d109      	bne.n	800579c <HAL_I2S_Receive+0xdc>
    {
      /* Clear the Overrun Flag by a read operation on the SPI_DR register followed by a read
      access to the SPI_SR register. */ 
      __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 8005788:	68fb      	ldr	r3, [r7, #12]
 800578a:	681b      	ldr	r3, [r3, #0]
 800578c:	68db      	ldr	r3, [r3, #12]
 800578e:	617b      	str	r3, [r7, #20]
 8005790:	68fb      	ldr	r3, [r7, #12]
 8005792:	681b      	ldr	r3, [r3, #0]
 8005794:	689b      	ldr	r3, [r3, #8]
 8005796:	617b      	str	r3, [r7, #20]
 8005798:	697b      	ldr	r3, [r7, #20]
    }

    /* Receive data */
    while(hi2s->RxXferCount > 0)
 800579a:	e01a      	b.n	80057d2 <HAL_I2S_Receive+0x112>
 800579c:	e019      	b.n	80057d2 <HAL_I2S_Receive+0x112>
    {
      /* Wait until RXNE flag is set */
      if (I2S_WaitFlagStateUntilTimeout(hi2s, I2S_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 800579e:	68f8      	ldr	r0, [r7, #12]
 80057a0:	2101      	movs	r1, #1
 80057a2:	2200      	movs	r2, #0
 80057a4:	683b      	ldr	r3, [r7, #0]
 80057a6:	f000 fd51 	bl	800624c <I2S_WaitFlagStateUntilTimeout>
 80057aa:	4603      	mov	r3, r0
 80057ac:	2b00      	cmp	r3, #0
 80057ae:	d001      	beq.n	80057b4 <HAL_I2S_Receive+0xf4>
      {
        return HAL_TIMEOUT;
 80057b0:	2303      	movs	r3, #3
 80057b2:	e01e      	b.n	80057f2 <HAL_I2S_Receive+0x132>
      }

      (*pData++) = hi2s->Instance->DR;
 80057b4:	68bb      	ldr	r3, [r7, #8]
 80057b6:	1c9a      	adds	r2, r3, #2
 80057b8:	60ba      	str	r2, [r7, #8]
 80057ba:	68fa      	ldr	r2, [r7, #12]
 80057bc:	6812      	ldr	r2, [r2, #0]
 80057be:	68d2      	ldr	r2, [r2, #12]
 80057c0:	b292      	uxth	r2, r2
 80057c2:	801a      	strh	r2, [r3, #0]
      hi2s->RxXferCount--;
 80057c4:	68fb      	ldr	r3, [r7, #12]
 80057c6:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 80057c8:	b29b      	uxth	r3, r3
 80057ca:	3b01      	subs	r3, #1
 80057cc:	b29a      	uxth	r2, r3
 80057ce:	68fb      	ldr	r3, [r7, #12]
 80057d0:	865a      	strh	r2, [r3, #50]	; 0x32
      access to the SPI_SR register. */ 
      __HAL_I2S_CLEAR_OVRFLAG(hi2s);
    }

    /* Receive data */
    while(hi2s->RxXferCount > 0)
 80057d2:	68fb      	ldr	r3, [r7, #12]
 80057d4:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 80057d6:	b29b      	uxth	r3, r3
 80057d8:	2b00      	cmp	r3, #0
 80057da:	d1e0      	bne.n	800579e <HAL_I2S_Receive+0xde>

      (*pData++) = hi2s->Instance->DR;
      hi2s->RxXferCount--;
    }

    hi2s->State = HAL_I2S_STATE_READY; 
 80057dc:	68fb      	ldr	r3, [r7, #12]
 80057de:	2201      	movs	r2, #1
 80057e0:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2s);
 80057e4:	68fb      	ldr	r3, [r7, #12]
 80057e6:	2200      	movs	r2, #0
 80057e8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    
    return HAL_OK;
 80057ec:	2300      	movs	r3, #0
 80057ee:	e000      	b.n	80057f2 <HAL_I2S_Receive+0x132>
  }
  else
  {
    return HAL_BUSY;
 80057f0:	2302      	movs	r3, #2
  }
}
 80057f2:	4618      	mov	r0, r3
 80057f4:	3720      	adds	r7, #32
 80057f6:	46bd      	mov	sp, r7
 80057f8:	bd80      	pop	{r7, pc}
 80057fa:	bf00      	nop

080057fc <HAL_I2S_Transmit_IT>:
  * @note The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization 
  *       between Master and Slave(example: audio streaming).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2S_Transmit_IT(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size)
{
 80057fc:	b480      	push	{r7}
 80057fe:	b087      	sub	sp, #28
 8005800:	af00      	add	r7, sp, #0
 8005802:	60f8      	str	r0, [r7, #12]
 8005804:	60b9      	str	r1, [r7, #8]
 8005806:	4613      	mov	r3, r2
 8005808:	80fb      	strh	r3, [r7, #6]
  uint32_t tmp1 = 0, tmp2 = 0;     
 800580a:	2300      	movs	r3, #0
 800580c:	617b      	str	r3, [r7, #20]
 800580e:	2300      	movs	r3, #0
 8005810:	613b      	str	r3, [r7, #16]
  if(hi2s->State == HAL_I2S_STATE_READY)
 8005812:	68fb      	ldr	r3, [r7, #12]
 8005814:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8005818:	b2db      	uxtb	r3, r3
 800581a:	2b01      	cmp	r3, #1
 800581c:	d15d      	bne.n	80058da <HAL_I2S_Transmit_IT+0xde>
  {
    if((pData == NULL) || (Size == 0)) 
 800581e:	68bb      	ldr	r3, [r7, #8]
 8005820:	2b00      	cmp	r3, #0
 8005822:	d002      	beq.n	800582a <HAL_I2S_Transmit_IT+0x2e>
 8005824:	88fb      	ldrh	r3, [r7, #6]
 8005826:	2b00      	cmp	r3, #0
 8005828:	d101      	bne.n	800582e <HAL_I2S_Transmit_IT+0x32>
    {
      return  HAL_ERROR;
 800582a:	2301      	movs	r3, #1
 800582c:	e056      	b.n	80058dc <HAL_I2S_Transmit_IT+0xe0>
    }

    hi2s->pTxBuffPtr = pData;
 800582e:	68fb      	ldr	r3, [r7, #12]
 8005830:	68ba      	ldr	r2, [r7, #8]
 8005832:	625a      	str	r2, [r3, #36]	; 0x24
    tmp1 = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 8005834:	68fb      	ldr	r3, [r7, #12]
 8005836:	681b      	ldr	r3, [r3, #0]
 8005838:	69db      	ldr	r3, [r3, #28]
 800583a:	f003 0307 	and.w	r3, r3, #7
 800583e:	617b      	str	r3, [r7, #20]
    tmp2 = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 8005840:	68fb      	ldr	r3, [r7, #12]
 8005842:	681b      	ldr	r3, [r3, #0]
 8005844:	69db      	ldr	r3, [r3, #28]
 8005846:	f003 0307 	and.w	r3, r3, #7
 800584a:	613b      	str	r3, [r7, #16]
    if((tmp1 == I2S_DATAFORMAT_24B)|| \
 800584c:	697b      	ldr	r3, [r7, #20]
 800584e:	2b03      	cmp	r3, #3
 8005850:	d002      	beq.n	8005858 <HAL_I2S_Transmit_IT+0x5c>
 8005852:	693b      	ldr	r3, [r7, #16]
 8005854:	2b05      	cmp	r3, #5
 8005856:	d10a      	bne.n	800586e <HAL_I2S_Transmit_IT+0x72>
      (tmp2 == I2S_DATAFORMAT_32B))
    {
      hi2s->TxXferSize = Size*2;
 8005858:	88fb      	ldrh	r3, [r7, #6]
 800585a:	005b      	lsls	r3, r3, #1
 800585c:	b29a      	uxth	r2, r3
 800585e:	68fb      	ldr	r3, [r7, #12]
 8005860:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2s->TxXferCount = Size*2;
 8005862:	88fb      	ldrh	r3, [r7, #6]
 8005864:	005b      	lsls	r3, r3, #1
 8005866:	b29a      	uxth	r2, r3
 8005868:	68fb      	ldr	r3, [r7, #12]
 800586a:	855a      	strh	r2, [r3, #42]	; 0x2a
 800586c:	e005      	b.n	800587a <HAL_I2S_Transmit_IT+0x7e>
    }
    else
    {
      hi2s->TxXferSize = Size;
 800586e:	68fb      	ldr	r3, [r7, #12]
 8005870:	88fa      	ldrh	r2, [r7, #6]
 8005872:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2s->TxXferCount = Size;
 8005874:	68fb      	ldr	r3, [r7, #12]
 8005876:	88fa      	ldrh	r2, [r7, #6]
 8005878:	855a      	strh	r2, [r3, #42]	; 0x2a
    }

    /* Process Locked */
    __HAL_LOCK(hi2s);
 800587a:	68fb      	ldr	r3, [r7, #12]
 800587c:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8005880:	b2db      	uxtb	r3, r3
 8005882:	2b01      	cmp	r3, #1
 8005884:	d101      	bne.n	800588a <HAL_I2S_Transmit_IT+0x8e>
 8005886:	2302      	movs	r3, #2
 8005888:	e028      	b.n	80058dc <HAL_I2S_Transmit_IT+0xe0>
 800588a:	68fb      	ldr	r3, [r7, #12]
 800588c:	2201      	movs	r2, #1
 800588e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    hi2s->State = HAL_I2S_STATE_BUSY_TX;
 8005892:	68fb      	ldr	r3, [r7, #12]
 8005894:	2212      	movs	r2, #18
 8005896:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
 800589a:	68fb      	ldr	r3, [r7, #12]
 800589c:	2200      	movs	r2, #0
 800589e:	641a      	str	r2, [r3, #64]	; 0x40

    /* Enable TXE and ERR interrupt */
    __HAL_I2S_ENABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 80058a0:	68fb      	ldr	r3, [r7, #12]
 80058a2:	681b      	ldr	r3, [r3, #0]
 80058a4:	68fa      	ldr	r2, [r7, #12]
 80058a6:	6812      	ldr	r2, [r2, #0]
 80058a8:	6852      	ldr	r2, [r2, #4]
 80058aa:	f042 02a0 	orr.w	r2, r2, #160	; 0xa0
 80058ae:	605a      	str	r2, [r3, #4]

    /* Check if the I2S is already enabled */ 
    if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
 80058b0:	68fb      	ldr	r3, [r7, #12]
 80058b2:	681b      	ldr	r3, [r3, #0]
 80058b4:	69db      	ldr	r3, [r3, #28]
 80058b6:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80058ba:	2b00      	cmp	r3, #0
 80058bc:	d107      	bne.n	80058ce <HAL_I2S_Transmit_IT+0xd2>
    {
      /* Enable I2S peripheral */
      __HAL_I2S_ENABLE(hi2s);
 80058be:	68fb      	ldr	r3, [r7, #12]
 80058c0:	681b      	ldr	r3, [r3, #0]
 80058c2:	68fa      	ldr	r2, [r7, #12]
 80058c4:	6812      	ldr	r2, [r2, #0]
 80058c6:	69d2      	ldr	r2, [r2, #28]
 80058c8:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80058cc:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2s);
 80058ce:	68fb      	ldr	r3, [r7, #12]
 80058d0:	2200      	movs	r2, #0
 80058d2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    
    return HAL_OK;
 80058d6:	2300      	movs	r3, #0
 80058d8:	e000      	b.n	80058dc <HAL_I2S_Transmit_IT+0xe0>
  }
  else
  {
    return HAL_BUSY;
 80058da:	2302      	movs	r3, #2
  }
}
 80058dc:	4618      	mov	r0, r3
 80058de:	371c      	adds	r7, #28
 80058e0:	46bd      	mov	sp, r7
 80058e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80058e6:	4770      	bx	lr

080058e8 <HAL_I2S_Receive_IT>:
  * @note It is recommended to use DMA for the I2S receiver to avoid de-synchronisation 
  * between Master and Slave otherwise the I2S interrupt should be optimized. 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2S_Receive_IT(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size)
{
 80058e8:	b480      	push	{r7}
 80058ea:	b087      	sub	sp, #28
 80058ec:	af00      	add	r7, sp, #0
 80058ee:	60f8      	str	r0, [r7, #12]
 80058f0:	60b9      	str	r1, [r7, #8]
 80058f2:	4613      	mov	r3, r2
 80058f4:	80fb      	strh	r3, [r7, #6]
  uint32_t tmp1 = 0, tmp2 = 0;     
 80058f6:	2300      	movs	r3, #0
 80058f8:	617b      	str	r3, [r7, #20]
 80058fa:	2300      	movs	r3, #0
 80058fc:	613b      	str	r3, [r7, #16]
  if(hi2s->State == HAL_I2S_STATE_READY)
 80058fe:	68fb      	ldr	r3, [r7, #12]
 8005900:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8005904:	b2db      	uxtb	r3, r3
 8005906:	2b01      	cmp	r3, #1
 8005908:	d15d      	bne.n	80059c6 <HAL_I2S_Receive_IT+0xde>
  {
    if((pData == NULL) || (Size == 0)) 
 800590a:	68bb      	ldr	r3, [r7, #8]
 800590c:	2b00      	cmp	r3, #0
 800590e:	d002      	beq.n	8005916 <HAL_I2S_Receive_IT+0x2e>
 8005910:	88fb      	ldrh	r3, [r7, #6]
 8005912:	2b00      	cmp	r3, #0
 8005914:	d101      	bne.n	800591a <HAL_I2S_Receive_IT+0x32>
    {
      return  HAL_ERROR;
 8005916:	2301      	movs	r3, #1
 8005918:	e056      	b.n	80059c8 <HAL_I2S_Receive_IT+0xe0>
    }

    hi2s->pRxBuffPtr = pData;
 800591a:	68fb      	ldr	r3, [r7, #12]
 800591c:	68ba      	ldr	r2, [r7, #8]
 800591e:	62da      	str	r2, [r3, #44]	; 0x2c
    tmp1 = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 8005920:	68fb      	ldr	r3, [r7, #12]
 8005922:	681b      	ldr	r3, [r3, #0]
 8005924:	69db      	ldr	r3, [r3, #28]
 8005926:	f003 0307 	and.w	r3, r3, #7
 800592a:	617b      	str	r3, [r7, #20]
    tmp2 = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 800592c:	68fb      	ldr	r3, [r7, #12]
 800592e:	681b      	ldr	r3, [r3, #0]
 8005930:	69db      	ldr	r3, [r3, #28]
 8005932:	f003 0307 	and.w	r3, r3, #7
 8005936:	613b      	str	r3, [r7, #16]
    if((tmp1 == I2S_DATAFORMAT_24B)||\
 8005938:	697b      	ldr	r3, [r7, #20]
 800593a:	2b03      	cmp	r3, #3
 800593c:	d002      	beq.n	8005944 <HAL_I2S_Receive_IT+0x5c>
 800593e:	693b      	ldr	r3, [r7, #16]
 8005940:	2b05      	cmp	r3, #5
 8005942:	d10a      	bne.n	800595a <HAL_I2S_Receive_IT+0x72>
      (tmp2 == I2S_DATAFORMAT_32B))
    {
      hi2s->RxXferSize = Size*2;
 8005944:	88fb      	ldrh	r3, [r7, #6]
 8005946:	005b      	lsls	r3, r3, #1
 8005948:	b29a      	uxth	r2, r3
 800594a:	68fb      	ldr	r3, [r7, #12]
 800594c:	861a      	strh	r2, [r3, #48]	; 0x30
      hi2s->RxXferCount = Size*2;
 800594e:	88fb      	ldrh	r3, [r7, #6]
 8005950:	005b      	lsls	r3, r3, #1
 8005952:	b29a      	uxth	r2, r3
 8005954:	68fb      	ldr	r3, [r7, #12]
 8005956:	865a      	strh	r2, [r3, #50]	; 0x32
 8005958:	e005      	b.n	8005966 <HAL_I2S_Receive_IT+0x7e>
    }
    else
    {
      hi2s->RxXferSize = Size;
 800595a:	68fb      	ldr	r3, [r7, #12]
 800595c:	88fa      	ldrh	r2, [r7, #6]
 800595e:	861a      	strh	r2, [r3, #48]	; 0x30
      hi2s->RxXferCount = Size;
 8005960:	68fb      	ldr	r3, [r7, #12]
 8005962:	88fa      	ldrh	r2, [r7, #6]
 8005964:	865a      	strh	r2, [r3, #50]	; 0x32
    }
    /* Process Locked */
    __HAL_LOCK(hi2s);
 8005966:	68fb      	ldr	r3, [r7, #12]
 8005968:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 800596c:	b2db      	uxtb	r3, r3
 800596e:	2b01      	cmp	r3, #1
 8005970:	d101      	bne.n	8005976 <HAL_I2S_Receive_IT+0x8e>
 8005972:	2302      	movs	r3, #2
 8005974:	e028      	b.n	80059c8 <HAL_I2S_Receive_IT+0xe0>
 8005976:	68fb      	ldr	r3, [r7, #12]
 8005978:	2201      	movs	r2, #1
 800597a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    
    hi2s->State = HAL_I2S_STATE_BUSY_RX;
 800597e:	68fb      	ldr	r3, [r7, #12]
 8005980:	2222      	movs	r2, #34	; 0x22
 8005982:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
 8005986:	68fb      	ldr	r3, [r7, #12]
 8005988:	2200      	movs	r2, #0
 800598a:	641a      	str	r2, [r3, #64]	; 0x40
    
    /* Enable TXE and ERR interrupt */
    __HAL_I2S_ENABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 800598c:	68fb      	ldr	r3, [r7, #12]
 800598e:	681b      	ldr	r3, [r3, #0]
 8005990:	68fa      	ldr	r2, [r7, #12]
 8005992:	6812      	ldr	r2, [r2, #0]
 8005994:	6852      	ldr	r2, [r2, #4]
 8005996:	f042 0260 	orr.w	r2, r2, #96	; 0x60
 800599a:	605a      	str	r2, [r3, #4]
    
    /* Check if the I2S is already enabled */ 
    if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
 800599c:	68fb      	ldr	r3, [r7, #12]
 800599e:	681b      	ldr	r3, [r3, #0]
 80059a0:	69db      	ldr	r3, [r3, #28]
 80059a2:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80059a6:	2b00      	cmp	r3, #0
 80059a8:	d107      	bne.n	80059ba <HAL_I2S_Receive_IT+0xd2>
    {
      /* Enable I2S peripheral */
      __HAL_I2S_ENABLE(hi2s);
 80059aa:	68fb      	ldr	r3, [r7, #12]
 80059ac:	681b      	ldr	r3, [r3, #0]
 80059ae:	68fa      	ldr	r2, [r7, #12]
 80059b0:	6812      	ldr	r2, [r2, #0]
 80059b2:	69d2      	ldr	r2, [r2, #28]
 80059b4:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80059b8:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2s);
 80059ba:	68fb      	ldr	r3, [r7, #12]
 80059bc:	2200      	movs	r2, #0
 80059be:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    return HAL_OK;
 80059c2:	2300      	movs	r3, #0
 80059c4:	e000      	b.n	80059c8 <HAL_I2S_Receive_IT+0xe0>
  }

  else
  {
    return HAL_BUSY; 
 80059c6:	2302      	movs	r3, #2
  } 
}
 80059c8:	4618      	mov	r0, r3
 80059ca:	371c      	adds	r7, #28
 80059cc:	46bd      	mov	sp, r7
 80059ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80059d2:	4770      	bx	lr

080059d4 <HAL_I2S_Transmit_DMA>:
  * @note The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization 
  *       between Master and Slave(example: audio streaming).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2S_Transmit_DMA(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size)
{
 80059d4:	b580      	push	{r7, lr}
 80059d6:	b088      	sub	sp, #32
 80059d8:	af00      	add	r7, sp, #0
 80059da:	60f8      	str	r0, [r7, #12]
 80059dc:	60b9      	str	r1, [r7, #8]
 80059de:	4613      	mov	r3, r2
 80059e0:	80fb      	strh	r3, [r7, #6]
  uint32_t *tmp;
  uint32_t tmp1 = 0, tmp2 = 0;     
 80059e2:	2300      	movs	r3, #0
 80059e4:	61fb      	str	r3, [r7, #28]
 80059e6:	2300      	movs	r3, #0
 80059e8:	61bb      	str	r3, [r7, #24]
  
  if((pData == NULL) || (Size == 0)) 
 80059ea:	68bb      	ldr	r3, [r7, #8]
 80059ec:	2b00      	cmp	r3, #0
 80059ee:	d002      	beq.n	80059f6 <HAL_I2S_Transmit_DMA+0x22>
 80059f0:	88fb      	ldrh	r3, [r7, #6]
 80059f2:	2b00      	cmp	r3, #0
 80059f4:	d101      	bne.n	80059fa <HAL_I2S_Transmit_DMA+0x26>
  {
    return  HAL_ERROR;
 80059f6:	2301      	movs	r3, #1
 80059f8:	e089      	b.n	8005b0e <HAL_I2S_Transmit_DMA+0x13a>
  }

  if(hi2s->State == HAL_I2S_STATE_READY)
 80059fa:	68fb      	ldr	r3, [r7, #12]
 80059fc:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8005a00:	b2db      	uxtb	r3, r3
 8005a02:	2b01      	cmp	r3, #1
 8005a04:	f040 8082 	bne.w	8005b0c <HAL_I2S_Transmit_DMA+0x138>
  {  
    hi2s->pTxBuffPtr = pData;
 8005a08:	68ba      	ldr	r2, [r7, #8]
 8005a0a:	68fb      	ldr	r3, [r7, #12]
 8005a0c:	625a      	str	r2, [r3, #36]	; 0x24
    tmp1 = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 8005a0e:	68fb      	ldr	r3, [r7, #12]
 8005a10:	681b      	ldr	r3, [r3, #0]
 8005a12:	69db      	ldr	r3, [r3, #28]
 8005a14:	f003 0307 	and.w	r3, r3, #7
 8005a18:	61fb      	str	r3, [r7, #28]
    tmp2 = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 8005a1a:	68fb      	ldr	r3, [r7, #12]
 8005a1c:	681b      	ldr	r3, [r3, #0]
 8005a1e:	69db      	ldr	r3, [r3, #28]
 8005a20:	f003 0307 	and.w	r3, r3, #7
 8005a24:	61bb      	str	r3, [r7, #24]
    if((tmp1 == I2S_DATAFORMAT_24B)|| \
 8005a26:	69fb      	ldr	r3, [r7, #28]
 8005a28:	2b03      	cmp	r3, #3
 8005a2a:	d002      	beq.n	8005a32 <HAL_I2S_Transmit_DMA+0x5e>
 8005a2c:	69bb      	ldr	r3, [r7, #24]
 8005a2e:	2b05      	cmp	r3, #5
 8005a30:	d10a      	bne.n	8005a48 <HAL_I2S_Transmit_DMA+0x74>
      (tmp2 == I2S_DATAFORMAT_32B))
    {
      hi2s->TxXferSize = Size*2;
 8005a32:	88fb      	ldrh	r3, [r7, #6]
 8005a34:	005b      	lsls	r3, r3, #1
 8005a36:	b29a      	uxth	r2, r3
 8005a38:	68fb      	ldr	r3, [r7, #12]
 8005a3a:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2s->TxXferCount = Size*2;
 8005a3c:	88fb      	ldrh	r3, [r7, #6]
 8005a3e:	005b      	lsls	r3, r3, #1
 8005a40:	b29a      	uxth	r2, r3
 8005a42:	68fb      	ldr	r3, [r7, #12]
 8005a44:	855a      	strh	r2, [r3, #42]	; 0x2a
 8005a46:	e005      	b.n	8005a54 <HAL_I2S_Transmit_DMA+0x80>
    }
    else
    {
      hi2s->TxXferSize = Size;
 8005a48:	68fb      	ldr	r3, [r7, #12]
 8005a4a:	88fa      	ldrh	r2, [r7, #6]
 8005a4c:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2s->TxXferCount = Size;
 8005a4e:	68fb      	ldr	r3, [r7, #12]
 8005a50:	88fa      	ldrh	r2, [r7, #6]
 8005a52:	855a      	strh	r2, [r3, #42]	; 0x2a
    }

    /* Process Locked */
    __HAL_LOCK(hi2s);
 8005a54:	68fb      	ldr	r3, [r7, #12]
 8005a56:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8005a5a:	b2db      	uxtb	r3, r3
 8005a5c:	2b01      	cmp	r3, #1
 8005a5e:	d101      	bne.n	8005a64 <HAL_I2S_Transmit_DMA+0x90>
 8005a60:	2302      	movs	r3, #2
 8005a62:	e054      	b.n	8005b0e <HAL_I2S_Transmit_DMA+0x13a>
 8005a64:	68fb      	ldr	r3, [r7, #12]
 8005a66:	2201      	movs	r2, #1
 8005a68:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    hi2s->State = HAL_I2S_STATE_BUSY_TX;
 8005a6c:	68fb      	ldr	r3, [r7, #12]
 8005a6e:	2212      	movs	r2, #18
 8005a70:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
 8005a74:	68fb      	ldr	r3, [r7, #12]
 8005a76:	2200      	movs	r2, #0
 8005a78:	641a      	str	r2, [r3, #64]	; 0x40

    /* Set the I2S Tx DMA Half transfer complete callback */
    hi2s->hdmatx->XferHalfCpltCallback = I2S_DMATxHalfCplt;
 8005a7a:	68fb      	ldr	r3, [r7, #12]
 8005a7c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8005a7e:	f246 038d 	movw	r3, #24717	; 0x608d
 8005a82:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005a86:	6413      	str	r3, [r2, #64]	; 0x40

    /* Set the I2S Tx DMA transfer complete callback */
    hi2s->hdmatx->XferCpltCallback = I2S_DMATxCplt;
 8005a88:	68fb      	ldr	r3, [r7, #12]
 8005a8a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8005a8c:	f647 4335 	movw	r3, #31797	; 0x7c35
 8005a90:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005a94:	63d3      	str	r3, [r2, #60]	; 0x3c

    /* Set the DMA error callback */
    hi2s->hdmatx->XferErrorCallback = I2S_DMAError;
 8005a96:	68fb      	ldr	r3, [r7, #12]
 8005a98:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8005a9a:	f246 03c5 	movw	r3, #24773	; 0x60c5
 8005a9e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005aa2:	6493      	str	r3, [r2, #72]	; 0x48

    /* Enable the Tx DMA Stream */
    tmp = (uint32_t*)&pData;
 8005aa4:	f107 0308 	add.w	r3, r7, #8
 8005aa8:	617b      	str	r3, [r7, #20]
    HAL_DMA_Start_IT(hi2s->hdmatx, *(uint32_t*)tmp, (uint32_t)&hi2s->Instance->DR, hi2s->TxXferSize);
 8005aaa:	68fb      	ldr	r3, [r7, #12]
 8005aac:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8005aae:	697b      	ldr	r3, [r7, #20]
 8005ab0:	6819      	ldr	r1, [r3, #0]
 8005ab2:	68fb      	ldr	r3, [r7, #12]
 8005ab4:	681b      	ldr	r3, [r3, #0]
 8005ab6:	330c      	adds	r3, #12
 8005ab8:	461a      	mov	r2, r3
 8005aba:	68fb      	ldr	r3, [r7, #12]
 8005abc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8005abe:	b29b      	uxth	r3, r3
 8005ac0:	f7fe fd72 	bl	80045a8 <HAL_DMA_Start_IT>

    /* Check if the I2S is already enabled */ 
    if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
 8005ac4:	68fb      	ldr	r3, [r7, #12]
 8005ac6:	681b      	ldr	r3, [r3, #0]
 8005ac8:	69db      	ldr	r3, [r3, #28]
 8005aca:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8005ace:	2b00      	cmp	r3, #0
 8005ad0:	d107      	bne.n	8005ae2 <HAL_I2S_Transmit_DMA+0x10e>
    {
      /* Enable I2S peripheral */
      __HAL_I2S_ENABLE(hi2s);
 8005ad2:	68fb      	ldr	r3, [r7, #12]
 8005ad4:	681b      	ldr	r3, [r3, #0]
 8005ad6:	68fa      	ldr	r2, [r7, #12]
 8005ad8:	6812      	ldr	r2, [r2, #0]
 8005ada:	69d2      	ldr	r2, [r2, #28]
 8005adc:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8005ae0:	61da      	str	r2, [r3, #28]
    }

     /* Check if the I2S Tx request is already enabled */ 
    if((hi2s->Instance->CR2 & SPI_CR2_TXDMAEN) != SPI_CR2_TXDMAEN)
 8005ae2:	68fb      	ldr	r3, [r7, #12]
 8005ae4:	681b      	ldr	r3, [r3, #0]
 8005ae6:	685b      	ldr	r3, [r3, #4]
 8005ae8:	f003 0302 	and.w	r3, r3, #2
 8005aec:	2b00      	cmp	r3, #0
 8005aee:	d107      	bne.n	8005b00 <HAL_I2S_Transmit_DMA+0x12c>
    {
      /* Enable Tx DMA Request */  
      hi2s->Instance->CR2 |= SPI_CR2_TXDMAEN;
 8005af0:	68fb      	ldr	r3, [r7, #12]
 8005af2:	681b      	ldr	r3, [r3, #0]
 8005af4:	68fa      	ldr	r2, [r7, #12]
 8005af6:	6812      	ldr	r2, [r2, #0]
 8005af8:	6852      	ldr	r2, [r2, #4]
 8005afa:	f042 0202 	orr.w	r2, r2, #2
 8005afe:	605a      	str	r2, [r3, #4]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2s);
 8005b00:	68fb      	ldr	r3, [r7, #12]
 8005b02:	2200      	movs	r2, #0
 8005b04:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    
    return HAL_OK;
 8005b08:	2300      	movs	r3, #0
 8005b0a:	e000      	b.n	8005b0e <HAL_I2S_Transmit_DMA+0x13a>
  }
  else
  {
    return HAL_BUSY;
 8005b0c:	2302      	movs	r3, #2
  }
}
 8005b0e:	4618      	mov	r0, r3
 8005b10:	3720      	adds	r7, #32
 8005b12:	46bd      	mov	sp, r7
 8005b14:	bd80      	pop	{r7, pc}
 8005b16:	bf00      	nop

08005b18 <HAL_I2S_Receive_DMA>:
  * @note The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization 
  *       between Master and Slave(example: audio streaming).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2S_Receive_DMA(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size)
{
 8005b18:	b580      	push	{r7, lr}
 8005b1a:	b088      	sub	sp, #32
 8005b1c:	af00      	add	r7, sp, #0
 8005b1e:	60f8      	str	r0, [r7, #12]
 8005b20:	60b9      	str	r1, [r7, #8]
 8005b22:	4613      	mov	r3, r2
 8005b24:	80fb      	strh	r3, [r7, #6]
  uint32_t *tmp;
  uint32_t tmp1 = 0, tmp2 = 0;  
 8005b26:	2300      	movs	r3, #0
 8005b28:	61fb      	str	r3, [r7, #28]
 8005b2a:	2300      	movs	r3, #0
 8005b2c:	61bb      	str	r3, [r7, #24]
  
  if((pData == NULL) || (Size == 0))
 8005b2e:	68bb      	ldr	r3, [r7, #8]
 8005b30:	2b00      	cmp	r3, #0
 8005b32:	d002      	beq.n	8005b3a <HAL_I2S_Receive_DMA+0x22>
 8005b34:	88fb      	ldrh	r3, [r7, #6]
 8005b36:	2b00      	cmp	r3, #0
 8005b38:	d101      	bne.n	8005b3e <HAL_I2S_Receive_DMA+0x26>
  {
    return  HAL_ERROR;
 8005b3a:	2301      	movs	r3, #1
 8005b3c:	e09a      	b.n	8005c74 <HAL_I2S_Receive_DMA+0x15c>
  }

  if(hi2s->State == HAL_I2S_STATE_READY)
 8005b3e:	68fb      	ldr	r3, [r7, #12]
 8005b40:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8005b44:	b2db      	uxtb	r3, r3
 8005b46:	2b01      	cmp	r3, #1
 8005b48:	f040 8093 	bne.w	8005c72 <HAL_I2S_Receive_DMA+0x15a>
  {
    hi2s->pRxBuffPtr = pData;
 8005b4c:	68ba      	ldr	r2, [r7, #8]
 8005b4e:	68fb      	ldr	r3, [r7, #12]
 8005b50:	62da      	str	r2, [r3, #44]	; 0x2c
    tmp1 = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 8005b52:	68fb      	ldr	r3, [r7, #12]
 8005b54:	681b      	ldr	r3, [r3, #0]
 8005b56:	69db      	ldr	r3, [r3, #28]
 8005b58:	f003 0307 	and.w	r3, r3, #7
 8005b5c:	61fb      	str	r3, [r7, #28]
    tmp2 = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 8005b5e:	68fb      	ldr	r3, [r7, #12]
 8005b60:	681b      	ldr	r3, [r3, #0]
 8005b62:	69db      	ldr	r3, [r3, #28]
 8005b64:	f003 0307 	and.w	r3, r3, #7
 8005b68:	61bb      	str	r3, [r7, #24]
    if((tmp1 == I2S_DATAFORMAT_24B)|| \
 8005b6a:	69fb      	ldr	r3, [r7, #28]
 8005b6c:	2b03      	cmp	r3, #3
 8005b6e:	d002      	beq.n	8005b76 <HAL_I2S_Receive_DMA+0x5e>
 8005b70:	69bb      	ldr	r3, [r7, #24]
 8005b72:	2b05      	cmp	r3, #5
 8005b74:	d10a      	bne.n	8005b8c <HAL_I2S_Receive_DMA+0x74>
      (tmp2 == I2S_DATAFORMAT_32B))
    {
      hi2s->RxXferSize = Size*2;
 8005b76:	88fb      	ldrh	r3, [r7, #6]
 8005b78:	005b      	lsls	r3, r3, #1
 8005b7a:	b29a      	uxth	r2, r3
 8005b7c:	68fb      	ldr	r3, [r7, #12]
 8005b7e:	861a      	strh	r2, [r3, #48]	; 0x30
      hi2s->RxXferCount = Size*2;
 8005b80:	88fb      	ldrh	r3, [r7, #6]
 8005b82:	005b      	lsls	r3, r3, #1
 8005b84:	b29a      	uxth	r2, r3
 8005b86:	68fb      	ldr	r3, [r7, #12]
 8005b88:	865a      	strh	r2, [r3, #50]	; 0x32
 8005b8a:	e005      	b.n	8005b98 <HAL_I2S_Receive_DMA+0x80>
    }
    else
    {
      hi2s->RxXferSize = Size;
 8005b8c:	68fb      	ldr	r3, [r7, #12]
 8005b8e:	88fa      	ldrh	r2, [r7, #6]
 8005b90:	861a      	strh	r2, [r3, #48]	; 0x30
      hi2s->RxXferCount = Size;
 8005b92:	68fb      	ldr	r3, [r7, #12]
 8005b94:	88fa      	ldrh	r2, [r7, #6]
 8005b96:	865a      	strh	r2, [r3, #50]	; 0x32
    }
    /* Process Locked */
    __HAL_LOCK(hi2s);
 8005b98:	68fb      	ldr	r3, [r7, #12]
 8005b9a:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8005b9e:	b2db      	uxtb	r3, r3
 8005ba0:	2b01      	cmp	r3, #1
 8005ba2:	d101      	bne.n	8005ba8 <HAL_I2S_Receive_DMA+0x90>
 8005ba4:	2302      	movs	r3, #2
 8005ba6:	e065      	b.n	8005c74 <HAL_I2S_Receive_DMA+0x15c>
 8005ba8:	68fb      	ldr	r3, [r7, #12]
 8005baa:	2201      	movs	r2, #1
 8005bac:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    
    hi2s->State = HAL_I2S_STATE_BUSY_RX;
 8005bb0:	68fb      	ldr	r3, [r7, #12]
 8005bb2:	2222      	movs	r2, #34	; 0x22
 8005bb4:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
 8005bb8:	68fb      	ldr	r3, [r7, #12]
 8005bba:	2200      	movs	r2, #0
 8005bbc:	641a      	str	r2, [r3, #64]	; 0x40
    
    /* Set the I2S Rx DMA Half transfer complete callback */
    hi2s->hdmarx->XferHalfCpltCallback = I2S_DMARxHalfCplt;
 8005bbe:	68fb      	ldr	r3, [r7, #12]
 8005bc0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8005bc2:	f246 03a9 	movw	r3, #24745	; 0x60a9
 8005bc6:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005bca:	6413      	str	r3, [r2, #64]	; 0x40
    
    /* Set the I2S Rx DMA transfer complete callback */
    hi2s->hdmarx->XferCpltCallback = I2S_DMARxCplt;
 8005bcc:	68fb      	ldr	r3, [r7, #12]
 8005bce:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8005bd0:	f647 43e9 	movw	r3, #31977	; 0x7ce9
 8005bd4:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005bd8:	63d3      	str	r3, [r2, #60]	; 0x3c
    
    /* Set the DMA error callback */
    hi2s->hdmarx->XferErrorCallback = I2S_DMAError;
 8005bda:	68fb      	ldr	r3, [r7, #12]
 8005bdc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8005bde:	f246 03c5 	movw	r3, #24773	; 0x60c5
 8005be2:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005be6:	6493      	str	r3, [r2, #72]	; 0x48
    
    /* Check if Master Receiver mode is selected */
    if((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG) == I2S_MODE_MASTER_RX)
 8005be8:	68fb      	ldr	r3, [r7, #12]
 8005bea:	681b      	ldr	r3, [r3, #0]
 8005bec:	69db      	ldr	r3, [r3, #28]
 8005bee:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8005bf2:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8005bf6:	d108      	bne.n	8005c0a <HAL_I2S_Receive_DMA+0xf2>
    {
      /* Clear the Overrun Flag by a read operation to the SPI_DR register followed by a read
      access to the SPI_SR register. */ 
      __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 8005bf8:	68fb      	ldr	r3, [r7, #12]
 8005bfa:	681b      	ldr	r3, [r3, #0]
 8005bfc:	68db      	ldr	r3, [r3, #12]
 8005bfe:	613b      	str	r3, [r7, #16]
 8005c00:	68fb      	ldr	r3, [r7, #12]
 8005c02:	681b      	ldr	r3, [r3, #0]
 8005c04:	689b      	ldr	r3, [r3, #8]
 8005c06:	613b      	str	r3, [r7, #16]
 8005c08:	693b      	ldr	r3, [r7, #16]
    }
    
    /* Enable the Rx DMA Stream */
    tmp = (uint32_t*)&pData;
 8005c0a:	f107 0308 	add.w	r3, r7, #8
 8005c0e:	617b      	str	r3, [r7, #20]
    HAL_DMA_Start_IT(hi2s->hdmarx, (uint32_t)&hi2s->Instance->DR, *(uint32_t*)tmp, hi2s->RxXferSize);
 8005c10:	68fb      	ldr	r3, [r7, #12]
 8005c12:	6b98      	ldr	r0, [r3, #56]	; 0x38
 8005c14:	68fb      	ldr	r3, [r7, #12]
 8005c16:	681b      	ldr	r3, [r3, #0]
 8005c18:	330c      	adds	r3, #12
 8005c1a:	4619      	mov	r1, r3
 8005c1c:	697b      	ldr	r3, [r7, #20]
 8005c1e:	681a      	ldr	r2, [r3, #0]
 8005c20:	68fb      	ldr	r3, [r7, #12]
 8005c22:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 8005c24:	b29b      	uxth	r3, r3
 8005c26:	f7fe fcbf 	bl	80045a8 <HAL_DMA_Start_IT>
    
    /* Check if the I2S is already enabled */ 
    if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
 8005c2a:	68fb      	ldr	r3, [r7, #12]
 8005c2c:	681b      	ldr	r3, [r3, #0]
 8005c2e:	69db      	ldr	r3, [r3, #28]
 8005c30:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8005c34:	2b00      	cmp	r3, #0
 8005c36:	d107      	bne.n	8005c48 <HAL_I2S_Receive_DMA+0x130>
    {
      /* Enable I2S peripheral */
      __HAL_I2S_ENABLE(hi2s);
 8005c38:	68fb      	ldr	r3, [r7, #12]
 8005c3a:	681b      	ldr	r3, [r3, #0]
 8005c3c:	68fa      	ldr	r2, [r7, #12]
 8005c3e:	6812      	ldr	r2, [r2, #0]
 8005c40:	69d2      	ldr	r2, [r2, #28]
 8005c42:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8005c46:	61da      	str	r2, [r3, #28]
    }

     /* Check if the I2S Rx request is already enabled */ 
    if((hi2s->Instance->CR2 &SPI_CR2_RXDMAEN) != SPI_CR2_RXDMAEN)
 8005c48:	68fb      	ldr	r3, [r7, #12]
 8005c4a:	681b      	ldr	r3, [r3, #0]
 8005c4c:	685b      	ldr	r3, [r3, #4]
 8005c4e:	f003 0301 	and.w	r3, r3, #1
 8005c52:	2b00      	cmp	r3, #0
 8005c54:	d107      	bne.n	8005c66 <HAL_I2S_Receive_DMA+0x14e>
    {
      /* Enable Rx DMA Request */  
      hi2s->Instance->CR2 |= SPI_CR2_RXDMAEN;
 8005c56:	68fb      	ldr	r3, [r7, #12]
 8005c58:	681b      	ldr	r3, [r3, #0]
 8005c5a:	68fa      	ldr	r2, [r7, #12]
 8005c5c:	6812      	ldr	r2, [r2, #0]
 8005c5e:	6852      	ldr	r2, [r2, #4]
 8005c60:	f042 0201 	orr.w	r2, r2, #1
 8005c64:	605a      	str	r2, [r3, #4]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2s);
 8005c66:	68fb      	ldr	r3, [r7, #12]
 8005c68:	2200      	movs	r2, #0
 8005c6a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    return HAL_OK;
 8005c6e:	2300      	movs	r3, #0
 8005c70:	e000      	b.n	8005c74 <HAL_I2S_Receive_DMA+0x15c>
  }
  else
  {
    return HAL_BUSY;
 8005c72:	2302      	movs	r3, #2
  }
}
 8005c74:	4618      	mov	r0, r3
 8005c76:	3720      	adds	r7, #32
 8005c78:	46bd      	mov	sp, r7
 8005c7a:	bd80      	pop	{r7, pc}
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_I2S_DMAPause(I2S_HandleTypeDef *hi2s)
{
 8005c7c:	b480      	push	{r7}
 8005c7e:	b083      	sub	sp, #12
 8005c80:	af00      	add	r7, sp, #0
 8005c82:	6078      	str	r0, [r7, #4]
  /* Process Locked */
  __HAL_LOCK(hi2s);
 8005c84:	687b      	ldr	r3, [r7, #4]
 8005c86:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8005c8a:	b2db      	uxtb	r3, r3
 8005c8c:	2b01      	cmp	r3, #1
 8005c8e:	d101      	bne.n	8005c94 <HAL_I2S_Receive_DMA+0x17c>
 8005c90:	2302      	movs	r3, #2
 8005c92:	e046      	b.n	8005d22 <HAL_I2S_Receive_DMA+0x20a>
 8005c94:	687b      	ldr	r3, [r7, #4]
 8005c96:	2201      	movs	r2, #1
 8005c98:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  if(hi2s->State == HAL_I2S_STATE_BUSY_TX)
 8005c9c:	687b      	ldr	r3, [r7, #4]
 8005c9e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8005ca2:	b2db      	uxtb	r3, r3
 8005ca4:	2b12      	cmp	r3, #18
 8005ca6:	d108      	bne.n	8005cba <HAL_I2S_Receive_DMA+0x1a2>
  {
    /* Disable the I2S DMA Tx request */
    hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
 8005ca8:	687b      	ldr	r3, [r7, #4]
 8005caa:	681b      	ldr	r3, [r3, #0]
 8005cac:	687a      	ldr	r2, [r7, #4]
 8005cae:	6812      	ldr	r2, [r2, #0]
 8005cb0:	6852      	ldr	r2, [r2, #4]
 8005cb2:	f022 0202 	bic.w	r2, r2, #2
 8005cb6:	605a      	str	r2, [r3, #4]
 8005cb8:	e02e      	b.n	8005d18 <HAL_I2S_Receive_DMA+0x200>
  }
  else if(hi2s->State == HAL_I2S_STATE_BUSY_RX)
 8005cba:	687b      	ldr	r3, [r7, #4]
 8005cbc:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8005cc0:	b2db      	uxtb	r3, r3
 8005cc2:	2b22      	cmp	r3, #34	; 0x22
 8005cc4:	d108      	bne.n	8005cd8 <HAL_I2S_Receive_DMA+0x1c0>
  {
    /* Disable the I2S DMA Rx request */
    hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
 8005cc6:	687b      	ldr	r3, [r7, #4]
 8005cc8:	681b      	ldr	r3, [r3, #0]
 8005cca:	687a      	ldr	r2, [r7, #4]
 8005ccc:	6812      	ldr	r2, [r2, #0]
 8005cce:	6852      	ldr	r2, [r2, #4]
 8005cd0:	f022 0201 	bic.w	r2, r2, #1
 8005cd4:	605a      	str	r2, [r3, #4]
 8005cd6:	e01f      	b.n	8005d18 <HAL_I2S_Receive_DMA+0x200>
  }
  else if(hi2s->State == HAL_I2S_STATE_BUSY_TX_RX)
 8005cd8:	687b      	ldr	r3, [r7, #4]
 8005cda:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8005cde:	b2db      	uxtb	r3, r3
 8005ce0:	2b32      	cmp	r3, #50	; 0x32
 8005ce2:	d119      	bne.n	8005d18 <HAL_I2S_Receive_DMA+0x200>
  {
    if((hi2s->Init.Mode == I2S_MODE_SLAVE_TX)||(hi2s->Init.Mode == I2S_MODE_MASTER_TX))
 8005ce4:	687b      	ldr	r3, [r7, #4]
 8005ce6:	685b      	ldr	r3, [r3, #4]
 8005ce8:	2b00      	cmp	r3, #0
 8005cea:	d004      	beq.n	8005cf6 <HAL_I2S_Receive_DMA+0x1de>
 8005cec:	687b      	ldr	r3, [r7, #4]
 8005cee:	685b      	ldr	r3, [r3, #4]
 8005cf0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8005cf4:	d108      	bne.n	8005d08 <HAL_I2S_Receive_DMA+0x1f0>
    {
      /* Disable the I2S DMA Tx request */
      hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
 8005cf6:	687b      	ldr	r3, [r7, #4]
 8005cf8:	681b      	ldr	r3, [r3, #0]
 8005cfa:	687a      	ldr	r2, [r7, #4]
 8005cfc:	6812      	ldr	r2, [r2, #0]
 8005cfe:	6852      	ldr	r2, [r2, #4]
 8005d00:	f022 0202 	bic.w	r2, r2, #2
 8005d04:	605a      	str	r2, [r3, #4]
 8005d06:	e007      	b.n	8005d18 <HAL_I2S_Receive_DMA+0x200>
    }
    else
    {
      /* Disable the I2S DMA Rx request */
      hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
 8005d08:	687b      	ldr	r3, [r7, #4]
 8005d0a:	681b      	ldr	r3, [r3, #0]
 8005d0c:	687a      	ldr	r2, [r7, #4]
 8005d0e:	6812      	ldr	r2, [r2, #0]
 8005d10:	6852      	ldr	r2, [r2, #4]
 8005d12:	f022 0201 	bic.w	r2, r2, #1
 8005d16:	605a      	str	r2, [r3, #4]
    }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2s);
 8005d18:	687b      	ldr	r3, [r7, #4]
 8005d1a:	2200      	movs	r2, #0
 8005d1c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  return HAL_OK; 
 8005d20:	2300      	movs	r3, #0
}
 8005d22:	4618      	mov	r0, r3
 8005d24:	370c      	adds	r7, #12
 8005d26:	46bd      	mov	sp, r7
 8005d28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005d2c:	4770      	bx	lr
 8005d2e:	bf00      	nop
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_I2S_DMAResume(I2S_HandleTypeDef *hi2s)
{
 8005d30:	b480      	push	{r7}
 8005d32:	b083      	sub	sp, #12
 8005d34:	af00      	add	r7, sp, #0
 8005d36:	6078      	str	r0, [r7, #4]
  /* Process Locked */
  __HAL_LOCK(hi2s);
 8005d38:	687b      	ldr	r3, [r7, #4]
 8005d3a:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8005d3e:	b2db      	uxtb	r3, r3
 8005d40:	2b01      	cmp	r3, #1
 8005d42:	d101      	bne.n	8005d48 <HAL_I2S_Receive_DMA+0x230>
 8005d44:	2302      	movs	r3, #2
 8005d46:	e055      	b.n	8005df4 <HAL_I2S_Receive_DMA+0x2dc>
 8005d48:	687b      	ldr	r3, [r7, #4]
 8005d4a:	2201      	movs	r2, #1
 8005d4c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  if(hi2s->State == HAL_I2S_STATE_BUSY_TX)
 8005d50:	687b      	ldr	r3, [r7, #4]
 8005d52:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8005d56:	b2db      	uxtb	r3, r3
 8005d58:	2b12      	cmp	r3, #18
 8005d5a:	d108      	bne.n	8005d6e <HAL_I2S_Receive_DMA+0x256>
  {
    /* Enable the I2S DMA Tx request */
    hi2s->Instance->CR2 |= SPI_CR2_TXDMAEN;
 8005d5c:	687b      	ldr	r3, [r7, #4]
 8005d5e:	681b      	ldr	r3, [r3, #0]
 8005d60:	687a      	ldr	r2, [r7, #4]
 8005d62:	6812      	ldr	r2, [r2, #0]
 8005d64:	6852      	ldr	r2, [r2, #4]
 8005d66:	f042 0202 	orr.w	r2, r2, #2
 8005d6a:	605a      	str	r2, [r3, #4]
 8005d6c:	e02e      	b.n	8005dcc <HAL_I2S_Receive_DMA+0x2b4>
  }
  else if(hi2s->State == HAL_I2S_STATE_BUSY_RX)
 8005d6e:	687b      	ldr	r3, [r7, #4]
 8005d70:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8005d74:	b2db      	uxtb	r3, r3
 8005d76:	2b22      	cmp	r3, #34	; 0x22
 8005d78:	d108      	bne.n	8005d8c <HAL_I2S_Receive_DMA+0x274>
  {
    /* Enable the I2S DMA Rx request */
    hi2s->Instance->CR2 |= SPI_CR2_RXDMAEN;
 8005d7a:	687b      	ldr	r3, [r7, #4]
 8005d7c:	681b      	ldr	r3, [r3, #0]
 8005d7e:	687a      	ldr	r2, [r7, #4]
 8005d80:	6812      	ldr	r2, [r2, #0]
 8005d82:	6852      	ldr	r2, [r2, #4]
 8005d84:	f042 0201 	orr.w	r2, r2, #1
 8005d88:	605a      	str	r2, [r3, #4]
 8005d8a:	e01f      	b.n	8005dcc <HAL_I2S_Receive_DMA+0x2b4>
  }
  else if(hi2s->State == HAL_I2S_STATE_BUSY_TX_RX)
 8005d8c:	687b      	ldr	r3, [r7, #4]
 8005d8e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8005d92:	b2db      	uxtb	r3, r3
 8005d94:	2b32      	cmp	r3, #50	; 0x32
 8005d96:	d119      	bne.n	8005dcc <HAL_I2S_Receive_DMA+0x2b4>
  {
    if((hi2s->Init.Mode == I2S_MODE_SLAVE_TX)||(hi2s->Init.Mode == I2S_MODE_MASTER_TX))
 8005d98:	687b      	ldr	r3, [r7, #4]
 8005d9a:	685b      	ldr	r3, [r3, #4]
 8005d9c:	2b00      	cmp	r3, #0
 8005d9e:	d004      	beq.n	8005daa <HAL_I2S_Receive_DMA+0x292>
 8005da0:	687b      	ldr	r3, [r7, #4]
 8005da2:	685b      	ldr	r3, [r3, #4]
 8005da4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8005da8:	d108      	bne.n	8005dbc <HAL_I2S_Receive_DMA+0x2a4>
    {
      /* Enable the I2S DMA Tx request */
      hi2s->Instance->CR2 |= SPI_CR2_TXDMAEN;
 8005daa:	687b      	ldr	r3, [r7, #4]
 8005dac:	681b      	ldr	r3, [r3, #0]
 8005dae:	687a      	ldr	r2, [r7, #4]
 8005db0:	6812      	ldr	r2, [r2, #0]
 8005db2:	6852      	ldr	r2, [r2, #4]
 8005db4:	f042 0202 	orr.w	r2, r2, #2
 8005db8:	605a      	str	r2, [r3, #4]
 8005dba:	e007      	b.n	8005dcc <HAL_I2S_Receive_DMA+0x2b4>
    }
    else
    {
      /* Enable the I2S DMA Rx request */
      hi2s->Instance->CR2 |= SPI_CR2_RXDMAEN;
 8005dbc:	687b      	ldr	r3, [r7, #4]
 8005dbe:	681b      	ldr	r3, [r3, #0]
 8005dc0:	687a      	ldr	r2, [r7, #4]
 8005dc2:	6812      	ldr	r2, [r2, #0]
 8005dc4:	6852      	ldr	r2, [r2, #4]
 8005dc6:	f042 0201 	orr.w	r2, r2, #1
 8005dca:	605a      	str	r2, [r3, #4]
    }
  }

  /* If the I2S peripheral is still not enabled, enable it */
  if ((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SE) == 0)
 8005dcc:	687b      	ldr	r3, [r7, #4]
 8005dce:	681b      	ldr	r3, [r3, #0]
 8005dd0:	69db      	ldr	r3, [r3, #28]
 8005dd2:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8005dd6:	2b00      	cmp	r3, #0
 8005dd8:	d107      	bne.n	8005dea <HAL_I2S_Receive_DMA+0x2d2>
  {
    /* Enable I2S peripheral */    
    __HAL_I2S_ENABLE(hi2s);
 8005dda:	687b      	ldr	r3, [r7, #4]
 8005ddc:	681b      	ldr	r3, [r3, #0]
 8005dde:	687a      	ldr	r2, [r7, #4]
 8005de0:	6812      	ldr	r2, [r2, #0]
 8005de2:	69d2      	ldr	r2, [r2, #28]
 8005de4:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8005de8:	61da      	str	r2, [r3, #28]
  }
  
  /* Process Unlocked */
  __HAL_UNLOCK(hi2s);
 8005dea:	687b      	ldr	r3, [r7, #4]
 8005dec:	2200      	movs	r2, #0
 8005dee:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  return HAL_OK;
 8005df2:	2300      	movs	r3, #0
}
 8005df4:	4618      	mov	r0, r3
 8005df6:	370c      	adds	r7, #12
 8005df8:	46bd      	mov	sp, r7
 8005dfa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005dfe:	4770      	bx	lr
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_I2S_DMAStop(I2S_HandleTypeDef *hi2s)
{
 8005e00:	b580      	push	{r7, lr}
 8005e02:	b082      	sub	sp, #8
 8005e04:	af00      	add	r7, sp, #0
 8005e06:	6078      	str	r0, [r7, #4]
  /* Process Locked */
  __HAL_LOCK(hi2s);
 8005e08:	687b      	ldr	r3, [r7, #4]
 8005e0a:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8005e0e:	b2db      	uxtb	r3, r3
 8005e10:	2b01      	cmp	r3, #1
 8005e12:	d101      	bne.n	8005e18 <HAL_I2S_Receive_DMA+0x300>
 8005e14:	2302      	movs	r3, #2
 8005e16:	e036      	b.n	8005e86 <HAL_I2S_Receive_DMA+0x36e>
 8005e18:	687b      	ldr	r3, [r7, #4]
 8005e1a:	2201      	movs	r2, #1
 8005e1c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Disable the I2S Tx/Rx DMA requests */
  hi2s->Instance->CR2 &= ~SPI_CR2_TXDMAEN;
 8005e20:	687b      	ldr	r3, [r7, #4]
 8005e22:	681b      	ldr	r3, [r3, #0]
 8005e24:	687a      	ldr	r2, [r7, #4]
 8005e26:	6812      	ldr	r2, [r2, #0]
 8005e28:	6852      	ldr	r2, [r2, #4]
 8005e2a:	f022 0202 	bic.w	r2, r2, #2
 8005e2e:	605a      	str	r2, [r3, #4]
  hi2s->Instance->CR2 &= ~SPI_CR2_RXDMAEN;
 8005e30:	687b      	ldr	r3, [r7, #4]
 8005e32:	681b      	ldr	r3, [r3, #0]
 8005e34:	687a      	ldr	r2, [r7, #4]
 8005e36:	6812      	ldr	r2, [r2, #0]
 8005e38:	6852      	ldr	r2, [r2, #4]
 8005e3a:	f022 0201 	bic.w	r2, r2, #1
 8005e3e:	605a      	str	r2, [r3, #4]

  /* Abort the I2S DMA Stream tx */
  if(hi2s->hdmatx != NULL)
 8005e40:	687b      	ldr	r3, [r7, #4]
 8005e42:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005e44:	2b00      	cmp	r3, #0
 8005e46:	d004      	beq.n	8005e52 <HAL_I2S_Receive_DMA+0x33a>
  {
    HAL_DMA_Abort(hi2s->hdmatx);
 8005e48:	687b      	ldr	r3, [r7, #4]
 8005e4a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005e4c:	4618      	mov	r0, r3
 8005e4e:	f7fe fbed 	bl	800462c <HAL_DMA_Abort>
  }
  /* Abort the I2S DMA Stream rx */
  if(hi2s->hdmarx != NULL)
 8005e52:	687b      	ldr	r3, [r7, #4]
 8005e54:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005e56:	2b00      	cmp	r3, #0
 8005e58:	d004      	beq.n	8005e64 <HAL_I2S_Receive_DMA+0x34c>
  {
    HAL_DMA_Abort(hi2s->hdmarx);
 8005e5a:	687b      	ldr	r3, [r7, #4]
 8005e5c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005e5e:	4618      	mov	r0, r3
 8005e60:	f7fe fbe4 	bl	800462c <HAL_DMA_Abort>
  }

  /* Disable I2S peripheral */
  __HAL_I2S_DISABLE(hi2s);
 8005e64:	687b      	ldr	r3, [r7, #4]
 8005e66:	681b      	ldr	r3, [r3, #0]
 8005e68:	687a      	ldr	r2, [r7, #4]
 8005e6a:	6812      	ldr	r2, [r2, #0]
 8005e6c:	69d2      	ldr	r2, [r2, #28]
 8005e6e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8005e72:	61da      	str	r2, [r3, #28]
  
  hi2s->State = HAL_I2S_STATE_READY;
 8005e74:	687b      	ldr	r3, [r7, #4]
 8005e76:	2201      	movs	r2, #1
 8005e78:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Process Unlocked */
  __HAL_UNLOCK(hi2s);
 8005e7c:	687b      	ldr	r3, [r7, #4]
 8005e7e:	2200      	movs	r2, #0
 8005e80:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  return HAL_OK;
 8005e84:	2300      	movs	r3, #0
}
 8005e86:	4618      	mov	r0, r3
 8005e88:	3708      	adds	r7, #8
 8005e8a:	46bd      	mov	sp, r7
 8005e8c:	bd80      	pop	{r7, pc}
 8005e8e:	bf00      	nop
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
__weak void HAL_I2S_IRQHandler(I2S_HandleTypeDef *hi2s)
{  
 8005e90:	b580      	push	{r7, lr}
 8005e92:	b086      	sub	sp, #24
 8005e94:	af00      	add	r7, sp, #0
 8005e96:	6078      	str	r0, [r7, #4]
  uint32_t tmp1 = 0, tmp2 = 0; 
 8005e98:	2300      	movs	r3, #0
 8005e9a:	617b      	str	r3, [r7, #20]
 8005e9c:	2300      	movs	r3, #0
 8005e9e:	613b      	str	r3, [r7, #16]

    if(hi2s->State == HAL_I2S_STATE_BUSY_RX)
 8005ea0:	687b      	ldr	r3, [r7, #4]
 8005ea2:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8005ea6:	b2db      	uxtb	r3, r3
 8005ea8:	2b22      	cmp	r3, #34	; 0x22
 8005eaa:	d149      	bne.n	8005f40 <HAL_I2S_Receive_DMA+0x428>
    {
      tmp1 = __HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_RXNE);
 8005eac:	687b      	ldr	r3, [r7, #4]
 8005eae:	681b      	ldr	r3, [r3, #0]
 8005eb0:	689b      	ldr	r3, [r3, #8]
 8005eb2:	f003 0301 	and.w	r3, r3, #1
 8005eb6:	2b00      	cmp	r3, #0
 8005eb8:	bf0c      	ite	eq
 8005eba:	2300      	moveq	r3, #0
 8005ebc:	2301      	movne	r3, #1
 8005ebe:	b2db      	uxtb	r3, r3
 8005ec0:	617b      	str	r3, [r7, #20]
      tmp2 = __HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_RXNE);
 8005ec2:	687b      	ldr	r3, [r7, #4]
 8005ec4:	681b      	ldr	r3, [r3, #0]
 8005ec6:	685b      	ldr	r3, [r3, #4]
 8005ec8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8005ecc:	2b00      	cmp	r3, #0
 8005ece:	bf0c      	ite	eq
 8005ed0:	2300      	moveq	r3, #0
 8005ed2:	2301      	movne	r3, #1
 8005ed4:	b2db      	uxtb	r3, r3
 8005ed6:	613b      	str	r3, [r7, #16]
      /* I2S in mode Receiver ------------------------------------------------*/
      if((tmp1 != RESET) && (tmp2 != RESET))
 8005ed8:	697b      	ldr	r3, [r7, #20]
 8005eda:	2b00      	cmp	r3, #0
 8005edc:	d005      	beq.n	8005eea <HAL_I2S_Receive_DMA+0x3d2>
 8005ede:	693b      	ldr	r3, [r7, #16]
 8005ee0:	2b00      	cmp	r3, #0
 8005ee2:	d002      	beq.n	8005eea <HAL_I2S_Receive_DMA+0x3d2>
      {
        I2S_Receive_IT(hi2s);
 8005ee4:	6878      	ldr	r0, [r7, #4]
 8005ee6:	f000 f955 	bl	8006194 <I2S_Receive_IT>
      }

      tmp1 = __HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_OVR);
 8005eea:	687b      	ldr	r3, [r7, #4]
 8005eec:	681b      	ldr	r3, [r3, #0]
 8005eee:	689b      	ldr	r3, [r3, #8]
 8005ef0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8005ef4:	2b00      	cmp	r3, #0
 8005ef6:	bf0c      	ite	eq
 8005ef8:	2300      	moveq	r3, #0
 8005efa:	2301      	movne	r3, #1
 8005efc:	b2db      	uxtb	r3, r3
 8005efe:	617b      	str	r3, [r7, #20]
      tmp2 = __HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR);
 8005f00:	687b      	ldr	r3, [r7, #4]
 8005f02:	681b      	ldr	r3, [r3, #0]
 8005f04:	685b      	ldr	r3, [r3, #4]
 8005f06:	f003 0320 	and.w	r3, r3, #32
 8005f0a:	2b00      	cmp	r3, #0
 8005f0c:	bf0c      	ite	eq
 8005f0e:	2300      	moveq	r3, #0
 8005f10:	2301      	movne	r3, #1
 8005f12:	b2db      	uxtb	r3, r3
 8005f14:	613b      	str	r3, [r7, #16]
      /* I2S Overrun error interrupt occurred ---------------------------------*/
      if((tmp1 != RESET) && (tmp2 != RESET))
 8005f16:	697b      	ldr	r3, [r7, #20]
 8005f18:	2b00      	cmp	r3, #0
 8005f1a:	d011      	beq.n	8005f40 <HAL_I2S_Receive_DMA+0x428>
 8005f1c:	693b      	ldr	r3, [r7, #16]
 8005f1e:	2b00      	cmp	r3, #0
 8005f20:	d00e      	beq.n	8005f40 <HAL_I2S_Receive_DMA+0x428>
      {
        __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 8005f22:	687b      	ldr	r3, [r7, #4]
 8005f24:	681b      	ldr	r3, [r3, #0]
 8005f26:	68db      	ldr	r3, [r3, #12]
 8005f28:	60fb      	str	r3, [r7, #12]
 8005f2a:	687b      	ldr	r3, [r7, #4]
 8005f2c:	681b      	ldr	r3, [r3, #0]
 8005f2e:	689b      	ldr	r3, [r3, #8]
 8005f30:	60fb      	str	r3, [r7, #12]
 8005f32:	68fb      	ldr	r3, [r7, #12]
        hi2s->ErrorCode |= HAL_I2S_ERROR_OVR;
 8005f34:	687b      	ldr	r3, [r7, #4]
 8005f36:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005f38:	f043 0202 	orr.w	r2, r3, #2
 8005f3c:	687b      	ldr	r3, [r7, #4]
 8005f3e:	641a      	str	r2, [r3, #64]	; 0x40
      }
    }

    if(hi2s->State == HAL_I2S_STATE_BUSY_TX)
 8005f40:	687b      	ldr	r3, [r7, #4]
 8005f42:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8005f46:	b2db      	uxtb	r3, r3
 8005f48:	2b12      	cmp	r3, #18
 8005f4a:	d145      	bne.n	8005fd8 <HAL_I2S_Receive_DMA+0x4c0>
    {
      tmp1 = __HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_TXE);
 8005f4c:	687b      	ldr	r3, [r7, #4]
 8005f4e:	681b      	ldr	r3, [r3, #0]
 8005f50:	689b      	ldr	r3, [r3, #8]
 8005f52:	f003 0302 	and.w	r3, r3, #2
 8005f56:	2b00      	cmp	r3, #0
 8005f58:	bf0c      	ite	eq
 8005f5a:	2300      	moveq	r3, #0
 8005f5c:	2301      	movne	r3, #1
 8005f5e:	b2db      	uxtb	r3, r3
 8005f60:	617b      	str	r3, [r7, #20]
      tmp2 = __HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_TXE);
 8005f62:	687b      	ldr	r3, [r7, #4]
 8005f64:	681b      	ldr	r3, [r3, #0]
 8005f66:	685b      	ldr	r3, [r3, #4]
 8005f68:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8005f6c:	2b00      	cmp	r3, #0
 8005f6e:	bf0c      	ite	eq
 8005f70:	2300      	moveq	r3, #0
 8005f72:	2301      	movne	r3, #1
 8005f74:	b2db      	uxtb	r3, r3
 8005f76:	613b      	str	r3, [r7, #16]
      /* I2S in mode Transmitter -----------------------------------------------*/
      if((tmp1 != RESET) && (tmp2 != RESET))
 8005f78:	697b      	ldr	r3, [r7, #20]
 8005f7a:	2b00      	cmp	r3, #0
 8005f7c:	d005      	beq.n	8005f8a <HAL_I2S_Receive_DMA+0x472>
 8005f7e:	693b      	ldr	r3, [r7, #16]
 8005f80:	2b00      	cmp	r3, #0
 8005f82:	d002      	beq.n	8005f8a <HAL_I2S_Receive_DMA+0x472>
      {
        I2S_Transmit_IT(hi2s);
 8005f84:	6878      	ldr	r0, [r7, #4]
 8005f86:	f000 f8bb 	bl	8006100 <I2S_Transmit_IT>
      }

      tmp1 = __HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_UDR);
 8005f8a:	687b      	ldr	r3, [r7, #4]
 8005f8c:	681b      	ldr	r3, [r3, #0]
 8005f8e:	689b      	ldr	r3, [r3, #8]
 8005f90:	f003 0308 	and.w	r3, r3, #8
 8005f94:	2b00      	cmp	r3, #0
 8005f96:	bf0c      	ite	eq
 8005f98:	2300      	moveq	r3, #0
 8005f9a:	2301      	movne	r3, #1
 8005f9c:	b2db      	uxtb	r3, r3
 8005f9e:	617b      	str	r3, [r7, #20]
      tmp2 = __HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR);
 8005fa0:	687b      	ldr	r3, [r7, #4]
 8005fa2:	681b      	ldr	r3, [r3, #0]
 8005fa4:	685b      	ldr	r3, [r3, #4]
 8005fa6:	f003 0320 	and.w	r3, r3, #32
 8005faa:	2b00      	cmp	r3, #0
 8005fac:	bf0c      	ite	eq
 8005fae:	2300      	moveq	r3, #0
 8005fb0:	2301      	movne	r3, #1
 8005fb2:	b2db      	uxtb	r3, r3
 8005fb4:	613b      	str	r3, [r7, #16]
      /* I2S Underrun error interrupt occurred --------------------------------*/
      if((tmp1 != RESET) && (tmp2 != RESET))
 8005fb6:	697b      	ldr	r3, [r7, #20]
 8005fb8:	2b00      	cmp	r3, #0
 8005fba:	d00d      	beq.n	8005fd8 <HAL_I2S_Receive_DMA+0x4c0>
 8005fbc:	693b      	ldr	r3, [r7, #16]
 8005fbe:	2b00      	cmp	r3, #0
 8005fc0:	d00a      	beq.n	8005fd8 <HAL_I2S_Receive_DMA+0x4c0>
      {
        __HAL_I2S_CLEAR_UDRFLAG(hi2s);
 8005fc2:	687b      	ldr	r3, [r7, #4]
 8005fc4:	681b      	ldr	r3, [r3, #0]
 8005fc6:	689b      	ldr	r3, [r3, #8]
 8005fc8:	60bb      	str	r3, [r7, #8]
 8005fca:	68bb      	ldr	r3, [r7, #8]
        hi2s->ErrorCode |= HAL_I2S_ERROR_UDR;
 8005fcc:	687b      	ldr	r3, [r7, #4]
 8005fce:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005fd0:	f043 0201 	orr.w	r2, r3, #1
 8005fd4:	687b      	ldr	r3, [r7, #4]
 8005fd6:	641a      	str	r2, [r3, #64]	; 0x40
    }
  }

  /* Call the Error call Back in case of Errors */
  if(hi2s->ErrorCode != HAL_I2S_ERROR_NONE)
 8005fd8:	687b      	ldr	r3, [r7, #4]
 8005fda:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005fdc:	2b00      	cmp	r3, #0
 8005fde:	d006      	beq.n	8005fee <HAL_I2S_Receive_DMA+0x4d6>
  {
    /* Set the I2S state ready to be able to start again the process */
    hi2s->State= HAL_I2S_STATE_READY;
 8005fe0:	687b      	ldr	r3, [r7, #4]
 8005fe2:	2201      	movs	r2, #1
 8005fe4:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    HAL_I2S_ErrorCallback(hi2s);
 8005fe8:	6878      	ldr	r0, [r7, #4]
 8005fea:	f000 f82b 	bl	8006044 <HAL_I2S_ErrorCallback>
  }
}
 8005fee:	3718      	adds	r7, #24
 8005ff0:	46bd      	mov	sp, r7
 8005ff2:	bd80      	pop	{r7, pc}
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
 __weak void HAL_I2S_TxHalfCpltCallback(I2S_HandleTypeDef *hi2s)
{
 8005ff4:	b480      	push	{r7}
 8005ff6:	b083      	sub	sp, #12
 8005ff8:	af00      	add	r7, sp, #0
 8005ffa:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_TxHalfCpltCallback could be implemented in the user file
   */ 
}
 8005ffc:	370c      	adds	r7, #12
 8005ffe:	46bd      	mov	sp, r7
 8006000:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006004:	4770      	bx	lr
 8006006:	bf00      	nop
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
 __weak void HAL_I2S_TxCpltCallback(I2S_HandleTypeDef *hi2s)
{
 8006008:	b480      	push	{r7}
 800600a:	b083      	sub	sp, #12
 800600c:	af00      	add	r7, sp, #0
 800600e:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_TxCpltCallback could be implemented in the user file
   */ 
}
 8006010:	370c      	adds	r7, #12
 8006012:	46bd      	mov	sp, r7
 8006014:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006018:	4770      	bx	lr
 800601a:	bf00      	nop
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
__weak void HAL_I2S_RxHalfCpltCallback(I2S_HandleTypeDef *hi2s)
{
 800601c:	b480      	push	{r7}
 800601e:	b083      	sub	sp, #12
 8006020:	af00      	add	r7, sp, #0
 8006022:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_RxCpltCallback could be implemented in the user file
   */
}
 8006024:	370c      	adds	r7, #12
 8006026:	46bd      	mov	sp, r7
 8006028:	f85d 7b04 	ldr.w	r7, [sp], #4
 800602c:	4770      	bx	lr
 800602e:	bf00      	nop
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
__weak void HAL_I2S_RxCpltCallback(I2S_HandleTypeDef *hi2s)
{
 8006030:	b480      	push	{r7}
 8006032:	b083      	sub	sp, #12
 8006034:	af00      	add	r7, sp, #0
 8006036:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_RxCpltCallback could be implemented in the user file
   */
}
 8006038:	370c      	adds	r7, #12
 800603a:	46bd      	mov	sp, r7
 800603c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006040:	4770      	bx	lr
 8006042:	bf00      	nop

08006044 <HAL_I2S_ErrorCallback>:
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
 __weak void HAL_I2S_ErrorCallback(I2S_HandleTypeDef *hi2s)
{
 8006044:	b480      	push	{r7}
 8006046:	b083      	sub	sp, #12
 8006048:	af00      	add	r7, sp, #0
 800604a:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_ErrorCallback could be implemented in the user file
   */ 
}
 800604c:	370c      	adds	r7, #12
 800604e:	46bd      	mov	sp, r7
 8006050:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006054:	4770      	bx	lr
 8006056:	bf00      	nop

08006058 <HAL_I2S_GetState>:
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval HAL state
  */
HAL_I2S_StateTypeDef HAL_I2S_GetState(I2S_HandleTypeDef *hi2s)
{
 8006058:	b480      	push	{r7}
 800605a:	b083      	sub	sp, #12
 800605c:	af00      	add	r7, sp, #0
 800605e:	6078      	str	r0, [r7, #4]
  return hi2s->State;
 8006060:	687b      	ldr	r3, [r7, #4]
 8006062:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8006066:	b2db      	uxtb	r3, r3
}
 8006068:	4618      	mov	r0, r3
 800606a:	370c      	adds	r7, #12
 800606c:	46bd      	mov	sp, r7
 800606e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006072:	4770      	bx	lr

08006074 <HAL_I2S_GetError>:
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval I2S Error Code
  */
uint32_t HAL_I2S_GetError(I2S_HandleTypeDef *hi2s)
{
 8006074:	b480      	push	{r7}
 8006076:	b083      	sub	sp, #12
 8006078:	af00      	add	r7, sp, #0
 800607a:	6078      	str	r0, [r7, #4]
  return hi2s->ErrorCode;
 800607c:	687b      	ldr	r3, [r7, #4]
 800607e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
}
 8006080:	4618      	mov	r0, r3
 8006082:	370c      	adds	r7, #12
 8006084:	46bd      	mov	sp, r7
 8006086:	f85d 7b04 	ldr.w	r7, [sp], #4
 800608a:	4770      	bx	lr

0800608c <I2S_DMATxHalfCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
 void I2S_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 800608c:	b580      	push	{r7, lr}
 800608e:	b084      	sub	sp, #16
 8006090:	af00      	add	r7, sp, #0
 8006092:	6078      	str	r0, [r7, #4]
  I2S_HandleTypeDef* hi2s = (I2S_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
 8006094:	687b      	ldr	r3, [r7, #4]
 8006096:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8006098:	60fb      	str	r3, [r7, #12]

  HAL_I2S_TxHalfCpltCallback(hi2s);
 800609a:	68f8      	ldr	r0, [r7, #12]
 800609c:	f7fb f89e 	bl	80011dc <HAL_I2S_TxHalfCpltCallback>
}
 80060a0:	3710      	adds	r7, #16
 80060a2:	46bd      	mov	sp, r7
 80060a4:	bd80      	pop	{r7, pc}
 80060a6:	bf00      	nop

080060a8 <I2S_DMARxHalfCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
void I2S_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
 80060a8:	b580      	push	{r7, lr}
 80060aa:	b084      	sub	sp, #16
 80060ac:	af00      	add	r7, sp, #0
 80060ae:	6078      	str	r0, [r7, #4]
  I2S_HandleTypeDef* hi2s = (I2S_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
 80060b0:	687b      	ldr	r3, [r7, #4]
 80060b2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80060b4:	60fb      	str	r3, [r7, #12]

  HAL_I2S_RxHalfCpltCallback(hi2s); 
 80060b6:	68f8      	ldr	r0, [r7, #12]
 80060b8:	f7fb f8a4 	bl	8001204 <HAL_I2S_RxHalfCpltCallback>
}
 80060bc:	3710      	adds	r7, #16
 80060be:	46bd      	mov	sp, r7
 80060c0:	bd80      	pop	{r7, pc}
 80060c2:	bf00      	nop

080060c4 <I2S_DMAError>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
void I2S_DMAError(DMA_HandleTypeDef *hdma)
{
 80060c4:	b580      	push	{r7, lr}
 80060c6:	b084      	sub	sp, #16
 80060c8:	af00      	add	r7, sp, #0
 80060ca:	6078      	str	r0, [r7, #4]
  I2S_HandleTypeDef* hi2s = (I2S_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
 80060cc:	687b      	ldr	r3, [r7, #4]
 80060ce:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80060d0:	60fb      	str	r3, [r7, #12]

  hi2s->TxXferCount = 0;
 80060d2:	68fb      	ldr	r3, [r7, #12]
 80060d4:	2200      	movs	r2, #0
 80060d6:	855a      	strh	r2, [r3, #42]	; 0x2a
  hi2s->RxXferCount = 0;
 80060d8:	68fb      	ldr	r3, [r7, #12]
 80060da:	2200      	movs	r2, #0
 80060dc:	865a      	strh	r2, [r3, #50]	; 0x32

  hi2s->State= HAL_I2S_STATE_READY;
 80060de:	68fb      	ldr	r3, [r7, #12]
 80060e0:	2201      	movs	r2, #1
 80060e2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  hi2s->ErrorCode |= HAL_I2S_ERROR_DMA;
 80060e6:	68fb      	ldr	r3, [r7, #12]
 80060e8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80060ea:	f043 0220 	orr.w	r2, r3, #32
 80060ee:	68fb      	ldr	r3, [r7, #12]
 80060f0:	641a      	str	r2, [r3, #64]	; 0x40
  HAL_I2S_ErrorCallback(hi2s);
 80060f2:	68f8      	ldr	r0, [r7, #12]
 80060f4:	f7ff ffa6 	bl	8006044 <HAL_I2S_ErrorCallback>
}
 80060f8:	3710      	adds	r7, #16
 80060fa:	46bd      	mov	sp, r7
 80060fc:	bd80      	pop	{r7, pc}
 80060fe:	bf00      	nop

08006100 <I2S_Transmit_IT>:
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval HAL status
  */
HAL_StatusTypeDef I2S_Transmit_IT(I2S_HandleTypeDef *hi2s)
{
 8006100:	b580      	push	{r7, lr}
 8006102:	b082      	sub	sp, #8
 8006104:	af00      	add	r7, sp, #0
 8006106:	6078      	str	r0, [r7, #4]
 if(hi2s->State == HAL_I2S_STATE_BUSY_TX)
 8006108:	687b      	ldr	r3, [r7, #4]
 800610a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800610e:	b2db      	uxtb	r3, r3
 8006110:	2b12      	cmp	r3, #18
 8006112:	d13a      	bne.n	800618a <I2S_Transmit_IT+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2s);
 8006114:	687b      	ldr	r3, [r7, #4]
 8006116:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 800611a:	b2db      	uxtb	r3, r3
 800611c:	2b01      	cmp	r3, #1
 800611e:	d101      	bne.n	8006124 <I2S_Transmit_IT+0x24>
 8006120:	2302      	movs	r3, #2
 8006122:	e033      	b.n	800618c <I2S_Transmit_IT+0x8c>
 8006124:	687b      	ldr	r3, [r7, #4]
 8006126:	2201      	movs	r2, #1
 8006128:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Transmit data */
    hi2s->Instance->DR = (*hi2s->pTxBuffPtr++);
 800612c:	687b      	ldr	r3, [r7, #4]
 800612e:	681a      	ldr	r2, [r3, #0]
 8006130:	687b      	ldr	r3, [r7, #4]
 8006132:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006134:	1c98      	adds	r0, r3, #2
 8006136:	6879      	ldr	r1, [r7, #4]
 8006138:	6248      	str	r0, [r1, #36]	; 0x24
 800613a:	881b      	ldrh	r3, [r3, #0]
 800613c:	60d3      	str	r3, [r2, #12]

    hi2s->TxXferCount--;	
 800613e:	687b      	ldr	r3, [r7, #4]
 8006140:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8006142:	b29b      	uxth	r3, r3
 8006144:	3b01      	subs	r3, #1
 8006146:	b29a      	uxth	r2, r3
 8006148:	687b      	ldr	r3, [r7, #4]
 800614a:	855a      	strh	r2, [r3, #42]	; 0x2a
    
    if(hi2s->TxXferCount == 0)
 800614c:	687b      	ldr	r3, [r7, #4]
 800614e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8006150:	b29b      	uxth	r3, r3
 8006152:	2b00      	cmp	r3, #0
 8006154:	d113      	bne.n	800617e <I2S_Transmit_IT+0x7e>
    {
      /* Disable TXE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8006156:	687b      	ldr	r3, [r7, #4]
 8006158:	681b      	ldr	r3, [r3, #0]
 800615a:	687a      	ldr	r2, [r7, #4]
 800615c:	6812      	ldr	r2, [r2, #0]
 800615e:	6852      	ldr	r2, [r2, #4]
 8006160:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 8006164:	605a      	str	r2, [r3, #4]
      
      hi2s->State = HAL_I2S_STATE_READY;
 8006166:	687b      	ldr	r3, [r7, #4]
 8006168:	2201      	movs	r2, #1
 800616a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

      /* Process Unlocked */
      __HAL_UNLOCK(hi2s);
 800616e:	687b      	ldr	r3, [r7, #4]
 8006170:	2200      	movs	r2, #0
 8006172:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
      HAL_I2S_TxCpltCallback(hi2s);
 8006176:	6878      	ldr	r0, [r7, #4]
 8006178:	f7fa fffc 	bl	8001174 <HAL_I2S_TxCpltCallback>
 800617c:	e003      	b.n	8006186 <I2S_Transmit_IT+0x86>
    }
    else
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2s);
 800617e:	687b      	ldr	r3, [r7, #4]
 8006180:	2200      	movs	r2, #0
 8006182:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }

    return HAL_OK;
 8006186:	2300      	movs	r3, #0
 8006188:	e000      	b.n	800618c <I2S_Transmit_IT+0x8c>
  }
  
  else
  {
    return HAL_BUSY;
 800618a:	2302      	movs	r3, #2
  }
}
 800618c:	4618      	mov	r0, r3
 800618e:	3708      	adds	r7, #8
 8006190:	46bd      	mov	sp, r7
 8006192:	bd80      	pop	{r7, pc}

08006194 <I2S_Receive_IT>:
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval HAL status
  */
HAL_StatusTypeDef I2S_Receive_IT(I2S_HandleTypeDef *hi2s)
{
 8006194:	b580      	push	{r7, lr}
 8006196:	b084      	sub	sp, #16
 8006198:	af00      	add	r7, sp, #0
 800619a:	6078      	str	r0, [r7, #4]
  if(hi2s->State == HAL_I2S_STATE_BUSY_RX)
 800619c:	687b      	ldr	r3, [r7, #4]
 800619e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80061a2:	b2db      	uxtb	r3, r3
 80061a4:	2b22      	cmp	r3, #34	; 0x22
 80061a6:	d14c      	bne.n	8006242 <I2S_Receive_IT+0xae>
  {
    /* Process Locked */
    __HAL_LOCK(hi2s);
 80061a8:	687b      	ldr	r3, [r7, #4]
 80061aa:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80061ae:	b2db      	uxtb	r3, r3
 80061b0:	2b01      	cmp	r3, #1
 80061b2:	d101      	bne.n	80061b8 <I2S_Receive_IT+0x24>
 80061b4:	2302      	movs	r3, #2
 80061b6:	e045      	b.n	8006244 <I2S_Receive_IT+0xb0>
 80061b8:	687b      	ldr	r3, [r7, #4]
 80061ba:	2201      	movs	r2, #1
 80061bc:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Receive data */
    (*hi2s->pRxBuffPtr++) = hi2s->Instance->DR;
 80061c0:	687b      	ldr	r3, [r7, #4]
 80061c2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80061c4:	1c99      	adds	r1, r3, #2
 80061c6:	687a      	ldr	r2, [r7, #4]
 80061c8:	62d1      	str	r1, [r2, #44]	; 0x2c
 80061ca:	687a      	ldr	r2, [r7, #4]
 80061cc:	6812      	ldr	r2, [r2, #0]
 80061ce:	68d2      	ldr	r2, [r2, #12]
 80061d0:	b292      	uxth	r2, r2
 80061d2:	801a      	strh	r2, [r3, #0]

    hi2s->RxXferCount--;
 80061d4:	687b      	ldr	r3, [r7, #4]
 80061d6:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 80061d8:	b29b      	uxth	r3, r3
 80061da:	3b01      	subs	r3, #1
 80061dc:	b29a      	uxth	r2, r3
 80061de:	687b      	ldr	r3, [r7, #4]
 80061e0:	865a      	strh	r2, [r3, #50]	; 0x32

    /* Check if Master Receiver mode is selected */
    if((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG) == I2S_MODE_MASTER_RX)
 80061e2:	687b      	ldr	r3, [r7, #4]
 80061e4:	681b      	ldr	r3, [r3, #0]
 80061e6:	69db      	ldr	r3, [r3, #28]
 80061e8:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80061ec:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80061f0:	d108      	bne.n	8006204 <I2S_Receive_IT+0x70>
    {
      /* Clear the Overrun Flag by a read operation on the SPI_DR register followed by a read
      access to the SPI_SR register. */ 
      __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 80061f2:	687b      	ldr	r3, [r7, #4]
 80061f4:	681b      	ldr	r3, [r3, #0]
 80061f6:	68db      	ldr	r3, [r3, #12]
 80061f8:	60fb      	str	r3, [r7, #12]
 80061fa:	687b      	ldr	r3, [r7, #4]
 80061fc:	681b      	ldr	r3, [r3, #0]
 80061fe:	689b      	ldr	r3, [r3, #8]
 8006200:	60fb      	str	r3, [r7, #12]
 8006202:	68fb      	ldr	r3, [r7, #12]
    }

    if(hi2s->RxXferCount == 0)
 8006204:	687b      	ldr	r3, [r7, #4]
 8006206:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8006208:	b29b      	uxth	r3, r3
 800620a:	2b00      	cmp	r3, #0
 800620c:	d113      	bne.n	8006236 <I2S_Receive_IT+0xa2>
    {
      /* Disable RXNE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, I2S_IT_RXNE | I2S_IT_ERR);
 800620e:	687b      	ldr	r3, [r7, #4]
 8006210:	681b      	ldr	r3, [r3, #0]
 8006212:	687a      	ldr	r2, [r7, #4]
 8006214:	6812      	ldr	r2, [r2, #0]
 8006216:	6852      	ldr	r2, [r2, #4]
 8006218:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 800621c:	605a      	str	r2, [r3, #4]

      hi2s->State = HAL_I2S_STATE_READY;
 800621e:	687b      	ldr	r3, [r7, #4]
 8006220:	2201      	movs	r2, #1
 8006222:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

      /* Process Unlocked */
      __HAL_UNLOCK(hi2s);
 8006226:	687b      	ldr	r3, [r7, #4]
 8006228:	2200      	movs	r2, #0
 800622a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

      HAL_I2S_RxCpltCallback(hi2s);
 800622e:	6878      	ldr	r0, [r7, #4]
 8006230:	f7fa ffb4 	bl	800119c <HAL_I2S_RxCpltCallback>
 8006234:	e003      	b.n	800623e <I2S_Receive_IT+0xaa>
    }
    else
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2s);
 8006236:	687b      	ldr	r3, [r7, #4]
 8006238:	2200      	movs	r2, #0
 800623a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }

    return HAL_OK; 
 800623e:	2300      	movs	r3, #0
 8006240:	e000      	b.n	8006244 <I2S_Receive_IT+0xb0>
  }
  else
  {
    return HAL_BUSY; 
 8006242:	2302      	movs	r3, #2
  } 
}
 8006244:	4618      	mov	r0, r3
 8006246:	3710      	adds	r7, #16
 8006248:	46bd      	mov	sp, r7
 800624a:	bd80      	pop	{r7, pc}

0800624c <I2S_WaitFlagStateUntilTimeout>:
  * @param Status: Value of the flag expected
  * @param Timeout: Duration of the timeout
  * @retval HAL status
  */
HAL_StatusTypeDef I2S_WaitFlagStateUntilTimeout(I2S_HandleTypeDef *hi2s, uint32_t Flag, uint32_t Status, uint32_t Timeout)
{
 800624c:	b580      	push	{r7, lr}
 800624e:	b086      	sub	sp, #24
 8006250:	af00      	add	r7, sp, #0
 8006252:	60f8      	str	r0, [r7, #12]
 8006254:	60b9      	str	r1, [r7, #8]
 8006256:	607a      	str	r2, [r7, #4]
 8006258:	603b      	str	r3, [r7, #0]
  uint32_t tickstart = 0;
 800625a:	2300      	movs	r3, #0
 800625c:	617b      	str	r3, [r7, #20]
  
  /* Get tick */
  tickstart = HAL_GetTick();
 800625e:	f7fb fbb3 	bl	80019c8 <HAL_GetTick>
 8006262:	6178      	str	r0, [r7, #20]
  
  /* Wait until flag is set */
  if(Status == RESET)
 8006264:	687b      	ldr	r3, [r7, #4]
 8006266:	2b00      	cmp	r3, #0
 8006268:	d122      	bne.n	80062b0 <I2S_WaitFlagStateUntilTimeout+0x64>
  {
    while(__HAL_I2S_GET_FLAG(hi2s, Flag) == RESET)
 800626a:	e018      	b.n	800629e <I2S_WaitFlagStateUntilTimeout+0x52>
    {
      if(Timeout != HAL_MAX_DELAY)
 800626c:	683b      	ldr	r3, [r7, #0]
 800626e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8006272:	d014      	beq.n	800629e <I2S_WaitFlagStateUntilTimeout+0x52>
      {
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8006274:	683b      	ldr	r3, [r7, #0]
 8006276:	2b00      	cmp	r3, #0
 8006278:	d007      	beq.n	800628a <I2S_WaitFlagStateUntilTimeout+0x3e>
 800627a:	f7fb fba5 	bl	80019c8 <HAL_GetTick>
 800627e:	4602      	mov	r2, r0
 8006280:	697b      	ldr	r3, [r7, #20]
 8006282:	1ad2      	subs	r2, r2, r3
 8006284:	683b      	ldr	r3, [r7, #0]
 8006286:	429a      	cmp	r2, r3
 8006288:	d909      	bls.n	800629e <I2S_WaitFlagStateUntilTimeout+0x52>
        {
          /* Set the I2S State ready */
          hi2s->State= HAL_I2S_STATE_READY;
 800628a:	68fb      	ldr	r3, [r7, #12]
 800628c:	2201      	movs	r2, #1
 800628e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

          /* Process Unlocked */
          __HAL_UNLOCK(hi2s);
 8006292:	68fb      	ldr	r3, [r7, #12]
 8006294:	2200      	movs	r2, #0
 8006296:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

          return HAL_TIMEOUT;
 800629a:	2303      	movs	r3, #3
 800629c:	e02b      	b.n	80062f6 <I2S_WaitFlagStateUntilTimeout+0xaa>
  tickstart = HAL_GetTick();
  
  /* Wait until flag is set */
  if(Status == RESET)
  {
    while(__HAL_I2S_GET_FLAG(hi2s, Flag) == RESET)
 800629e:	68fb      	ldr	r3, [r7, #12]
 80062a0:	681b      	ldr	r3, [r3, #0]
 80062a2:	689a      	ldr	r2, [r3, #8]
 80062a4:	68bb      	ldr	r3, [r7, #8]
 80062a6:	401a      	ands	r2, r3
 80062a8:	68bb      	ldr	r3, [r7, #8]
 80062aa:	429a      	cmp	r2, r3
 80062ac:	d1de      	bne.n	800626c <I2S_WaitFlagStateUntilTimeout+0x20>
 80062ae:	e021      	b.n	80062f4 <I2S_WaitFlagStateUntilTimeout+0xa8>
      }
    }
  }
  else
  {
    while(__HAL_I2S_GET_FLAG(hi2s, Flag) != RESET)
 80062b0:	e018      	b.n	80062e4 <I2S_WaitFlagStateUntilTimeout+0x98>
    {
      if(Timeout != HAL_MAX_DELAY)
 80062b2:	683b      	ldr	r3, [r7, #0]
 80062b4:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80062b8:	d014      	beq.n	80062e4 <I2S_WaitFlagStateUntilTimeout+0x98>
      {
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 80062ba:	683b      	ldr	r3, [r7, #0]
 80062bc:	2b00      	cmp	r3, #0
 80062be:	d007      	beq.n	80062d0 <I2S_WaitFlagStateUntilTimeout+0x84>
 80062c0:	f7fb fb82 	bl	80019c8 <HAL_GetTick>
 80062c4:	4602      	mov	r2, r0
 80062c6:	697b      	ldr	r3, [r7, #20]
 80062c8:	1ad2      	subs	r2, r2, r3
 80062ca:	683b      	ldr	r3, [r7, #0]
 80062cc:	429a      	cmp	r2, r3
 80062ce:	d909      	bls.n	80062e4 <I2S_WaitFlagStateUntilTimeout+0x98>
        {
          /* Set the I2S State ready */
          hi2s->State= HAL_I2S_STATE_READY;
 80062d0:	68fb      	ldr	r3, [r7, #12]
 80062d2:	2201      	movs	r2, #1
 80062d4:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

          /* Process Unlocked */
          __HAL_UNLOCK(hi2s);
 80062d8:	68fb      	ldr	r3, [r7, #12]
 80062da:	2200      	movs	r2, #0
 80062dc:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

          return HAL_TIMEOUT;
 80062e0:	2303      	movs	r3, #3
 80062e2:	e008      	b.n	80062f6 <I2S_WaitFlagStateUntilTimeout+0xaa>
      }
    }
  }
  else
  {
    while(__HAL_I2S_GET_FLAG(hi2s, Flag) != RESET)
 80062e4:	68fb      	ldr	r3, [r7, #12]
 80062e6:	681b      	ldr	r3, [r3, #0]
 80062e8:	689a      	ldr	r2, [r3, #8]
 80062ea:	68bb      	ldr	r3, [r7, #8]
 80062ec:	401a      	ands	r2, r3
 80062ee:	68bb      	ldr	r3, [r7, #8]
 80062f0:	429a      	cmp	r2, r3
 80062f2:	d0de      	beq.n	80062b2 <I2S_WaitFlagStateUntilTimeout+0x66>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
 80062f4:	2300      	movs	r3, #0
}
 80062f6:	4618      	mov	r0, r3
 80062f8:	3718      	adds	r7, #24
 80062fa:	46bd      	mov	sp, r7
 80062fc:	bd80      	pop	{r7, pc}
 80062fe:	bf00      	nop

08006300 <HAL_I2S_Init>:
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2S_Init(I2S_HandleTypeDef *hi2s)
{
 8006300:	b580      	push	{r7, lr}
 8006302:	b088      	sub	sp, #32
 8006304:	af00      	add	r7, sp, #0
 8006306:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
 8006308:	2300      	movs	r3, #0
 800630a:	60fb      	str	r3, [r7, #12]
 800630c:	2302      	movs	r3, #2
 800630e:	61fb      	str	r3, [r7, #28]
 8006310:	2300      	movs	r3, #0
 8006312:	61bb      	str	r3, [r7, #24]
 8006314:	2301      	movs	r3, #1
 8006316:	617b      	str	r3, [r7, #20]
  uint32_t tmp = 0, i2sclk = 0;
 8006318:	2300      	movs	r3, #0
 800631a:	613b      	str	r3, [r7, #16]
 800631c:	2300      	movs	r3, #0
 800631e:	60bb      	str	r3, [r7, #8]
  
  /* Check the I2S handle allocation */
  if(hi2s == NULL)
 8006320:	687b      	ldr	r3, [r7, #4]
 8006322:	2b00      	cmp	r3, #0
 8006324:	d101      	bne.n	800632a <HAL_I2S_Init+0x2a>
  {
    return HAL_ERROR;
 8006326:	2301      	movs	r3, #1
 8006328:	e11a      	b.n	8006560 <HAL_I2S_Init+0x260>
  assert_param(IS_I2S_MCLK_OUTPUT(hi2s->Init.MCLKOutput));
  assert_param(IS_I2S_AUDIO_FREQ(hi2s->Init.AudioFreq));
  assert_param(IS_I2S_CPOL(hi2s->Init.CPOL));  
  assert_param(IS_I2S_CLOCKSOURCE(hi2s->Init.ClockSource));
  
  if(hi2s->State == HAL_I2S_STATE_RESET)
 800632a:	687b      	ldr	r3, [r7, #4]
 800632c:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8006330:	b2db      	uxtb	r3, r3
 8006332:	2b00      	cmp	r3, #0
 8006334:	d106      	bne.n	8006344 <HAL_I2S_Init+0x44>
  {
    /* Allocate lock resource and initialize it */
    hi2s->Lock = HAL_UNLOCKED;
 8006336:	687b      	ldr	r3, [r7, #4]
 8006338:	2200      	movs	r2, #0
 800633a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    /* Init the low level hardware : GPIO, CLOCK, CORTEX */
    HAL_I2S_MspInit(hi2s);
 800633e:	6878      	ldr	r0, [r7, #4]
 8006340:	f7fa fbe4 	bl	8000b0c <HAL_I2S_MspInit>
  }
  
  hi2s->State = HAL_I2S_STATE_BUSY;
 8006344:	687b      	ldr	r3, [r7, #4]
 8006346:	2202      	movs	r2, #2
 8006348:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /*----------------------- SPIx I2SCFGR & I2SPR Configuration ---------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  hi2s->Instance->I2SCFGR &= ~(SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
 800634c:	687b      	ldr	r3, [r7, #4]
 800634e:	681a      	ldr	r2, [r3, #0]
 8006350:	687b      	ldr	r3, [r7, #4]
 8006352:	681b      	ldr	r3, [r3, #0]
 8006354:	69db      	ldr	r3, [r3, #28]
 8006356:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 800635a:	f023 030f 	bic.w	r3, r3, #15
 800635e:	61d3      	str	r3, [r2, #28]
                               SPI_I2SCFGR_I2SSTD | SPI_I2SCFGR_PCMSYNC | SPI_I2SCFGR_I2SCFG | \
                               SPI_I2SCFGR_I2SE | SPI_I2SCFGR_I2SMOD); 
  hi2s->Instance->I2SPR = 0x0002;
 8006360:	687b      	ldr	r3, [r7, #4]
 8006362:	681b      	ldr	r3, [r3, #0]
 8006364:	2202      	movs	r2, #2
 8006366:	621a      	str	r2, [r3, #32]

  /* Get the I2SCFGR register value */
  tmpreg = hi2s->Instance->I2SCFGR;
 8006368:	687b      	ldr	r3, [r7, #4]
 800636a:	681b      	ldr	r3, [r3, #0]
 800636c:	69db      	ldr	r3, [r3, #28]
 800636e:	60fb      	str	r3, [r7, #12]

  /* If the default frequency value has to be written, reinitialize i2sdiv and i2sodd */
  /* If the requested audio frequency is not the default, compute the prescaler */
  if(hi2s->Init.AudioFreq != I2S_AUDIOFREQ_DEFAULT)
 8006370:	687b      	ldr	r3, [r7, #4]
 8006372:	695b      	ldr	r3, [r3, #20]
 8006374:	2b02      	cmp	r3, #2
 8006376:	d041      	beq.n	80063fc <HAL_I2S_Init+0xfc>
  {
    /* Check the frame length (For the Prescaler computing) *******************/
    if(hi2s->Init.DataFormat != I2S_DATAFORMAT_16B)
 8006378:	687b      	ldr	r3, [r7, #4]
 800637a:	68db      	ldr	r3, [r3, #12]
 800637c:	2b00      	cmp	r3, #0
 800637e:	d001      	beq.n	8006384 <HAL_I2S_Init+0x84>
    {
      /* Packet length is 32 bits */
      packetlength = 2;
 8006380:	2302      	movs	r3, #2
 8006382:	617b      	str	r3, [r7, #20]
    }

    /* Get I2S source Clock frequency  ****************************************/
    i2sclk = I2S_GetInputClock(hi2s);
 8006384:	6878      	ldr	r0, [r7, #4]
 8006386:	f001 fd09 	bl	8007d9c <I2S_GetInputClock>
 800638a:	60b8      	str	r0, [r7, #8]

    /* Compute the Real divider depending on the MCLK output state, with a floating point */
    if(hi2s->Init.MCLKOutput == I2S_MCLKOUTPUT_ENABLE)
 800638c:	687b      	ldr	r3, [r7, #4]
 800638e:	691b      	ldr	r3, [r3, #16]
 8006390:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8006394:	d10d      	bne.n	80063b2 <HAL_I2S_Init+0xb2>
    {
      /* MCLK output is enabled */
      tmp = (uint32_t)(((((i2sclk / 256) * 10) / hi2s->Init.AudioFreq)) + 5);
 8006396:	68bb      	ldr	r3, [r7, #8]
 8006398:	0a1a      	lsrs	r2, r3, #8
 800639a:	4613      	mov	r3, r2
 800639c:	009b      	lsls	r3, r3, #2
 800639e:	4413      	add	r3, r2
 80063a0:	005b      	lsls	r3, r3, #1
 80063a2:	461a      	mov	r2, r3
 80063a4:	687b      	ldr	r3, [r7, #4]
 80063a6:	695b      	ldr	r3, [r3, #20]
 80063a8:	fbb2 f3f3 	udiv	r3, r2, r3
 80063ac:	3305      	adds	r3, #5
 80063ae:	613b      	str	r3, [r7, #16]
 80063b0:	e00f      	b.n	80063d2 <HAL_I2S_Init+0xd2>
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint32_t)(((((i2sclk / (32 * packetlength)) *10 ) / hi2s->Init.AudioFreq)) + 5);
 80063b2:	697b      	ldr	r3, [r7, #20]
 80063b4:	015b      	lsls	r3, r3, #5
 80063b6:	68ba      	ldr	r2, [r7, #8]
 80063b8:	fbb2 f2f3 	udiv	r2, r2, r3
 80063bc:	4613      	mov	r3, r2
 80063be:	009b      	lsls	r3, r3, #2
 80063c0:	4413      	add	r3, r2
 80063c2:	005b      	lsls	r3, r3, #1
 80063c4:	461a      	mov	r2, r3
 80063c6:	687b      	ldr	r3, [r7, #4]
 80063c8:	695b      	ldr	r3, [r3, #20]
 80063ca:	fbb2 f3f3 	udiv	r3, r2, r3
 80063ce:	3305      	adds	r3, #5
 80063d0:	613b      	str	r3, [r7, #16]
    }

    /* Remove the flatting point */
    tmp = tmp / 10;  
 80063d2:	693a      	ldr	r2, [r7, #16]
 80063d4:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 80063d8:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
 80063dc:	fba3 1302 	umull	r1, r3, r3, r2
 80063e0:	08db      	lsrs	r3, r3, #3
 80063e2:	613b      	str	r3, [r7, #16]

    /* Check the parity of the divider */
    i2sodd = (uint32_t)(tmp & (uint32_t)1);
 80063e4:	693b      	ldr	r3, [r7, #16]
 80063e6:	f003 0301 	and.w	r3, r3, #1
 80063ea:	61bb      	str	r3, [r7, #24]

    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint32_t)((tmp - i2sodd) / 2);
 80063ec:	693a      	ldr	r2, [r7, #16]
 80063ee:	69bb      	ldr	r3, [r7, #24]
 80063f0:	1ad3      	subs	r3, r2, r3
 80063f2:	085b      	lsrs	r3, r3, #1
 80063f4:	61fb      	str	r3, [r7, #28]

    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint32_t) (i2sodd << 8);
 80063f6:	69bb      	ldr	r3, [r7, #24]
 80063f8:	021b      	lsls	r3, r3, #8
 80063fa:	61bb      	str	r3, [r7, #24]
  }

  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if((i2sdiv < 2) || (i2sdiv > 0xFF))
 80063fc:	69fb      	ldr	r3, [r7, #28]
 80063fe:	2b01      	cmp	r3, #1
 8006400:	d902      	bls.n	8006408 <HAL_I2S_Init+0x108>
 8006402:	69fb      	ldr	r3, [r7, #28]
 8006404:	2bff      	cmp	r3, #255	; 0xff
 8006406:	d903      	bls.n	8006410 <HAL_I2S_Init+0x110>
  {
    /* Set the default values */
    i2sdiv = 2;
 8006408:	2302      	movs	r3, #2
 800640a:	61fb      	str	r3, [r7, #28]
    i2sodd = 0;
 800640c:	2300      	movs	r3, #0
 800640e:	61bb      	str	r3, [r7, #24]
  }
  
  /* Write to SPIx I2SPR register the computed value */
  hi2s->Instance->I2SPR = (uint32_t)((uint32_t)i2sdiv | (uint32_t)(i2sodd | (uint32_t)hi2s->Init.MCLKOutput));
 8006410:	687b      	ldr	r3, [r7, #4]
 8006412:	681b      	ldr	r3, [r3, #0]
 8006414:	687a      	ldr	r2, [r7, #4]
 8006416:	6911      	ldr	r1, [r2, #16]
 8006418:	69ba      	ldr	r2, [r7, #24]
 800641a:	4311      	orrs	r1, r2
 800641c:	69fa      	ldr	r2, [r7, #28]
 800641e:	430a      	orrs	r2, r1
 8006420:	621a      	str	r2, [r3, #32]
  
  /* Configure the I2S with the I2S_InitStruct values */
  tmpreg |= (uint32_t)(SPI_I2SCFGR_I2SMOD | hi2s->Init.Mode | hi2s->Init.Standard | hi2s->Init.DataFormat | hi2s->Init.CPOL);
 8006422:	687b      	ldr	r3, [r7, #4]
 8006424:	685a      	ldr	r2, [r3, #4]
 8006426:	687b      	ldr	r3, [r7, #4]
 8006428:	689b      	ldr	r3, [r3, #8]
 800642a:	431a      	orrs	r2, r3
 800642c:	687b      	ldr	r3, [r7, #4]
 800642e:	68db      	ldr	r3, [r3, #12]
 8006430:	431a      	orrs	r2, r3
 8006432:	687b      	ldr	r3, [r7, #4]
 8006434:	699b      	ldr	r3, [r3, #24]
 8006436:	431a      	orrs	r2, r3
 8006438:	68fb      	ldr	r3, [r7, #12]
 800643a:	4313      	orrs	r3, r2
 800643c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8006440:	60fb      	str	r3, [r7, #12]
  /* Write to SPIx I2SCFGR */  
  hi2s->Instance->I2SCFGR = tmpreg;    
  }
#else
  /* Write to SPIx I2SCFGR */  
  hi2s->Instance->I2SCFGR = tmpreg;
 8006442:	687b      	ldr	r3, [r7, #4]
 8006444:	681b      	ldr	r3, [r3, #0]
 8006446:	68fa      	ldr	r2, [r7, #12]
 8006448:	61da      	str	r2, [r3, #28]
#endif
      
  /* Configure the I2S extended if the full duplex mode is enabled */
  assert_param(IS_I2S_FULLDUPLEX_MODE(hi2s->Init.FullDuplexMode));
  if(hi2s->Init.FullDuplexMode == I2S_FULLDUPLEXMODE_ENABLE)
 800644a:	687b      	ldr	r3, [r7, #4]
 800644c:	6a1b      	ldr	r3, [r3, #32]
 800644e:	2b01      	cmp	r3, #1
 8006450:	d17e      	bne.n	8006550 <HAL_I2S_Init+0x250>
  {    
    /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    I2SxEXT(hi2s->Instance)->I2SCFGR &= ~(SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
 8006452:	687b      	ldr	r3, [r7, #4]
 8006454:	681a      	ldr	r2, [r3, #0]
 8006456:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800645a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800645e:	429a      	cmp	r2, r3
 8006460:	d104      	bne.n	800646c <HAL_I2S_Init+0x16c>
 8006462:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8006466:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800646a:	e001      	b.n	8006470 <HAL_I2S_Init+0x170>
 800646c:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8006470:	687a      	ldr	r2, [r7, #4]
 8006472:	6811      	ldr	r1, [r2, #0]
 8006474:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8006478:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800647c:	4291      	cmp	r1, r2
 800647e:	d104      	bne.n	800648a <HAL_I2S_Init+0x18a>
 8006480:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 8006484:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006488:	e001      	b.n	800648e <HAL_I2S_Init+0x18e>
 800648a:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 800648e:	69d2      	ldr	r2, [r2, #28]
 8006490:	f422 627b 	bic.w	r2, r2, #4016	; 0xfb0
 8006494:	f022 020f 	bic.w	r2, r2, #15
 8006498:	61da      	str	r2, [r3, #28]
                                          SPI_I2SCFGR_I2SSTD | SPI_I2SCFGR_PCMSYNC | SPI_I2SCFGR_I2SCFG | \
                                          SPI_I2SCFGR_I2SE | SPI_I2SCFGR_I2SMOD);
    I2SxEXT(hi2s->Instance)->I2SPR = 2;
 800649a:	687b      	ldr	r3, [r7, #4]
 800649c:	681a      	ldr	r2, [r3, #0]
 800649e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80064a2:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80064a6:	429a      	cmp	r2, r3
 80064a8:	d104      	bne.n	80064b4 <HAL_I2S_Init+0x1b4>
 80064aa:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 80064ae:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80064b2:	e001      	b.n	80064b8 <HAL_I2S_Init+0x1b8>
 80064b4:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 80064b8:	2202      	movs	r2, #2
 80064ba:	621a      	str	r2, [r3, #32]
    
    /* Get the I2SCFGR register value */
    tmpreg = I2SxEXT(hi2s->Instance)->I2SCFGR;
 80064bc:	687b      	ldr	r3, [r7, #4]
 80064be:	681a      	ldr	r2, [r3, #0]
 80064c0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80064c4:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80064c8:	429a      	cmp	r2, r3
 80064ca:	d104      	bne.n	80064d6 <HAL_I2S_Init+0x1d6>
 80064cc:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 80064d0:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80064d4:	e001      	b.n	80064da <HAL_I2S_Init+0x1da>
 80064d6:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 80064da:	69db      	ldr	r3, [r3, #28]
 80064dc:	60fb      	str	r3, [r7, #12]
    
    /* Get the mode to be configured for the extended I2S */
    if((hi2s->Init.Mode == I2S_MODE_MASTER_TX) || (hi2s->Init.Mode == I2S_MODE_SLAVE_TX))
 80064de:	687b      	ldr	r3, [r7, #4]
 80064e0:	685b      	ldr	r3, [r3, #4]
 80064e2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80064e6:	d003      	beq.n	80064f0 <HAL_I2S_Init+0x1f0>
 80064e8:	687b      	ldr	r3, [r7, #4]
 80064ea:	685b      	ldr	r3, [r3, #4]
 80064ec:	2b00      	cmp	r3, #0
 80064ee:	d103      	bne.n	80064f8 <HAL_I2S_Init+0x1f8>
    {
      tmp = I2S_MODE_SLAVE_RX;
 80064f0:	f44f 7380 	mov.w	r3, #256	; 0x100
 80064f4:	613b      	str	r3, [r7, #16]
 80064f6:	e00b      	b.n	8006510 <HAL_I2S_Init+0x210>
    }
    else
    {
      if((hi2s->Init.Mode == I2S_MODE_MASTER_RX) || (hi2s->Init.Mode == I2S_MODE_SLAVE_RX))
 80064f8:	687b      	ldr	r3, [r7, #4]
 80064fa:	685b      	ldr	r3, [r3, #4]
 80064fc:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8006500:	d004      	beq.n	800650c <HAL_I2S_Init+0x20c>
 8006502:	687b      	ldr	r3, [r7, #4]
 8006504:	685b      	ldr	r3, [r3, #4]
 8006506:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800650a:	d101      	bne.n	8006510 <HAL_I2S_Init+0x210>
      {
        tmp = I2S_MODE_SLAVE_TX;
 800650c:	2300      	movs	r3, #0
 800650e:	613b      	str	r3, [r7, #16]
      }
    }
    
    /* Configure the I2S Slave with the I2S Master parameter values */
    tmpreg |= (uint32_t)(SPI_I2SCFGR_I2SMOD | tmp | hi2s->Init.Standard | hi2s->Init.DataFormat | hi2s->Init.CPOL);
 8006510:	687b      	ldr	r3, [r7, #4]
 8006512:	689a      	ldr	r2, [r3, #8]
 8006514:	693b      	ldr	r3, [r7, #16]
 8006516:	431a      	orrs	r2, r3
 8006518:	687b      	ldr	r3, [r7, #4]
 800651a:	68db      	ldr	r3, [r3, #12]
 800651c:	431a      	orrs	r2, r3
 800651e:	687b      	ldr	r3, [r7, #4]
 8006520:	699b      	ldr	r3, [r3, #24]
 8006522:	431a      	orrs	r2, r3
 8006524:	68fb      	ldr	r3, [r7, #12]
 8006526:	4313      	orrs	r3, r2
 8006528:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800652c:	60fb      	str	r3, [r7, #12]
    
    /* Write to SPIx I2SCFGR */  
    I2SxEXT(hi2s->Instance)->I2SCFGR = tmpreg;
 800652e:	687b      	ldr	r3, [r7, #4]
 8006530:	681a      	ldr	r2, [r3, #0]
 8006532:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006536:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800653a:	429a      	cmp	r2, r3
 800653c:	d104      	bne.n	8006548 <HAL_I2S_Init+0x248>
 800653e:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8006542:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006546:	e001      	b.n	800654c <HAL_I2S_Init+0x24c>
 8006548:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800654c:	68fa      	ldr	r2, [r7, #12]
 800654e:	61da      	str	r2, [r3, #28]
  }
  
  hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
 8006550:	687b      	ldr	r3, [r7, #4]
 8006552:	2200      	movs	r2, #0
 8006554:	641a      	str	r2, [r3, #64]	; 0x40
  hi2s->State= HAL_I2S_STATE_READY;
 8006556:	687b      	ldr	r3, [r7, #4]
 8006558:	2201      	movs	r2, #1
 800655a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  return HAL_OK;
 800655e:	2300      	movs	r3, #0
}
 8006560:	4618      	mov	r0, r3
 8006562:	3720      	adds	r7, #32
 8006564:	46bd      	mov	sp, r7
 8006566:	bd80      	pop	{r7, pc}

08006568 <HAL_I2SEx_TransmitReceive>:
  * @note The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization 
  *       between Master and Slave(example: audio streaming).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2SEx_TransmitReceive(I2S_HandleTypeDef *hi2s, uint16_t *pTxData, uint16_t *pRxData, uint16_t Size, uint32_t Timeout)
{
 8006568:	b580      	push	{r7, lr}
 800656a:	b088      	sub	sp, #32
 800656c:	af00      	add	r7, sp, #0
 800656e:	60f8      	str	r0, [r7, #12]
 8006570:	60b9      	str	r1, [r7, #8]
 8006572:	607a      	str	r2, [r7, #4]
 8006574:	807b      	strh	r3, [r7, #2]
  uint32_t tickstart = 0;
 8006576:	2300      	movs	r3, #0
 8006578:	61fb      	str	r3, [r7, #28]
  uint32_t tmp1 = 0, tmp2 = 0;
 800657a:	2300      	movs	r3, #0
 800657c:	61bb      	str	r3, [r7, #24]
 800657e:	2300      	movs	r3, #0
 8006580:	617b      	str	r3, [r7, #20]
 
  if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0)) 
 8006582:	68bb      	ldr	r3, [r7, #8]
 8006584:	2b00      	cmp	r3, #0
 8006586:	d005      	beq.n	8006594 <HAL_I2SEx_TransmitReceive+0x2c>
 8006588:	687b      	ldr	r3, [r7, #4]
 800658a:	2b00      	cmp	r3, #0
 800658c:	d002      	beq.n	8006594 <HAL_I2SEx_TransmitReceive+0x2c>
 800658e:	887b      	ldrh	r3, [r7, #2]
 8006590:	2b00      	cmp	r3, #0
 8006592:	d101      	bne.n	8006598 <HAL_I2SEx_TransmitReceive+0x30>
  {
    return  HAL_ERROR;
 8006594:	2301      	movs	r3, #1
 8006596:	e1af      	b.n	80068f8 <HAL_I2SEx_TransmitReceive+0x390>
  }

  /* Check the I2S State */
  if(hi2s->State == HAL_I2S_STATE_READY)
 8006598:	68fb      	ldr	r3, [r7, #12]
 800659a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800659e:	b2db      	uxtb	r3, r3
 80065a0:	2b01      	cmp	r3, #1
 80065a2:	f040 81a8 	bne.w	80068f6 <HAL_I2SEx_TransmitReceive+0x38e>
  {  
    tmp1 = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 80065a6:	68fb      	ldr	r3, [r7, #12]
 80065a8:	681b      	ldr	r3, [r3, #0]
 80065aa:	69db      	ldr	r3, [r3, #28]
 80065ac:	f003 0307 	and.w	r3, r3, #7
 80065b0:	61bb      	str	r3, [r7, #24]
    tmp2 = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN); 
 80065b2:	68fb      	ldr	r3, [r7, #12]
 80065b4:	681b      	ldr	r3, [r3, #0]
 80065b6:	69db      	ldr	r3, [r3, #28]
 80065b8:	f003 0307 	and.w	r3, r3, #7
 80065bc:	617b      	str	r3, [r7, #20]
    /* Check the Data format: When a 16-bit data frame or a 16-bit data frame extended 
       is selected during the I2S configuration phase, the Size parameter means the number
       of 16-bit data length in the transaction and when a 24-bit data frame or a 32-bit data 
       frame is selected the Size parameter means the number of 16-bit data length. */
    if((tmp1 == I2S_DATAFORMAT_24B)|| \
 80065be:	69bb      	ldr	r3, [r7, #24]
 80065c0:	2b03      	cmp	r3, #3
 80065c2:	d002      	beq.n	80065ca <HAL_I2SEx_TransmitReceive+0x62>
 80065c4:	697b      	ldr	r3, [r7, #20]
 80065c6:	2b05      	cmp	r3, #5
 80065c8:	d114      	bne.n	80065f4 <HAL_I2SEx_TransmitReceive+0x8c>
       (tmp2 == I2S_DATAFORMAT_32B))
    {
      hi2s->TxXferSize = Size*2;
 80065ca:	887b      	ldrh	r3, [r7, #2]
 80065cc:	005b      	lsls	r3, r3, #1
 80065ce:	b29a      	uxth	r2, r3
 80065d0:	68fb      	ldr	r3, [r7, #12]
 80065d2:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2s->TxXferCount = Size*2;
 80065d4:	887b      	ldrh	r3, [r7, #2]
 80065d6:	005b      	lsls	r3, r3, #1
 80065d8:	b29a      	uxth	r2, r3
 80065da:	68fb      	ldr	r3, [r7, #12]
 80065dc:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2s->RxXferSize = Size*2;
 80065de:	887b      	ldrh	r3, [r7, #2]
 80065e0:	005b      	lsls	r3, r3, #1
 80065e2:	b29a      	uxth	r2, r3
 80065e4:	68fb      	ldr	r3, [r7, #12]
 80065e6:	861a      	strh	r2, [r3, #48]	; 0x30
      hi2s->RxXferCount = Size*2;
 80065e8:	887b      	ldrh	r3, [r7, #2]
 80065ea:	005b      	lsls	r3, r3, #1
 80065ec:	b29a      	uxth	r2, r3
 80065ee:	68fb      	ldr	r3, [r7, #12]
 80065f0:	865a      	strh	r2, [r3, #50]	; 0x32
 80065f2:	e00b      	b.n	800660c <HAL_I2SEx_TransmitReceive+0xa4>
    }
    else
    {
      hi2s->TxXferSize = Size;
 80065f4:	68fb      	ldr	r3, [r7, #12]
 80065f6:	887a      	ldrh	r2, [r7, #2]
 80065f8:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2s->TxXferCount = Size;
 80065fa:	68fb      	ldr	r3, [r7, #12]
 80065fc:	887a      	ldrh	r2, [r7, #2]
 80065fe:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2s->RxXferSize = Size;
 8006600:	68fb      	ldr	r3, [r7, #12]
 8006602:	887a      	ldrh	r2, [r7, #2]
 8006604:	861a      	strh	r2, [r3, #48]	; 0x30
      hi2s->RxXferCount = Size;
 8006606:	68fb      	ldr	r3, [r7, #12]
 8006608:	887a      	ldrh	r2, [r7, #2]
 800660a:	865a      	strh	r2, [r3, #50]	; 0x32
    }
    
    /* Process Locked */
    __HAL_LOCK(hi2s);
 800660c:	68fb      	ldr	r3, [r7, #12]
 800660e:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8006612:	b2db      	uxtb	r3, r3
 8006614:	2b01      	cmp	r3, #1
 8006616:	d101      	bne.n	800661c <HAL_I2SEx_TransmitReceive+0xb4>
 8006618:	2302      	movs	r3, #2
 800661a:	e16d      	b.n	80068f8 <HAL_I2SEx_TransmitReceive+0x390>
 800661c:	68fb      	ldr	r3, [r7, #12]
 800661e:	2201      	movs	r2, #1
 8006620:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    
    /* Set the I2S State busy TX/RX */
    hi2s->State = HAL_I2S_STATE_BUSY_TX_RX;
 8006624:	68fb      	ldr	r3, [r7, #12]
 8006626:	2232      	movs	r2, #50	; 0x32
 8006628:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    
    tmp1 = hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG;
 800662c:	68fb      	ldr	r3, [r7, #12]
 800662e:	681b      	ldr	r3, [r3, #0]
 8006630:	69db      	ldr	r3, [r3, #28]
 8006632:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8006636:	61bb      	str	r3, [r7, #24]
    tmp2 = hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG;
 8006638:	68fb      	ldr	r3, [r7, #12]
 800663a:	681b      	ldr	r3, [r3, #0]
 800663c:	69db      	ldr	r3, [r3, #28]
 800663e:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8006642:	617b      	str	r3, [r7, #20]
    /* Check if the I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX Mode is selected */
    if((tmp1 == I2S_MODE_MASTER_TX) || (tmp2 == I2S_MODE_SLAVE_TX))
 8006644:	69bb      	ldr	r3, [r7, #24]
 8006646:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800664a:	d003      	beq.n	8006654 <HAL_I2SEx_TransmitReceive+0xec>
 800664c:	697b      	ldr	r3, [r7, #20]
 800664e:	2b00      	cmp	r3, #0
 8006650:	f040 809b 	bne.w	800678a <HAL_I2SEx_TransmitReceive+0x222>
    { 
      /* Check if the I2S is already enabled: The I2S is kept enabled at the end of transaction
      to avoid the clock de-synchronization between Master and Slave. */ 
      if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
 8006654:	68fb      	ldr	r3, [r7, #12]
 8006656:	681b      	ldr	r3, [r3, #0]
 8006658:	69db      	ldr	r3, [r3, #28]
 800665a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800665e:	2b00      	cmp	r3, #0
 8006660:	d12a      	bne.n	80066b8 <HAL_I2SEx_TransmitReceive+0x150>
      {
        /* Enable I2Sext(receiver) before enabling I2Sx peripheral */
        I2SxEXT(hi2s->Instance)->I2SCFGR |= SPI_I2SCFGR_I2SE;
 8006662:	68fb      	ldr	r3, [r7, #12]
 8006664:	681a      	ldr	r2, [r3, #0]
 8006666:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800666a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800666e:	429a      	cmp	r2, r3
 8006670:	d104      	bne.n	800667c <HAL_I2SEx_TransmitReceive+0x114>
 8006672:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8006676:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800667a:	e001      	b.n	8006680 <HAL_I2SEx_TransmitReceive+0x118>
 800667c:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8006680:	68fa      	ldr	r2, [r7, #12]
 8006682:	6811      	ldr	r1, [r2, #0]
 8006684:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8006688:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800668c:	4291      	cmp	r1, r2
 800668e:	d104      	bne.n	800669a <HAL_I2SEx_TransmitReceive+0x132>
 8006690:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 8006694:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006698:	e001      	b.n	800669e <HAL_I2SEx_TransmitReceive+0x136>
 800669a:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 800669e:	69d2      	ldr	r2, [r2, #28]
 80066a0:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80066a4:	61da      	str	r2, [r3, #28]

        /* Enable I2Sx peripheral */
        __HAL_I2S_ENABLE(hi2s);
 80066a6:	68fb      	ldr	r3, [r7, #12]
 80066a8:	681b      	ldr	r3, [r3, #0]
 80066aa:	68fa      	ldr	r2, [r7, #12]
 80066ac:	6812      	ldr	r2, [r2, #0]
 80066ae:	69d2      	ldr	r2, [r2, #28]
 80066b0:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80066b4:	61da      	str	r2, [r3, #28]
      }
      
      while(hi2s->TxXferCount > 0)
 80066b6:	e062      	b.n	800677e <HAL_I2SEx_TransmitReceive+0x216>
 80066b8:	e061      	b.n	800677e <HAL_I2SEx_TransmitReceive+0x216>
      {
        /* Wait until TXE flag is set */
        if (I2S_WaitFlagStateUntilTimeout(hi2s, I2S_FLAG_TXE, RESET, Timeout) != HAL_OK)
 80066ba:	68f8      	ldr	r0, [r7, #12]
 80066bc:	2102      	movs	r1, #2
 80066be:	2200      	movs	r2, #0
 80066c0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80066c2:	f7ff fdc3 	bl	800624c <I2S_WaitFlagStateUntilTimeout>
 80066c6:	4603      	mov	r3, r0
 80066c8:	2b00      	cmp	r3, #0
 80066ca:	d001      	beq.n	80066d0 <HAL_I2SEx_TransmitReceive+0x168>
        {
          return HAL_TIMEOUT;
 80066cc:	2303      	movs	r3, #3
 80066ce:	e113      	b.n	80068f8 <HAL_I2SEx_TransmitReceive+0x390>
        }
        hi2s->Instance->DR = (*pTxData++);
 80066d0:	68fb      	ldr	r3, [r7, #12]
 80066d2:	681a      	ldr	r2, [r3, #0]
 80066d4:	68bb      	ldr	r3, [r7, #8]
 80066d6:	1c99      	adds	r1, r3, #2
 80066d8:	60b9      	str	r1, [r7, #8]
 80066da:	881b      	ldrh	r3, [r3, #0]
 80066dc:	60d3      	str	r3, [r2, #12]

        /* Get tick */
        tickstart = HAL_GetTick();
 80066de:	f7fb f973 	bl	80019c8 <HAL_GetTick>
 80066e2:	61f8      	str	r0, [r7, #28]

        /* Wait until RXNE flag is set */
        while((I2SxEXT(hi2s->Instance)->SR & SPI_SR_RXNE) != SPI_SR_RXNE)
 80066e4:	e014      	b.n	8006710 <HAL_I2SEx_TransmitReceive+0x1a8>
        {
          if(Timeout != HAL_MAX_DELAY)
 80066e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80066e8:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80066ec:	d010      	beq.n	8006710 <HAL_I2SEx_TransmitReceive+0x1a8>
          {
            if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 80066ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80066f0:	2b00      	cmp	r3, #0
 80066f2:	d007      	beq.n	8006704 <HAL_I2SEx_TransmitReceive+0x19c>
 80066f4:	f7fb f968 	bl	80019c8 <HAL_GetTick>
 80066f8:	4602      	mov	r2, r0
 80066fa:	69fb      	ldr	r3, [r7, #28]
 80066fc:	1ad2      	subs	r2, r2, r3
 80066fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006700:	429a      	cmp	r2, r3
 8006702:	d905      	bls.n	8006710 <HAL_I2SEx_TransmitReceive+0x1a8>
            {
              /* Process Unlocked */
              __HAL_UNLOCK(hi2s);
 8006704:	68fb      	ldr	r3, [r7, #12]
 8006706:	2200      	movs	r2, #0
 8006708:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

              return HAL_TIMEOUT;
 800670c:	2303      	movs	r3, #3
 800670e:	e0f3      	b.n	80068f8 <HAL_I2SEx_TransmitReceive+0x390>

        /* Get tick */
        tickstart = HAL_GetTick();

        /* Wait until RXNE flag is set */
        while((I2SxEXT(hi2s->Instance)->SR & SPI_SR_RXNE) != SPI_SR_RXNE)
 8006710:	68fb      	ldr	r3, [r7, #12]
 8006712:	681a      	ldr	r2, [r3, #0]
 8006714:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006718:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800671c:	429a      	cmp	r2, r3
 800671e:	d104      	bne.n	800672a <HAL_I2SEx_TransmitReceive+0x1c2>
 8006720:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8006724:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006728:	e001      	b.n	800672e <HAL_I2SEx_TransmitReceive+0x1c6>
 800672a:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800672e:	689b      	ldr	r3, [r3, #8]
 8006730:	f003 0301 	and.w	r3, r3, #1
 8006734:	2b00      	cmp	r3, #0
 8006736:	d0d6      	beq.n	80066e6 <HAL_I2SEx_TransmitReceive+0x17e>

              return HAL_TIMEOUT;
            }
          }
        }
        (*pRxData++) = I2SxEXT(hi2s->Instance)->DR;
 8006738:	687a      	ldr	r2, [r7, #4]
 800673a:	1c93      	adds	r3, r2, #2
 800673c:	607b      	str	r3, [r7, #4]
 800673e:	68fb      	ldr	r3, [r7, #12]
 8006740:	6819      	ldr	r1, [r3, #0]
 8006742:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006746:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800674a:	4299      	cmp	r1, r3
 800674c:	d104      	bne.n	8006758 <HAL_I2SEx_TransmitReceive+0x1f0>
 800674e:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8006752:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006756:	e001      	b.n	800675c <HAL_I2SEx_TransmitReceive+0x1f4>
 8006758:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800675c:	68db      	ldr	r3, [r3, #12]
 800675e:	b29b      	uxth	r3, r3
 8006760:	8013      	strh	r3, [r2, #0]
        
        hi2s->TxXferCount--;
 8006762:	68fb      	ldr	r3, [r7, #12]
 8006764:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8006766:	b29b      	uxth	r3, r3
 8006768:	3b01      	subs	r3, #1
 800676a:	b29a      	uxth	r2, r3
 800676c:	68fb      	ldr	r3, [r7, #12]
 800676e:	855a      	strh	r2, [r3, #42]	; 0x2a
        hi2s->RxXferCount--;
 8006770:	68fb      	ldr	r3, [r7, #12]
 8006772:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8006774:	b29b      	uxth	r3, r3
 8006776:	3b01      	subs	r3, #1
 8006778:	b29a      	uxth	r2, r3
 800677a:	68fb      	ldr	r3, [r7, #12]
 800677c:	865a      	strh	r2, [r3, #50]	; 0x32

        /* Enable I2Sx peripheral */
        __HAL_I2S_ENABLE(hi2s);
      }
      
      while(hi2s->TxXferCount > 0)
 800677e:	68fb      	ldr	r3, [r7, #12]
 8006780:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8006782:	b29b      	uxth	r3, r3
 8006784:	2b00      	cmp	r3, #0
 8006786:	d198      	bne.n	80066ba <HAL_I2SEx_TransmitReceive+0x152>
    hi2s->State = HAL_I2S_STATE_BUSY_TX_RX;
    
    tmp1 = hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG;
    tmp2 = hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG;
    /* Check if the I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX Mode is selected */
    if((tmp1 == I2S_MODE_MASTER_TX) || (tmp2 == I2S_MODE_SLAVE_TX))
 8006788:	e0ab      	b.n	80068e2 <HAL_I2SEx_TransmitReceive+0x37a>
    }
    /* The I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX Mode is selected */
    else
    {
      /* Check if the I2S is already enabled */ 
      if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
 800678a:	68fb      	ldr	r3, [r7, #12]
 800678c:	681b      	ldr	r3, [r3, #0]
 800678e:	69db      	ldr	r3, [r3, #28]
 8006790:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8006794:	2b00      	cmp	r3, #0
 8006796:	d12a      	bne.n	80067ee <HAL_I2SEx_TransmitReceive+0x286>
      {
        /* Enable I2S peripheral before the I2Sext*/
        __HAL_I2S_ENABLE(hi2s);
 8006798:	68fb      	ldr	r3, [r7, #12]
 800679a:	681b      	ldr	r3, [r3, #0]
 800679c:	68fa      	ldr	r2, [r7, #12]
 800679e:	6812      	ldr	r2, [r2, #0]
 80067a0:	69d2      	ldr	r2, [r2, #28]
 80067a2:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80067a6:	61da      	str	r2, [r3, #28]

        /* Enable I2Sext(transmitter) after enabling I2Sx peripheral */
        I2SxEXT(hi2s->Instance)->I2SCFGR |= SPI_I2SCFGR_I2SE;
 80067a8:	68fb      	ldr	r3, [r7, #12]
 80067aa:	681a      	ldr	r2, [r3, #0]
 80067ac:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80067b0:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80067b4:	429a      	cmp	r2, r3
 80067b6:	d104      	bne.n	80067c2 <HAL_I2SEx_TransmitReceive+0x25a>
 80067b8:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 80067bc:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80067c0:	e001      	b.n	80067c6 <HAL_I2SEx_TransmitReceive+0x25e>
 80067c2:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 80067c6:	68fa      	ldr	r2, [r7, #12]
 80067c8:	6811      	ldr	r1, [r2, #0]
 80067ca:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80067ce:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80067d2:	4291      	cmp	r1, r2
 80067d4:	d104      	bne.n	80067e0 <HAL_I2SEx_TransmitReceive+0x278>
 80067d6:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 80067da:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80067de:	e001      	b.n	80067e4 <HAL_I2SEx_TransmitReceive+0x27c>
 80067e0:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 80067e4:	69d2      	ldr	r2, [r2, #28]
 80067e6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80067ea:	61da      	str	r2, [r3, #28]
 80067ec:	e011      	b.n	8006812 <HAL_I2SEx_TransmitReceive+0x2aa>
      }
      else
      {
        /* Check if Master Receiver mode is selected */
        if((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG) == I2S_MODE_MASTER_RX)
 80067ee:	68fb      	ldr	r3, [r7, #12]
 80067f0:	681b      	ldr	r3, [r3, #0]
 80067f2:	69db      	ldr	r3, [r3, #28]
 80067f4:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80067f8:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80067fc:	d109      	bne.n	8006812 <HAL_I2SEx_TransmitReceive+0x2aa>
        {
          /* Clear the Overrun Flag by a read operation on the SPI_DR register followed by a read
          access to the SPI_SR register. */ 
          __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 80067fe:	68fb      	ldr	r3, [r7, #12]
 8006800:	681b      	ldr	r3, [r3, #0]
 8006802:	68db      	ldr	r3, [r3, #12]
 8006804:	613b      	str	r3, [r7, #16]
 8006806:	68fb      	ldr	r3, [r7, #12]
 8006808:	681b      	ldr	r3, [r3, #0]
 800680a:	689b      	ldr	r3, [r3, #8]
 800680c:	613b      	str	r3, [r7, #16]
 800680e:	693b      	ldr	r3, [r7, #16]
        }
      }
      while(hi2s->TxXferCount > 0)
 8006810:	e062      	b.n	80068d8 <HAL_I2SEx_TransmitReceive+0x370>
 8006812:	e061      	b.n	80068d8 <HAL_I2SEx_TransmitReceive+0x370>
      {
        /* Get tick */
        tickstart = HAL_GetTick();
 8006814:	f7fb f8d8 	bl	80019c8 <HAL_GetTick>
 8006818:	61f8      	str	r0, [r7, #28]

        /* Wait until TXE flag is set */
        while((I2SxEXT(hi2s->Instance)->SR & SPI_SR_TXE) != SPI_SR_TXE)
 800681a:	e014      	b.n	8006846 <HAL_I2SEx_TransmitReceive+0x2de>
        {
          if(Timeout != HAL_MAX_DELAY)
 800681c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800681e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8006822:	d010      	beq.n	8006846 <HAL_I2SEx_TransmitReceive+0x2de>
          {
            if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8006824:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006826:	2b00      	cmp	r3, #0
 8006828:	d007      	beq.n	800683a <HAL_I2SEx_TransmitReceive+0x2d2>
 800682a:	f7fb f8cd 	bl	80019c8 <HAL_GetTick>
 800682e:	4602      	mov	r2, r0
 8006830:	69fb      	ldr	r3, [r7, #28]
 8006832:	1ad2      	subs	r2, r2, r3
 8006834:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006836:	429a      	cmp	r2, r3
 8006838:	d905      	bls.n	8006846 <HAL_I2SEx_TransmitReceive+0x2de>
            {
              /* Process Unlocked */
              __HAL_UNLOCK(hi2s);
 800683a:	68fb      	ldr	r3, [r7, #12]
 800683c:	2200      	movs	r2, #0
 800683e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

              return HAL_TIMEOUT;
 8006842:	2303      	movs	r3, #3
 8006844:	e058      	b.n	80068f8 <HAL_I2SEx_TransmitReceive+0x390>
      {
        /* Get tick */
        tickstart = HAL_GetTick();

        /* Wait until TXE flag is set */
        while((I2SxEXT(hi2s->Instance)->SR & SPI_SR_TXE) != SPI_SR_TXE)
 8006846:	68fb      	ldr	r3, [r7, #12]
 8006848:	681a      	ldr	r2, [r3, #0]
 800684a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800684e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006852:	429a      	cmp	r2, r3
 8006854:	d104      	bne.n	8006860 <HAL_I2SEx_TransmitReceive+0x2f8>
 8006856:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 800685a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800685e:	e001      	b.n	8006864 <HAL_I2SEx_TransmitReceive+0x2fc>
 8006860:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8006864:	689b      	ldr	r3, [r3, #8]
 8006866:	f003 0302 	and.w	r3, r3, #2
 800686a:	2b00      	cmp	r3, #0
 800686c:	d0d6      	beq.n	800681c <HAL_I2SEx_TransmitReceive+0x2b4>

              return HAL_TIMEOUT;
            }
          }
        }
        I2SxEXT(hi2s->Instance)->DR = (*pTxData++);
 800686e:	68fb      	ldr	r3, [r7, #12]
 8006870:	681a      	ldr	r2, [r3, #0]
 8006872:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006876:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800687a:	429a      	cmp	r2, r3
 800687c:	d104      	bne.n	8006888 <HAL_I2SEx_TransmitReceive+0x320>
 800687e:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8006882:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006886:	e001      	b.n	800688c <HAL_I2SEx_TransmitReceive+0x324>
 8006888:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800688c:	68ba      	ldr	r2, [r7, #8]
 800688e:	1c91      	adds	r1, r2, #2
 8006890:	60b9      	str	r1, [r7, #8]
 8006892:	8812      	ldrh	r2, [r2, #0]
 8006894:	60da      	str	r2, [r3, #12]
        
        /* Wait until RXNE flag is set */
        if (I2S_WaitFlagStateUntilTimeout(hi2s, I2S_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8006896:	68f8      	ldr	r0, [r7, #12]
 8006898:	2101      	movs	r1, #1
 800689a:	2200      	movs	r2, #0
 800689c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800689e:	f7ff fcd5 	bl	800624c <I2S_WaitFlagStateUntilTimeout>
 80068a2:	4603      	mov	r3, r0
 80068a4:	2b00      	cmp	r3, #0
 80068a6:	d001      	beq.n	80068ac <HAL_I2SEx_TransmitReceive+0x344>
        {
          return HAL_TIMEOUT;
 80068a8:	2303      	movs	r3, #3
 80068aa:	e025      	b.n	80068f8 <HAL_I2SEx_TransmitReceive+0x390>
        }
        (*pRxData++) = hi2s->Instance->DR;
 80068ac:	687b      	ldr	r3, [r7, #4]
 80068ae:	1c9a      	adds	r2, r3, #2
 80068b0:	607a      	str	r2, [r7, #4]
 80068b2:	68fa      	ldr	r2, [r7, #12]
 80068b4:	6812      	ldr	r2, [r2, #0]
 80068b6:	68d2      	ldr	r2, [r2, #12]
 80068b8:	b292      	uxth	r2, r2
 80068ba:	801a      	strh	r2, [r3, #0]

        hi2s->TxXferCount--;
 80068bc:	68fb      	ldr	r3, [r7, #12]
 80068be:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80068c0:	b29b      	uxth	r3, r3
 80068c2:	3b01      	subs	r3, #1
 80068c4:	b29a      	uxth	r2, r3
 80068c6:	68fb      	ldr	r3, [r7, #12]
 80068c8:	855a      	strh	r2, [r3, #42]	; 0x2a
        hi2s->RxXferCount--;
 80068ca:	68fb      	ldr	r3, [r7, #12]
 80068cc:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 80068ce:	b29b      	uxth	r3, r3
 80068d0:	3b01      	subs	r3, #1
 80068d2:	b29a      	uxth	r2, r3
 80068d4:	68fb      	ldr	r3, [r7, #12]
 80068d6:	865a      	strh	r2, [r3, #50]	; 0x32
          /* Clear the Overrun Flag by a read operation on the SPI_DR register followed by a read
          access to the SPI_SR register. */ 
          __HAL_I2S_CLEAR_OVRFLAG(hi2s);
        }
      }
      while(hi2s->TxXferCount > 0)
 80068d8:	68fb      	ldr	r3, [r7, #12]
 80068da:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80068dc:	b29b      	uxth	r3, r3
 80068de:	2b00      	cmp	r3, #0
 80068e0:	d198      	bne.n	8006814 <HAL_I2SEx_TransmitReceive+0x2ac>
        hi2s->RxXferCount--;
      }
    }

    /* Set the I2S State ready */
    hi2s->State = HAL_I2S_STATE_READY; 
 80068e2:	68fb      	ldr	r3, [r7, #12]
 80068e4:	2201      	movs	r2, #1
 80068e6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Process Unlocked */
    __HAL_UNLOCK(hi2s);
 80068ea:	68fb      	ldr	r3, [r7, #12]
 80068ec:	2200      	movs	r2, #0
 80068ee:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    
    return HAL_OK;
 80068f2:	2300      	movs	r3, #0
 80068f4:	e000      	b.n	80068f8 <HAL_I2SEx_TransmitReceive+0x390>
  }
  else
  {
    return HAL_BUSY;
 80068f6:	2302      	movs	r3, #2
  }
}
 80068f8:	4618      	mov	r0, r3
 80068fa:	3720      	adds	r7, #32
 80068fc:	46bd      	mov	sp, r7
 80068fe:	bd80      	pop	{r7, pc}

08006900 <HAL_I2SEx_TransmitReceive_IT>:
  * @note The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization 
  *       between Master and Slave(example: audio streaming).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2SEx_TransmitReceive_IT(I2S_HandleTypeDef *hi2s, uint16_t *pTxData, uint16_t *pRxData, uint16_t Size)
{
 8006900:	b480      	push	{r7}
 8006902:	b087      	sub	sp, #28
 8006904:	af00      	add	r7, sp, #0
 8006906:	60f8      	str	r0, [r7, #12]
 8006908:	60b9      	str	r1, [r7, #8]
 800690a:	607a      	str	r2, [r7, #4]
 800690c:	807b      	strh	r3, [r7, #2]
  uint32_t tmp1 = 0, tmp2 = 0;
 800690e:	2300      	movs	r3, #0
 8006910:	617b      	str	r3, [r7, #20]
 8006912:	2300      	movs	r3, #0
 8006914:	613b      	str	r3, [r7, #16]
  
  if(hi2s->State == HAL_I2S_STATE_READY)
 8006916:	68fb      	ldr	r3, [r7, #12]
 8006918:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800691c:	b2db      	uxtb	r3, r3
 800691e:	2b01      	cmp	r3, #1
 8006920:	f040 8179 	bne.w	8006c16 <HAL_I2SEx_TransmitReceive_IT+0x316>
  {
    if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0)) 
 8006924:	68bb      	ldr	r3, [r7, #8]
 8006926:	2b00      	cmp	r3, #0
 8006928:	d005      	beq.n	8006936 <HAL_I2SEx_TransmitReceive_IT+0x36>
 800692a:	687b      	ldr	r3, [r7, #4]
 800692c:	2b00      	cmp	r3, #0
 800692e:	d002      	beq.n	8006936 <HAL_I2SEx_TransmitReceive_IT+0x36>
 8006930:	887b      	ldrh	r3, [r7, #2]
 8006932:	2b00      	cmp	r3, #0
 8006934:	d101      	bne.n	800693a <HAL_I2SEx_TransmitReceive_IT+0x3a>
    {
      return  HAL_ERROR;
 8006936:	2301      	movs	r3, #1
 8006938:	e16e      	b.n	8006c18 <HAL_I2SEx_TransmitReceive_IT+0x318>
    }

    hi2s->pTxBuffPtr = pTxData;
 800693a:	68fb      	ldr	r3, [r7, #12]
 800693c:	68ba      	ldr	r2, [r7, #8]
 800693e:	625a      	str	r2, [r3, #36]	; 0x24
    hi2s->pRxBuffPtr = pRxData;
 8006940:	68fb      	ldr	r3, [r7, #12]
 8006942:	687a      	ldr	r2, [r7, #4]
 8006944:	62da      	str	r2, [r3, #44]	; 0x2c

    tmp1 = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 8006946:	68fb      	ldr	r3, [r7, #12]
 8006948:	681b      	ldr	r3, [r3, #0]
 800694a:	69db      	ldr	r3, [r3, #28]
 800694c:	f003 0307 	and.w	r3, r3, #7
 8006950:	617b      	str	r3, [r7, #20]
    tmp2 = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 8006952:	68fb      	ldr	r3, [r7, #12]
 8006954:	681b      	ldr	r3, [r3, #0]
 8006956:	69db      	ldr	r3, [r3, #28]
 8006958:	f003 0307 	and.w	r3, r3, #7
 800695c:	613b      	str	r3, [r7, #16]
    /* Check the Data format: When a 16-bit data frame or a 16-bit data frame extended 
       is selected during the I2S configuration phase, the Size parameter means the number
       of 16-bit data length in the transaction and when a 24-bit data frame or a 32-bit data 
       frame is selected the Size parameter means the number of 16-bit data length. */
    if((tmp1 == I2S_DATAFORMAT_24B)||\
 800695e:	697b      	ldr	r3, [r7, #20]
 8006960:	2b03      	cmp	r3, #3
 8006962:	d002      	beq.n	800696a <HAL_I2SEx_TransmitReceive_IT+0x6a>
 8006964:	693b      	ldr	r3, [r7, #16]
 8006966:	2b05      	cmp	r3, #5
 8006968:	d114      	bne.n	8006994 <HAL_I2SEx_TransmitReceive_IT+0x94>
       (tmp2 == I2S_DATAFORMAT_32B))
    {
      hi2s->TxXferSize = Size*2;
 800696a:	887b      	ldrh	r3, [r7, #2]
 800696c:	005b      	lsls	r3, r3, #1
 800696e:	b29a      	uxth	r2, r3
 8006970:	68fb      	ldr	r3, [r7, #12]
 8006972:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2s->TxXferCount = Size*2;
 8006974:	887b      	ldrh	r3, [r7, #2]
 8006976:	005b      	lsls	r3, r3, #1
 8006978:	b29a      	uxth	r2, r3
 800697a:	68fb      	ldr	r3, [r7, #12]
 800697c:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2s->RxXferSize = Size*2;
 800697e:	887b      	ldrh	r3, [r7, #2]
 8006980:	005b      	lsls	r3, r3, #1
 8006982:	b29a      	uxth	r2, r3
 8006984:	68fb      	ldr	r3, [r7, #12]
 8006986:	861a      	strh	r2, [r3, #48]	; 0x30
      hi2s->RxXferCount = Size*2;
 8006988:	887b      	ldrh	r3, [r7, #2]
 800698a:	005b      	lsls	r3, r3, #1
 800698c:	b29a      	uxth	r2, r3
 800698e:	68fb      	ldr	r3, [r7, #12]
 8006990:	865a      	strh	r2, [r3, #50]	; 0x32
 8006992:	e00b      	b.n	80069ac <HAL_I2SEx_TransmitReceive_IT+0xac>
    }  
    else
    {
      hi2s->TxXferSize = Size;
 8006994:	68fb      	ldr	r3, [r7, #12]
 8006996:	887a      	ldrh	r2, [r7, #2]
 8006998:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2s->TxXferCount = Size;
 800699a:	68fb      	ldr	r3, [r7, #12]
 800699c:	887a      	ldrh	r2, [r7, #2]
 800699e:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2s->RxXferSize = Size;
 80069a0:	68fb      	ldr	r3, [r7, #12]
 80069a2:	887a      	ldrh	r2, [r7, #2]
 80069a4:	861a      	strh	r2, [r3, #48]	; 0x30
      hi2s->RxXferCount = Size;
 80069a6:	68fb      	ldr	r3, [r7, #12]
 80069a8:	887a      	ldrh	r2, [r7, #2]
 80069aa:	865a      	strh	r2, [r3, #50]	; 0x32
    }
    
    /* Process Locked */
    __HAL_LOCK(hi2s);
 80069ac:	68fb      	ldr	r3, [r7, #12]
 80069ae:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80069b2:	b2db      	uxtb	r3, r3
 80069b4:	2b01      	cmp	r3, #1
 80069b6:	d101      	bne.n	80069bc <HAL_I2SEx_TransmitReceive_IT+0xbc>
 80069b8:	2302      	movs	r3, #2
 80069ba:	e12d      	b.n	8006c18 <HAL_I2SEx_TransmitReceive_IT+0x318>
 80069bc:	68fb      	ldr	r3, [r7, #12]
 80069be:	2201      	movs	r2, #1
 80069c0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    
    hi2s->State = HAL_I2S_STATE_BUSY_TX_RX;
 80069c4:	68fb      	ldr	r3, [r7, #12]
 80069c6:	2232      	movs	r2, #50	; 0x32
 80069c8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
 80069cc:	68fb      	ldr	r3, [r7, #12]
 80069ce:	2200      	movs	r2, #0
 80069d0:	641a      	str	r2, [r3, #64]	; 0x40

    tmp1 = hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG;
 80069d2:	68fb      	ldr	r3, [r7, #12]
 80069d4:	681b      	ldr	r3, [r3, #0]
 80069d6:	69db      	ldr	r3, [r3, #28]
 80069d8:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80069dc:	617b      	str	r3, [r7, #20]
    tmp2 = hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG;
 80069de:	68fb      	ldr	r3, [r7, #12]
 80069e0:	681b      	ldr	r3, [r3, #0]
 80069e2:	69db      	ldr	r3, [r3, #28]
 80069e4:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80069e8:	613b      	str	r3, [r7, #16]
    /* Check if the I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX Mode is selected */
    if((tmp1 == I2S_MODE_MASTER_TX) || (tmp2 == I2S_MODE_SLAVE_TX))
 80069ea:	697b      	ldr	r3, [r7, #20]
 80069ec:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80069f0:	d002      	beq.n	80069f8 <HAL_I2SEx_TransmitReceive_IT+0xf8>
 80069f2:	693b      	ldr	r3, [r7, #16]
 80069f4:	2b00      	cmp	r3, #0
 80069f6:	d15c      	bne.n	8006ab2 <HAL_I2SEx_TransmitReceive_IT+0x1b2>
    { 
      /* Enable I2Sext RXNE and ERR interrupts */
      I2SxEXT(hi2s->Instance)->CR2 |= (I2S_IT_RXNE | I2S_IT_ERR);
 80069f8:	68fb      	ldr	r3, [r7, #12]
 80069fa:	681a      	ldr	r2, [r3, #0]
 80069fc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006a00:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006a04:	429a      	cmp	r2, r3
 8006a06:	d104      	bne.n	8006a12 <HAL_I2SEx_TransmitReceive_IT+0x112>
 8006a08:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8006a0c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006a10:	e001      	b.n	8006a16 <HAL_I2SEx_TransmitReceive_IT+0x116>
 8006a12:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8006a16:	68fa      	ldr	r2, [r7, #12]
 8006a18:	6811      	ldr	r1, [r2, #0]
 8006a1a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8006a1e:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006a22:	4291      	cmp	r1, r2
 8006a24:	d104      	bne.n	8006a30 <HAL_I2SEx_TransmitReceive_IT+0x130>
 8006a26:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 8006a2a:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006a2e:	e001      	b.n	8006a34 <HAL_I2SEx_TransmitReceive_IT+0x134>
 8006a30:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8006a34:	6852      	ldr	r2, [r2, #4]
 8006a36:	f042 0260 	orr.w	r2, r2, #96	; 0x60
 8006a3a:	605a      	str	r2, [r3, #4]

      /* Enable I2Sx TXE and ERR interrupts */
      __HAL_I2S_ENABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8006a3c:	68fb      	ldr	r3, [r7, #12]
 8006a3e:	681b      	ldr	r3, [r3, #0]
 8006a40:	68fa      	ldr	r2, [r7, #12]
 8006a42:	6812      	ldr	r2, [r2, #0]
 8006a44:	6852      	ldr	r2, [r2, #4]
 8006a46:	f042 02a0 	orr.w	r2, r2, #160	; 0xa0
 8006a4a:	605a      	str	r2, [r3, #4]

      /* Check if the I2S is already enabled */ 
      if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
 8006a4c:	68fb      	ldr	r3, [r7, #12]
 8006a4e:	681b      	ldr	r3, [r3, #0]
 8006a50:	69db      	ldr	r3, [r3, #28]
 8006a52:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8006a56:	2b00      	cmp	r3, #0
 8006a58:	d12a      	bne.n	8006ab0 <HAL_I2SEx_TransmitReceive_IT+0x1b0>
      {
        /* Enable I2Sext(receiver) before enabling I2Sx peripheral */
        I2SxEXT(hi2s->Instance)->I2SCFGR |= SPI_I2SCFGR_I2SE;
 8006a5a:	68fb      	ldr	r3, [r7, #12]
 8006a5c:	681a      	ldr	r2, [r3, #0]
 8006a5e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006a62:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006a66:	429a      	cmp	r2, r3
 8006a68:	d104      	bne.n	8006a74 <HAL_I2SEx_TransmitReceive_IT+0x174>
 8006a6a:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8006a6e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006a72:	e001      	b.n	8006a78 <HAL_I2SEx_TransmitReceive_IT+0x178>
 8006a74:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8006a78:	68fa      	ldr	r2, [r7, #12]
 8006a7a:	6811      	ldr	r1, [r2, #0]
 8006a7c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8006a80:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006a84:	4291      	cmp	r1, r2
 8006a86:	d104      	bne.n	8006a92 <HAL_I2SEx_TransmitReceive_IT+0x192>
 8006a88:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 8006a8c:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006a90:	e001      	b.n	8006a96 <HAL_I2SEx_TransmitReceive_IT+0x196>
 8006a92:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8006a96:	69d2      	ldr	r2, [r2, #28]
 8006a98:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8006a9c:	61da      	str	r2, [r3, #28]

        /* Enable I2Sx peripheral */
        __HAL_I2S_ENABLE(hi2s);
 8006a9e:	68fb      	ldr	r3, [r7, #12]
 8006aa0:	681b      	ldr	r3, [r3, #0]
 8006aa2:	68fa      	ldr	r2, [r7, #12]
 8006aa4:	6812      	ldr	r2, [r2, #0]
 8006aa6:	69d2      	ldr	r2, [r2, #28]
 8006aa8:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8006aac:	61da      	str	r2, [r3, #28]

      /* Enable I2Sx TXE and ERR interrupts */
      __HAL_I2S_ENABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));

      /* Check if the I2S is already enabled */ 
      if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
 8006aae:	e0ac      	b.n	8006c0a <HAL_I2SEx_TransmitReceive_IT+0x30a>
 8006ab0:	e0ab      	b.n	8006c0a <HAL_I2SEx_TransmitReceive_IT+0x30a>
    }
    /* The I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX Mode is selected */
    else
    {
      /* Enable I2Sext TXE and ERR interrupts */
      I2SxEXT(hi2s->Instance)->CR2 |= (I2S_IT_TXE |I2S_IT_ERR);
 8006ab2:	68fb      	ldr	r3, [r7, #12]
 8006ab4:	681a      	ldr	r2, [r3, #0]
 8006ab6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006aba:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006abe:	429a      	cmp	r2, r3
 8006ac0:	d104      	bne.n	8006acc <HAL_I2SEx_TransmitReceive_IT+0x1cc>
 8006ac2:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8006ac6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006aca:	e001      	b.n	8006ad0 <HAL_I2SEx_TransmitReceive_IT+0x1d0>
 8006acc:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8006ad0:	68fa      	ldr	r2, [r7, #12]
 8006ad2:	6811      	ldr	r1, [r2, #0]
 8006ad4:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8006ad8:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006adc:	4291      	cmp	r1, r2
 8006ade:	d104      	bne.n	8006aea <HAL_I2SEx_TransmitReceive_IT+0x1ea>
 8006ae0:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 8006ae4:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006ae8:	e001      	b.n	8006aee <HAL_I2SEx_TransmitReceive_IT+0x1ee>
 8006aea:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8006aee:	6852      	ldr	r2, [r2, #4]
 8006af0:	f042 02a0 	orr.w	r2, r2, #160	; 0xa0
 8006af4:	605a      	str	r2, [r3, #4]

      /* Enable I2Sext RXNE and ERR interrupts */
      __HAL_I2S_ENABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8006af6:	68fb      	ldr	r3, [r7, #12]
 8006af8:	681b      	ldr	r3, [r3, #0]
 8006afa:	68fa      	ldr	r2, [r7, #12]
 8006afc:	6812      	ldr	r2, [r2, #0]
 8006afe:	6852      	ldr	r2, [r2, #4]
 8006b00:	f042 0260 	orr.w	r2, r2, #96	; 0x60
 8006b04:	605a      	str	r2, [r3, #4]

      /* Check if the I2S is already enabled */ 
      if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
 8006b06:	68fb      	ldr	r3, [r7, #12]
 8006b08:	681b      	ldr	r3, [r3, #0]
 8006b0a:	69db      	ldr	r3, [r3, #28]
 8006b0c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8006b10:	2b00      	cmp	r3, #0
 8006b12:	d17a      	bne.n	8006c0a <HAL_I2SEx_TransmitReceive_IT+0x30a>
      {
        /* Check if the I2S_MODE_MASTER_RX is selected */
        if((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG) == I2S_MODE_MASTER_RX) 
 8006b14:	68fb      	ldr	r3, [r7, #12]
 8006b16:	681b      	ldr	r3, [r3, #0]
 8006b18:	69db      	ldr	r3, [r3, #28]
 8006b1a:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8006b1e:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8006b22:	d148      	bne.n	8006bb6 <HAL_I2SEx_TransmitReceive_IT+0x2b6>
        {
          /* Prepare the First Data before enabling the I2S */
          if(hi2s->TxXferCount != 0)
 8006b24:	68fb      	ldr	r3, [r7, #12]
 8006b26:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8006b28:	b29b      	uxth	r3, r3
 8006b2a:	2b00      	cmp	r3, #0
 8006b2c:	d043      	beq.n	8006bb6 <HAL_I2SEx_TransmitReceive_IT+0x2b6>
          {
            /* Transmit First data */
            I2SxEXT(hi2s->Instance)->DR = (*hi2s->pTxBuffPtr++);
 8006b2e:	68fb      	ldr	r3, [r7, #12]
 8006b30:	681a      	ldr	r2, [r3, #0]
 8006b32:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006b36:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006b3a:	429a      	cmp	r2, r3
 8006b3c:	d104      	bne.n	8006b48 <HAL_I2SEx_TransmitReceive_IT+0x248>
 8006b3e:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8006b42:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006b46:	e001      	b.n	8006b4c <HAL_I2SEx_TransmitReceive_IT+0x24c>
 8006b48:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8006b4c:	68fa      	ldr	r2, [r7, #12]
 8006b4e:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8006b50:	1c90      	adds	r0, r2, #2
 8006b52:	68f9      	ldr	r1, [r7, #12]
 8006b54:	6248      	str	r0, [r1, #36]	; 0x24
 8006b56:	8812      	ldrh	r2, [r2, #0]
 8006b58:	60da      	str	r2, [r3, #12]
            hi2s->TxXferCount--;	
 8006b5a:	68fb      	ldr	r3, [r7, #12]
 8006b5c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8006b5e:	b29b      	uxth	r3, r3
 8006b60:	3b01      	subs	r3, #1
 8006b62:	b29a      	uxth	r2, r3
 8006b64:	68fb      	ldr	r3, [r7, #12]
 8006b66:	855a      	strh	r2, [r3, #42]	; 0x2a

            if(hi2s->TxXferCount == 0)
 8006b68:	68fb      	ldr	r3, [r7, #12]
 8006b6a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8006b6c:	b29b      	uxth	r3, r3
 8006b6e:	2b00      	cmp	r3, #0
 8006b70:	d121      	bne.n	8006bb6 <HAL_I2SEx_TransmitReceive_IT+0x2b6>
            {
              /* Disable I2Sext TXE interrupt */
              I2SxEXT(hi2s->Instance)->CR2 &= ~I2S_IT_TXE;
 8006b72:	68fb      	ldr	r3, [r7, #12]
 8006b74:	681a      	ldr	r2, [r3, #0]
 8006b76:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006b7a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006b7e:	429a      	cmp	r2, r3
 8006b80:	d104      	bne.n	8006b8c <HAL_I2SEx_TransmitReceive_IT+0x28c>
 8006b82:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8006b86:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006b8a:	e001      	b.n	8006b90 <HAL_I2SEx_TransmitReceive_IT+0x290>
 8006b8c:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8006b90:	68fa      	ldr	r2, [r7, #12]
 8006b92:	6811      	ldr	r1, [r2, #0]
 8006b94:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8006b98:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006b9c:	4291      	cmp	r1, r2
 8006b9e:	d104      	bne.n	8006baa <HAL_I2SEx_TransmitReceive_IT+0x2aa>
 8006ba0:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 8006ba4:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006ba8:	e001      	b.n	8006bae <HAL_I2SEx_TransmitReceive_IT+0x2ae>
 8006baa:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8006bae:	6852      	ldr	r2, [r2, #4]
 8006bb0:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8006bb4:	605a      	str	r2, [r3, #4]
            }
          }
        }
        /* Enable I2S peripheral */
        __HAL_I2S_ENABLE(hi2s);
 8006bb6:	68fb      	ldr	r3, [r7, #12]
 8006bb8:	681b      	ldr	r3, [r3, #0]
 8006bba:	68fa      	ldr	r2, [r7, #12]
 8006bbc:	6812      	ldr	r2, [r2, #0]
 8006bbe:	69d2      	ldr	r2, [r2, #28]
 8006bc0:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8006bc4:	61da      	str	r2, [r3, #28]
        
        /* Enable I2Sext(transmitter) after enabling I2Sx peripheral */
        I2SxEXT(hi2s->Instance)->I2SCFGR |= SPI_I2SCFGR_I2SE;
 8006bc6:	68fb      	ldr	r3, [r7, #12]
 8006bc8:	681a      	ldr	r2, [r3, #0]
 8006bca:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006bce:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006bd2:	429a      	cmp	r2, r3
 8006bd4:	d104      	bne.n	8006be0 <HAL_I2SEx_TransmitReceive_IT+0x2e0>
 8006bd6:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8006bda:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006bde:	e001      	b.n	8006be4 <HAL_I2SEx_TransmitReceive_IT+0x2e4>
 8006be0:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8006be4:	68fa      	ldr	r2, [r7, #12]
 8006be6:	6811      	ldr	r1, [r2, #0]
 8006be8:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8006bec:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006bf0:	4291      	cmp	r1, r2
 8006bf2:	d104      	bne.n	8006bfe <HAL_I2SEx_TransmitReceive_IT+0x2fe>
 8006bf4:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 8006bf8:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006bfc:	e001      	b.n	8006c02 <HAL_I2SEx_TransmitReceive_IT+0x302>
 8006bfe:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8006c02:	69d2      	ldr	r2, [r2, #28]
 8006c04:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8006c08:	61da      	str	r2, [r3, #28]
      }
    }
    /* Process Unlocked */
    __HAL_UNLOCK(hi2s);
 8006c0a:	68fb      	ldr	r3, [r7, #12]
 8006c0c:	2200      	movs	r2, #0
 8006c0e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    return HAL_OK;
 8006c12:	2300      	movs	r3, #0
 8006c14:	e000      	b.n	8006c18 <HAL_I2SEx_TransmitReceive_IT+0x318>
  }
  else
  {
    return HAL_BUSY;
 8006c16:	2302      	movs	r3, #2
  }
}
 8006c18:	4618      	mov	r0, r3
 8006c1a:	371c      	adds	r7, #28
 8006c1c:	46bd      	mov	sp, r7
 8006c1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006c22:	4770      	bx	lr

08006c24 <HAL_I2SEx_TransmitReceive_DMA>:
  * @note The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization 
  *       between Master and Slave(example: audio streaming).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2SEx_TransmitReceive_DMA(I2S_HandleTypeDef *hi2s, uint16_t *pTxData, uint16_t *pRxData, uint16_t Size)
{
 8006c24:	b580      	push	{r7, lr}
 8006c26:	b088      	sub	sp, #32
 8006c28:	af00      	add	r7, sp, #0
 8006c2a:	60f8      	str	r0, [r7, #12]
 8006c2c:	60b9      	str	r1, [r7, #8]
 8006c2e:	607a      	str	r2, [r7, #4]
 8006c30:	807b      	strh	r3, [r7, #2]
  uint32_t *tmp;
  uint32_t tmp1 = 0, tmp2 = 0;
 8006c32:	2300      	movs	r3, #0
 8006c34:	61fb      	str	r3, [r7, #28]
 8006c36:	2300      	movs	r3, #0
 8006c38:	61bb      	str	r3, [r7, #24]
    
  if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0)) 
 8006c3a:	68bb      	ldr	r3, [r7, #8]
 8006c3c:	2b00      	cmp	r3, #0
 8006c3e:	d005      	beq.n	8006c4c <HAL_I2SEx_TransmitReceive_DMA+0x28>
 8006c40:	687b      	ldr	r3, [r7, #4]
 8006c42:	2b00      	cmp	r3, #0
 8006c44:	d002      	beq.n	8006c4c <HAL_I2SEx_TransmitReceive_DMA+0x28>
 8006c46:	887b      	ldrh	r3, [r7, #2]
 8006c48:	2b00      	cmp	r3, #0
 8006c4a:	d101      	bne.n	8006c50 <HAL_I2SEx_TransmitReceive_DMA+0x2c>
  {
    return  HAL_ERROR;
 8006c4c:	2301      	movs	r3, #1
 8006c4e:	e1b9      	b.n	8006fc4 <HAL_I2SEx_TransmitReceive_DMA+0x3a0>
  }

  if(hi2s->State == HAL_I2S_STATE_READY)
 8006c50:	68fb      	ldr	r3, [r7, #12]
 8006c52:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8006c56:	b2db      	uxtb	r3, r3
 8006c58:	2b01      	cmp	r3, #1
 8006c5a:	f040 81b2 	bne.w	8006fc2 <HAL_I2SEx_TransmitReceive_DMA+0x39e>
  {
    hi2s->pTxBuffPtr = pTxData;
 8006c5e:	68ba      	ldr	r2, [r7, #8]
 8006c60:	68fb      	ldr	r3, [r7, #12]
 8006c62:	625a      	str	r2, [r3, #36]	; 0x24
    hi2s->pRxBuffPtr = pRxData;
 8006c64:	687a      	ldr	r2, [r7, #4]
 8006c66:	68fb      	ldr	r3, [r7, #12]
 8006c68:	62da      	str	r2, [r3, #44]	; 0x2c

    tmp1 = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 8006c6a:	68fb      	ldr	r3, [r7, #12]
 8006c6c:	681b      	ldr	r3, [r3, #0]
 8006c6e:	69db      	ldr	r3, [r3, #28]
 8006c70:	f003 0307 	and.w	r3, r3, #7
 8006c74:	61fb      	str	r3, [r7, #28]
    tmp2 = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 8006c76:	68fb      	ldr	r3, [r7, #12]
 8006c78:	681b      	ldr	r3, [r3, #0]
 8006c7a:	69db      	ldr	r3, [r3, #28]
 8006c7c:	f003 0307 	and.w	r3, r3, #7
 8006c80:	61bb      	str	r3, [r7, #24]
    /* Check the Data format: When a 16-bit data frame or a 16-bit data frame extended 
       is selected during the I2S configuration phase, the Size parameter means the number
       of 16-bit data length in the transaction and when a 24-bit data frame or a 32-bit data 
       frame is selected the Size parameter means the number of 16-bit data length. */
    if((tmp1 == I2S_DATAFORMAT_24B)||\
 8006c82:	69fb      	ldr	r3, [r7, #28]
 8006c84:	2b03      	cmp	r3, #3
 8006c86:	d002      	beq.n	8006c8e <HAL_I2SEx_TransmitReceive_DMA+0x6a>
 8006c88:	69bb      	ldr	r3, [r7, #24]
 8006c8a:	2b05      	cmp	r3, #5
 8006c8c:	d114      	bne.n	8006cb8 <HAL_I2SEx_TransmitReceive_DMA+0x94>
       (tmp2 == I2S_DATAFORMAT_32B))
    {
      hi2s->TxXferSize = Size*2;
 8006c8e:	887b      	ldrh	r3, [r7, #2]
 8006c90:	005b      	lsls	r3, r3, #1
 8006c92:	b29a      	uxth	r2, r3
 8006c94:	68fb      	ldr	r3, [r7, #12]
 8006c96:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2s->TxXferCount = Size*2;
 8006c98:	887b      	ldrh	r3, [r7, #2]
 8006c9a:	005b      	lsls	r3, r3, #1
 8006c9c:	b29a      	uxth	r2, r3
 8006c9e:	68fb      	ldr	r3, [r7, #12]
 8006ca0:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2s->RxXferSize = Size*2;
 8006ca2:	887b      	ldrh	r3, [r7, #2]
 8006ca4:	005b      	lsls	r3, r3, #1
 8006ca6:	b29a      	uxth	r2, r3
 8006ca8:	68fb      	ldr	r3, [r7, #12]
 8006caa:	861a      	strh	r2, [r3, #48]	; 0x30
      hi2s->RxXferCount = Size*2;
 8006cac:	887b      	ldrh	r3, [r7, #2]
 8006cae:	005b      	lsls	r3, r3, #1
 8006cb0:	b29a      	uxth	r2, r3
 8006cb2:	68fb      	ldr	r3, [r7, #12]
 8006cb4:	865a      	strh	r2, [r3, #50]	; 0x32
 8006cb6:	e00b      	b.n	8006cd0 <HAL_I2SEx_TransmitReceive_DMA+0xac>
    }
    else
    {
      hi2s->TxXferSize = Size;
 8006cb8:	68fb      	ldr	r3, [r7, #12]
 8006cba:	887a      	ldrh	r2, [r7, #2]
 8006cbc:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2s->TxXferCount = Size;
 8006cbe:	68fb      	ldr	r3, [r7, #12]
 8006cc0:	887a      	ldrh	r2, [r7, #2]
 8006cc2:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2s->RxXferSize = Size;
 8006cc4:	68fb      	ldr	r3, [r7, #12]
 8006cc6:	887a      	ldrh	r2, [r7, #2]
 8006cc8:	861a      	strh	r2, [r3, #48]	; 0x30
      hi2s->RxXferCount = Size;
 8006cca:	68fb      	ldr	r3, [r7, #12]
 8006ccc:	887a      	ldrh	r2, [r7, #2]
 8006cce:	865a      	strh	r2, [r3, #50]	; 0x32
    }

    /* Process Locked */
    __HAL_LOCK(hi2s);
 8006cd0:	68fb      	ldr	r3, [r7, #12]
 8006cd2:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8006cd6:	b2db      	uxtb	r3, r3
 8006cd8:	2b01      	cmp	r3, #1
 8006cda:	d101      	bne.n	8006ce0 <HAL_I2SEx_TransmitReceive_DMA+0xbc>
 8006cdc:	2302      	movs	r3, #2
 8006cde:	e171      	b.n	8006fc4 <HAL_I2SEx_TransmitReceive_DMA+0x3a0>
 8006ce0:	68fb      	ldr	r3, [r7, #12]
 8006ce2:	2201      	movs	r2, #1
 8006ce4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    hi2s->State = HAL_I2S_STATE_BUSY_TX_RX;
 8006ce8:	68fb      	ldr	r3, [r7, #12]
 8006cea:	2232      	movs	r2, #50	; 0x32
 8006cec:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
 8006cf0:	68fb      	ldr	r3, [r7, #12]
 8006cf2:	2200      	movs	r2, #0
 8006cf4:	641a      	str	r2, [r3, #64]	; 0x40

    /* Set the I2S Rx DMA Half transfer complete callback */
    hi2s->hdmarx->XferHalfCpltCallback = I2S_DMARxHalfCplt;
 8006cf6:	68fb      	ldr	r3, [r7, #12]
 8006cf8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8006cfa:	f246 03a9 	movw	r3, #24745	; 0x60a9
 8006cfe:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006d02:	6413      	str	r3, [r2, #64]	; 0x40

    /* Set the I2S Rx DMA transfer complete callback */
    hi2s->hdmarx->XferCpltCallback = I2S_DMARxCplt;
 8006d04:	68fb      	ldr	r3, [r7, #12]
 8006d06:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8006d08:	f647 43e9 	movw	r3, #31977	; 0x7ce9
 8006d0c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006d10:	63d3      	str	r3, [r2, #60]	; 0x3c

    /* Set the I2S Rx DMA error callback */
    hi2s->hdmarx->XferErrorCallback = I2S_DMAError;
 8006d12:	68fb      	ldr	r3, [r7, #12]
 8006d14:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8006d16:	f246 03c5 	movw	r3, #24773	; 0x60c5
 8006d1a:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006d1e:	6493      	str	r3, [r2, #72]	; 0x48

    /* Set the I2S Tx DMA Half transfer complete callback */
    hi2s->hdmatx->XferHalfCpltCallback = I2S_DMATxHalfCplt;
 8006d20:	68fb      	ldr	r3, [r7, #12]
 8006d22:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8006d24:	f246 038d 	movw	r3, #24717	; 0x608d
 8006d28:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006d2c:	6413      	str	r3, [r2, #64]	; 0x40

    /* Set the I2S Tx DMA transfer complete callback */
    hi2s->hdmatx->XferCpltCallback = I2S_DMATxCplt;
 8006d2e:	68fb      	ldr	r3, [r7, #12]
 8006d30:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8006d32:	f647 4335 	movw	r3, #31797	; 0x7c35
 8006d36:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006d3a:	63d3      	str	r3, [r2, #60]	; 0x3c

    /* Set the I2S Tx DMA error callback */
    hi2s->hdmatx->XferErrorCallback = I2S_DMAError;
 8006d3c:	68fb      	ldr	r3, [r7, #12]
 8006d3e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8006d40:	f246 03c5 	movw	r3, #24773	; 0x60c5
 8006d44:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006d48:	6493      	str	r3, [r2, #72]	; 0x48

    tmp1 = hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG;
 8006d4a:	68fb      	ldr	r3, [r7, #12]
 8006d4c:	681b      	ldr	r3, [r3, #0]
 8006d4e:	69db      	ldr	r3, [r3, #28]
 8006d50:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8006d54:	61fb      	str	r3, [r7, #28]
    tmp2 = hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG;
 8006d56:	68fb      	ldr	r3, [r7, #12]
 8006d58:	681b      	ldr	r3, [r3, #0]
 8006d5a:	69db      	ldr	r3, [r3, #28]
 8006d5c:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8006d60:	61bb      	str	r3, [r7, #24]
    /* Check if the I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX Mode is selected */
    if((tmp1 == I2S_MODE_MASTER_TX) || (tmp2 == I2S_MODE_SLAVE_TX))
 8006d62:	69fb      	ldr	r3, [r7, #28]
 8006d64:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8006d68:	d003      	beq.n	8006d72 <HAL_I2SEx_TransmitReceive_DMA+0x14e>
 8006d6a:	69bb      	ldr	r3, [r7, #24]
 8006d6c:	2b00      	cmp	r3, #0
 8006d6e:	f040 8089 	bne.w	8006e84 <HAL_I2SEx_TransmitReceive_DMA+0x260>
    {
      /* Enable the Rx DMA Stream */
      tmp = (uint32_t*)&pRxData;
 8006d72:	1d3b      	adds	r3, r7, #4
 8006d74:	617b      	str	r3, [r7, #20]
      HAL_DMA_Start_IT(hi2s->hdmarx, (uint32_t)&I2SxEXT(hi2s->Instance)->DR, *(uint32_t*)tmp, hi2s->RxXferSize);
 8006d76:	68fb      	ldr	r3, [r7, #12]
 8006d78:	6b98      	ldr	r0, [r3, #56]	; 0x38
 8006d7a:	68fb      	ldr	r3, [r7, #12]
 8006d7c:	681a      	ldr	r2, [r3, #0]
 8006d7e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006d82:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006d86:	429a      	cmp	r2, r3
 8006d88:	d104      	bne.n	8006d94 <HAL_I2SEx_TransmitReceive_DMA+0x170>
 8006d8a:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8006d8e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006d92:	e001      	b.n	8006d98 <HAL_I2SEx_TransmitReceive_DMA+0x174>
 8006d94:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8006d98:	330c      	adds	r3, #12
 8006d9a:	4619      	mov	r1, r3
 8006d9c:	697b      	ldr	r3, [r7, #20]
 8006d9e:	681a      	ldr	r2, [r3, #0]
 8006da0:	68fb      	ldr	r3, [r7, #12]
 8006da2:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 8006da4:	b29b      	uxth	r3, r3
 8006da6:	f7fd fbff 	bl	80045a8 <HAL_DMA_Start_IT>

      /* Enable Rx DMA Request */  
      I2SxEXT(hi2s->Instance)->CR2 |= SPI_CR2_RXDMAEN;
 8006daa:	68fb      	ldr	r3, [r7, #12]
 8006dac:	681a      	ldr	r2, [r3, #0]
 8006dae:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006db2:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006db6:	429a      	cmp	r2, r3
 8006db8:	d104      	bne.n	8006dc4 <HAL_I2SEx_TransmitReceive_DMA+0x1a0>
 8006dba:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8006dbe:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006dc2:	e001      	b.n	8006dc8 <HAL_I2SEx_TransmitReceive_DMA+0x1a4>
 8006dc4:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8006dc8:	68fa      	ldr	r2, [r7, #12]
 8006dca:	6811      	ldr	r1, [r2, #0]
 8006dcc:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8006dd0:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006dd4:	4291      	cmp	r1, r2
 8006dd6:	d104      	bne.n	8006de2 <HAL_I2SEx_TransmitReceive_DMA+0x1be>
 8006dd8:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 8006ddc:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006de0:	e001      	b.n	8006de6 <HAL_I2SEx_TransmitReceive_DMA+0x1c2>
 8006de2:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8006de6:	6852      	ldr	r2, [r2, #4]
 8006de8:	f042 0201 	orr.w	r2, r2, #1
 8006dec:	605a      	str	r2, [r3, #4]

      /* Enable the Tx DMA Stream */
      tmp = (uint32_t*)&pTxData;
 8006dee:	f107 0308 	add.w	r3, r7, #8
 8006df2:	617b      	str	r3, [r7, #20]
      HAL_DMA_Start_IT(hi2s->hdmatx, *(uint32_t*)tmp, (uint32_t)&hi2s->Instance->DR, hi2s->TxXferSize);
 8006df4:	68fb      	ldr	r3, [r7, #12]
 8006df6:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8006df8:	697b      	ldr	r3, [r7, #20]
 8006dfa:	6819      	ldr	r1, [r3, #0]
 8006dfc:	68fb      	ldr	r3, [r7, #12]
 8006dfe:	681b      	ldr	r3, [r3, #0]
 8006e00:	330c      	adds	r3, #12
 8006e02:	461a      	mov	r2, r3
 8006e04:	68fb      	ldr	r3, [r7, #12]
 8006e06:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8006e08:	b29b      	uxth	r3, r3
 8006e0a:	f7fd fbcd 	bl	80045a8 <HAL_DMA_Start_IT>

      /* Enable Tx DMA Request */  
      hi2s->Instance->CR2 |= SPI_CR2_TXDMAEN;
 8006e0e:	68fb      	ldr	r3, [r7, #12]
 8006e10:	681b      	ldr	r3, [r3, #0]
 8006e12:	68fa      	ldr	r2, [r7, #12]
 8006e14:	6812      	ldr	r2, [r2, #0]
 8006e16:	6852      	ldr	r2, [r2, #4]
 8006e18:	f042 0202 	orr.w	r2, r2, #2
 8006e1c:	605a      	str	r2, [r3, #4]

      /* Check if the I2S is already enabled */ 
      if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
 8006e1e:	68fb      	ldr	r3, [r7, #12]
 8006e20:	681b      	ldr	r3, [r3, #0]
 8006e22:	69db      	ldr	r3, [r3, #28]
 8006e24:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8006e28:	2b00      	cmp	r3, #0
 8006e2a:	d12a      	bne.n	8006e82 <HAL_I2SEx_TransmitReceive_DMA+0x25e>
      {
        /* Enable I2Sext(receiver) before enabling I2Sx peripheral */
        I2SxEXT(hi2s->Instance)->I2SCFGR |= SPI_I2SCFGR_I2SE;
 8006e2c:	68fb      	ldr	r3, [r7, #12]
 8006e2e:	681a      	ldr	r2, [r3, #0]
 8006e30:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006e34:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006e38:	429a      	cmp	r2, r3
 8006e3a:	d104      	bne.n	8006e46 <HAL_I2SEx_TransmitReceive_DMA+0x222>
 8006e3c:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8006e40:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006e44:	e001      	b.n	8006e4a <HAL_I2SEx_TransmitReceive_DMA+0x226>
 8006e46:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8006e4a:	68fa      	ldr	r2, [r7, #12]
 8006e4c:	6811      	ldr	r1, [r2, #0]
 8006e4e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8006e52:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006e56:	4291      	cmp	r1, r2
 8006e58:	d104      	bne.n	8006e64 <HAL_I2SEx_TransmitReceive_DMA+0x240>
 8006e5a:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 8006e5e:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006e62:	e001      	b.n	8006e68 <HAL_I2SEx_TransmitReceive_DMA+0x244>
 8006e64:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8006e68:	69d2      	ldr	r2, [r2, #28]
 8006e6a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8006e6e:	61da      	str	r2, [r3, #28]

        /* Enable I2S peripheral after the I2Sext */
        __HAL_I2S_ENABLE(hi2s);
 8006e70:	68fb      	ldr	r3, [r7, #12]
 8006e72:	681b      	ldr	r3, [r3, #0]
 8006e74:	68fa      	ldr	r2, [r7, #12]
 8006e76:	6812      	ldr	r2, [r2, #0]
 8006e78:	69d2      	ldr	r2, [r2, #28]
 8006e7a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8006e7e:	61da      	str	r2, [r3, #28]

      /* Enable Tx DMA Request */  
      hi2s->Instance->CR2 |= SPI_CR2_TXDMAEN;

      /* Check if the I2S is already enabled */ 
      if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
 8006e80:	e099      	b.n	8006fb6 <HAL_I2SEx_TransmitReceive_DMA+0x392>
 8006e82:	e098      	b.n	8006fb6 <HAL_I2SEx_TransmitReceive_DMA+0x392>
      }
    }
    else
    {
      /* Enable the Tx DMA Stream */
      tmp = (uint32_t*)&pTxData;
 8006e84:	f107 0308 	add.w	r3, r7, #8
 8006e88:	617b      	str	r3, [r7, #20]
      HAL_DMA_Start_IT(hi2s->hdmatx, *(uint32_t*)tmp, (uint32_t)&I2SxEXT(hi2s->Instance)->DR, hi2s->TxXferSize);
 8006e8a:	68fb      	ldr	r3, [r7, #12]
 8006e8c:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8006e8e:	697b      	ldr	r3, [r7, #20]
 8006e90:	6819      	ldr	r1, [r3, #0]
 8006e92:	68fb      	ldr	r3, [r7, #12]
 8006e94:	681a      	ldr	r2, [r3, #0]
 8006e96:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006e9a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006e9e:	429a      	cmp	r2, r3
 8006ea0:	d104      	bne.n	8006eac <HAL_I2SEx_TransmitReceive_DMA+0x288>
 8006ea2:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8006ea6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006eaa:	e001      	b.n	8006eb0 <HAL_I2SEx_TransmitReceive_DMA+0x28c>
 8006eac:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8006eb0:	330c      	adds	r3, #12
 8006eb2:	461a      	mov	r2, r3
 8006eb4:	68fb      	ldr	r3, [r7, #12]
 8006eb6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8006eb8:	b29b      	uxth	r3, r3
 8006eba:	f7fd fb75 	bl	80045a8 <HAL_DMA_Start_IT>

      /* Enable Tx DMA Request */  
      I2SxEXT(hi2s->Instance)->CR2 |= SPI_CR2_TXDMAEN;
 8006ebe:	68fb      	ldr	r3, [r7, #12]
 8006ec0:	681a      	ldr	r2, [r3, #0]
 8006ec2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006ec6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006eca:	429a      	cmp	r2, r3
 8006ecc:	d104      	bne.n	8006ed8 <HAL_I2SEx_TransmitReceive_DMA+0x2b4>
 8006ece:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8006ed2:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006ed6:	e001      	b.n	8006edc <HAL_I2SEx_TransmitReceive_DMA+0x2b8>
 8006ed8:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8006edc:	68fa      	ldr	r2, [r7, #12]
 8006ede:	6811      	ldr	r1, [r2, #0]
 8006ee0:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8006ee4:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006ee8:	4291      	cmp	r1, r2
 8006eea:	d104      	bne.n	8006ef6 <HAL_I2SEx_TransmitReceive_DMA+0x2d2>
 8006eec:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 8006ef0:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006ef4:	e001      	b.n	8006efa <HAL_I2SEx_TransmitReceive_DMA+0x2d6>
 8006ef6:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8006efa:	6852      	ldr	r2, [r2, #4]
 8006efc:	f042 0202 	orr.w	r2, r2, #2
 8006f00:	605a      	str	r2, [r3, #4]

      /* Enable the Rx DMA Stream */
      tmp = (uint32_t*)&pRxData;
 8006f02:	1d3b      	adds	r3, r7, #4
 8006f04:	617b      	str	r3, [r7, #20]
      HAL_DMA_Start_IT(hi2s->hdmarx, (uint32_t)&hi2s->Instance->DR, *(uint32_t*)tmp, hi2s->RxXferSize);
 8006f06:	68fb      	ldr	r3, [r7, #12]
 8006f08:	6b98      	ldr	r0, [r3, #56]	; 0x38
 8006f0a:	68fb      	ldr	r3, [r7, #12]
 8006f0c:	681b      	ldr	r3, [r3, #0]
 8006f0e:	330c      	adds	r3, #12
 8006f10:	4619      	mov	r1, r3
 8006f12:	697b      	ldr	r3, [r7, #20]
 8006f14:	681a      	ldr	r2, [r3, #0]
 8006f16:	68fb      	ldr	r3, [r7, #12]
 8006f18:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 8006f1a:	b29b      	uxth	r3, r3
 8006f1c:	f7fd fb44 	bl	80045a8 <HAL_DMA_Start_IT>

      /* Enable Rx DMA Request */  
      hi2s->Instance->CR2 |= SPI_CR2_RXDMAEN;
 8006f20:	68fb      	ldr	r3, [r7, #12]
 8006f22:	681b      	ldr	r3, [r3, #0]
 8006f24:	68fa      	ldr	r2, [r7, #12]
 8006f26:	6812      	ldr	r2, [r2, #0]
 8006f28:	6852      	ldr	r2, [r2, #4]
 8006f2a:	f042 0201 	orr.w	r2, r2, #1
 8006f2e:	605a      	str	r2, [r3, #4]

      /* Check if the I2S is already enabled */ 
      if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
 8006f30:	68fb      	ldr	r3, [r7, #12]
 8006f32:	681b      	ldr	r3, [r3, #0]
 8006f34:	69db      	ldr	r3, [r3, #28]
 8006f36:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8006f3a:	2b00      	cmp	r3, #0
 8006f3c:	d12a      	bne.n	8006f94 <HAL_I2SEx_TransmitReceive_DMA+0x370>
      {
        /* Enable I2S peripheral before the I2Sext */
        __HAL_I2S_ENABLE(hi2s);
 8006f3e:	68fb      	ldr	r3, [r7, #12]
 8006f40:	681b      	ldr	r3, [r3, #0]
 8006f42:	68fa      	ldr	r2, [r7, #12]
 8006f44:	6812      	ldr	r2, [r2, #0]
 8006f46:	69d2      	ldr	r2, [r2, #28]
 8006f48:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8006f4c:	61da      	str	r2, [r3, #28]

        /* Enable I2Sext(transmitter) after enabling I2Sx peripheral */
        I2SxEXT(hi2s->Instance)->I2SCFGR |= SPI_I2SCFGR_I2SE;
 8006f4e:	68fb      	ldr	r3, [r7, #12]
 8006f50:	681a      	ldr	r2, [r3, #0]
 8006f52:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006f56:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006f5a:	429a      	cmp	r2, r3
 8006f5c:	d104      	bne.n	8006f68 <HAL_I2SEx_TransmitReceive_DMA+0x344>
 8006f5e:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8006f62:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006f66:	e001      	b.n	8006f6c <HAL_I2SEx_TransmitReceive_DMA+0x348>
 8006f68:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8006f6c:	68fa      	ldr	r2, [r7, #12]
 8006f6e:	6811      	ldr	r1, [r2, #0]
 8006f70:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8006f74:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006f78:	4291      	cmp	r1, r2
 8006f7a:	d104      	bne.n	8006f86 <HAL_I2SEx_TransmitReceive_DMA+0x362>
 8006f7c:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 8006f80:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006f84:	e001      	b.n	8006f8a <HAL_I2SEx_TransmitReceive_DMA+0x366>
 8006f86:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8006f8a:	69d2      	ldr	r2, [r2, #28]
 8006f8c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8006f90:	61da      	str	r2, [r3, #28]
 8006f92:	e010      	b.n	8006fb6 <HAL_I2SEx_TransmitReceive_DMA+0x392>
      }
      else
      {
        /* Check if Master Receiver mode is selected */
        if((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG) == I2S_MODE_MASTER_RX)
 8006f94:	68fb      	ldr	r3, [r7, #12]
 8006f96:	681b      	ldr	r3, [r3, #0]
 8006f98:	69db      	ldr	r3, [r3, #28]
 8006f9a:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8006f9e:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8006fa2:	d108      	bne.n	8006fb6 <HAL_I2SEx_TransmitReceive_DMA+0x392>
        {
          /* Clear the Overrun Flag by a read operation on the SPI_DR register followed by a read
          access to the SPI_SR register. */ 
          __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 8006fa4:	68fb      	ldr	r3, [r7, #12]
 8006fa6:	681b      	ldr	r3, [r3, #0]
 8006fa8:	68db      	ldr	r3, [r3, #12]
 8006faa:	613b      	str	r3, [r7, #16]
 8006fac:	68fb      	ldr	r3, [r7, #12]
 8006fae:	681b      	ldr	r3, [r3, #0]
 8006fb0:	689b      	ldr	r3, [r3, #8]
 8006fb2:	613b      	str	r3, [r7, #16]
 8006fb4:	693b      	ldr	r3, [r7, #16]
        }
      }
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2s);
 8006fb6:	68fb      	ldr	r3, [r7, #12]
 8006fb8:	2200      	movs	r2, #0
 8006fba:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    return HAL_OK;
 8006fbe:	2300      	movs	r3, #0
 8006fc0:	e000      	b.n	8006fc4 <HAL_I2SEx_TransmitReceive_DMA+0x3a0>
  }
  else
  {
    return HAL_BUSY;
 8006fc2:	2302      	movs	r3, #2
  }
}
 8006fc4:	4618      	mov	r0, r3
 8006fc6:	3720      	adds	r7, #32
 8006fc8:	46bd      	mov	sp, r7
 8006fca:	bd80      	pop	{r7, pc}

08006fcc <HAL_I2S_DMAPause>:
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2S_DMAPause(I2S_HandleTypeDef *hi2s)
{
 8006fcc:	b480      	push	{r7}
 8006fce:	b083      	sub	sp, #12
 8006fd0:	af00      	add	r7, sp, #0
 8006fd2:	6078      	str	r0, [r7, #4]
  /* Process Locked */
  __HAL_LOCK(hi2s);
 8006fd4:	687b      	ldr	r3, [r7, #4]
 8006fd6:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8006fda:	b2db      	uxtb	r3, r3
 8006fdc:	2b01      	cmp	r3, #1
 8006fde:	d101      	bne.n	8006fe4 <HAL_I2S_DMAPause+0x18>
 8006fe0:	2302      	movs	r3, #2
 8006fe2:	e08a      	b.n	80070fa <HAL_I2S_DMAPause+0x12e>
 8006fe4:	687b      	ldr	r3, [r7, #4]
 8006fe6:	2201      	movs	r2, #1
 8006fe8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  if(hi2s->State == HAL_I2S_STATE_BUSY_TX)
 8006fec:	687b      	ldr	r3, [r7, #4]
 8006fee:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8006ff2:	b2db      	uxtb	r3, r3
 8006ff4:	2b12      	cmp	r3, #18
 8006ff6:	d108      	bne.n	800700a <HAL_I2S_DMAPause+0x3e>
  {
    /* Disable the I2S DMA Tx request */
    hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
 8006ff8:	687b      	ldr	r3, [r7, #4]
 8006ffa:	681b      	ldr	r3, [r3, #0]
 8006ffc:	687a      	ldr	r2, [r7, #4]
 8006ffe:	6812      	ldr	r2, [r2, #0]
 8007000:	6852      	ldr	r2, [r2, #4]
 8007002:	f022 0202 	bic.w	r2, r2, #2
 8007006:	605a      	str	r2, [r3, #4]
 8007008:	e072      	b.n	80070f0 <HAL_I2S_DMAPause+0x124>
  }
  else if(hi2s->State == HAL_I2S_STATE_BUSY_RX)
 800700a:	687b      	ldr	r3, [r7, #4]
 800700c:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8007010:	b2db      	uxtb	r3, r3
 8007012:	2b22      	cmp	r3, #34	; 0x22
 8007014:	d108      	bne.n	8007028 <HAL_I2S_DMAPause+0x5c>
  {
    /* Disable the I2S DMA Rx request */
    hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
 8007016:	687b      	ldr	r3, [r7, #4]
 8007018:	681b      	ldr	r3, [r3, #0]
 800701a:	687a      	ldr	r2, [r7, #4]
 800701c:	6812      	ldr	r2, [r2, #0]
 800701e:	6852      	ldr	r2, [r2, #4]
 8007020:	f022 0201 	bic.w	r2, r2, #1
 8007024:	605a      	str	r2, [r3, #4]
 8007026:	e063      	b.n	80070f0 <HAL_I2S_DMAPause+0x124>
  }
  else if(hi2s->State == HAL_I2S_STATE_BUSY_TX_RX)
 8007028:	687b      	ldr	r3, [r7, #4]
 800702a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800702e:	b2db      	uxtb	r3, r3
 8007030:	2b32      	cmp	r3, #50	; 0x32
 8007032:	d15d      	bne.n	80070f0 <HAL_I2S_DMAPause+0x124>
  {
    if((hi2s->Init.Mode == I2S_MODE_SLAVE_TX)||(hi2s->Init.Mode == I2S_MODE_MASTER_TX))
 8007034:	687b      	ldr	r3, [r7, #4]
 8007036:	685b      	ldr	r3, [r3, #4]
 8007038:	2b00      	cmp	r3, #0
 800703a:	d004      	beq.n	8007046 <HAL_I2S_DMAPause+0x7a>
 800703c:	687b      	ldr	r3, [r7, #4]
 800703e:	685b      	ldr	r3, [r3, #4]
 8007040:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8007044:	d12a      	bne.n	800709c <HAL_I2S_DMAPause+0xd0>
    {
      /* Disable the I2S DMA Tx request */
      hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
 8007046:	687b      	ldr	r3, [r7, #4]
 8007048:	681b      	ldr	r3, [r3, #0]
 800704a:	687a      	ldr	r2, [r7, #4]
 800704c:	6812      	ldr	r2, [r2, #0]
 800704e:	6852      	ldr	r2, [r2, #4]
 8007050:	f022 0202 	bic.w	r2, r2, #2
 8007054:	605a      	str	r2, [r3, #4]
      /* Disable the I2SEx Rx DMA Request */
      I2SxEXT(hi2s->Instance)->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
 8007056:	687b      	ldr	r3, [r7, #4]
 8007058:	681a      	ldr	r2, [r3, #0]
 800705a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800705e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007062:	429a      	cmp	r2, r3
 8007064:	d104      	bne.n	8007070 <HAL_I2S_DMAPause+0xa4>
 8007066:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 800706a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800706e:	e001      	b.n	8007074 <HAL_I2S_DMAPause+0xa8>
 8007070:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8007074:	687a      	ldr	r2, [r7, #4]
 8007076:	6811      	ldr	r1, [r2, #0]
 8007078:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800707c:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8007080:	4291      	cmp	r1, r2
 8007082:	d104      	bne.n	800708e <HAL_I2S_DMAPause+0xc2>
 8007084:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 8007088:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800708c:	e001      	b.n	8007092 <HAL_I2S_DMAPause+0xc6>
 800708e:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8007092:	6852      	ldr	r2, [r2, #4]
 8007094:	f022 0201 	bic.w	r2, r2, #1
 8007098:	605a      	str	r2, [r3, #4]
 800709a:	e029      	b.n	80070f0 <HAL_I2S_DMAPause+0x124>
    }
    else
    {
      /* Disable the I2S DMA Rx request */
      hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
 800709c:	687b      	ldr	r3, [r7, #4]
 800709e:	681b      	ldr	r3, [r3, #0]
 80070a0:	687a      	ldr	r2, [r7, #4]
 80070a2:	6812      	ldr	r2, [r2, #0]
 80070a4:	6852      	ldr	r2, [r2, #4]
 80070a6:	f022 0201 	bic.w	r2, r2, #1
 80070aa:	605a      	str	r2, [r3, #4]
      /* Disable the I2SEx Tx DMA Request */
      I2SxEXT(hi2s->Instance)->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);      
 80070ac:	687b      	ldr	r3, [r7, #4]
 80070ae:	681a      	ldr	r2, [r3, #0]
 80070b0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80070b4:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80070b8:	429a      	cmp	r2, r3
 80070ba:	d104      	bne.n	80070c6 <HAL_I2S_DMAPause+0xfa>
 80070bc:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 80070c0:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80070c4:	e001      	b.n	80070ca <HAL_I2S_DMAPause+0xfe>
 80070c6:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 80070ca:	687a      	ldr	r2, [r7, #4]
 80070cc:	6811      	ldr	r1, [r2, #0]
 80070ce:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80070d2:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80070d6:	4291      	cmp	r1, r2
 80070d8:	d104      	bne.n	80070e4 <HAL_I2S_DMAPause+0x118>
 80070da:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 80070de:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80070e2:	e001      	b.n	80070e8 <HAL_I2S_DMAPause+0x11c>
 80070e4:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 80070e8:	6852      	ldr	r2, [r2, #4]
 80070ea:	f022 0202 	bic.w	r2, r2, #2
 80070ee:	605a      	str	r2, [r3, #4]
    }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2s);
 80070f0:	687b      	ldr	r3, [r7, #4]
 80070f2:	2200      	movs	r2, #0
 80070f4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  return HAL_OK; 
 80070f8:	2300      	movs	r3, #0
}
 80070fa:	4618      	mov	r0, r3
 80070fc:	370c      	adds	r7, #12
 80070fe:	46bd      	mov	sp, r7
 8007100:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007104:	4770      	bx	lr
 8007106:	bf00      	nop

08007108 <HAL_I2S_DMAResume>:
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2S_DMAResume(I2S_HandleTypeDef *hi2s)
{
 8007108:	b480      	push	{r7}
 800710a:	b083      	sub	sp, #12
 800710c:	af00      	add	r7, sp, #0
 800710e:	6078      	str	r0, [r7, #4]
  /* Process Locked */
  __HAL_LOCK(hi2s);
 8007110:	687b      	ldr	r3, [r7, #4]
 8007112:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8007116:	b2db      	uxtb	r3, r3
 8007118:	2b01      	cmp	r3, #1
 800711a:	d101      	bne.n	8007120 <HAL_I2S_DMAResume+0x18>
 800711c:	2302      	movs	r3, #2
 800711e:	e099      	b.n	8007254 <HAL_I2S_DMAResume+0x14c>
 8007120:	687b      	ldr	r3, [r7, #4]
 8007122:	2201      	movs	r2, #1
 8007124:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  if(hi2s->State == HAL_I2S_STATE_BUSY_TX)
 8007128:	687b      	ldr	r3, [r7, #4]
 800712a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800712e:	b2db      	uxtb	r3, r3
 8007130:	2b12      	cmp	r3, #18
 8007132:	d108      	bne.n	8007146 <HAL_I2S_DMAResume+0x3e>
  {
    /* Enable the I2S DMA Tx request */
    hi2s->Instance->CR2 |= SPI_CR2_TXDMAEN;
 8007134:	687b      	ldr	r3, [r7, #4]
 8007136:	681b      	ldr	r3, [r3, #0]
 8007138:	687a      	ldr	r2, [r7, #4]
 800713a:	6812      	ldr	r2, [r2, #0]
 800713c:	6852      	ldr	r2, [r2, #4]
 800713e:	f042 0202 	orr.w	r2, r2, #2
 8007142:	605a      	str	r2, [r3, #4]
 8007144:	e072      	b.n	800722c <HAL_I2S_DMAResume+0x124>
  }
  else if(hi2s->State == HAL_I2S_STATE_BUSY_RX)
 8007146:	687b      	ldr	r3, [r7, #4]
 8007148:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800714c:	b2db      	uxtb	r3, r3
 800714e:	2b22      	cmp	r3, #34	; 0x22
 8007150:	d108      	bne.n	8007164 <HAL_I2S_DMAResume+0x5c>
  {
    /* Enable the I2S DMA Rx request */
    hi2s->Instance->CR2 |= SPI_CR2_RXDMAEN;
 8007152:	687b      	ldr	r3, [r7, #4]
 8007154:	681b      	ldr	r3, [r3, #0]
 8007156:	687a      	ldr	r2, [r7, #4]
 8007158:	6812      	ldr	r2, [r2, #0]
 800715a:	6852      	ldr	r2, [r2, #4]
 800715c:	f042 0201 	orr.w	r2, r2, #1
 8007160:	605a      	str	r2, [r3, #4]
 8007162:	e063      	b.n	800722c <HAL_I2S_DMAResume+0x124>
  }
  else if(hi2s->State == HAL_I2S_STATE_BUSY_TX_RX)
 8007164:	687b      	ldr	r3, [r7, #4]
 8007166:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800716a:	b2db      	uxtb	r3, r3
 800716c:	2b32      	cmp	r3, #50	; 0x32
 800716e:	d15d      	bne.n	800722c <HAL_I2S_DMAResume+0x124>
  {
    if((hi2s->Init.Mode == I2S_MODE_SLAVE_TX)||(hi2s->Init.Mode == I2S_MODE_MASTER_TX))
 8007170:	687b      	ldr	r3, [r7, #4]
 8007172:	685b      	ldr	r3, [r3, #4]
 8007174:	2b00      	cmp	r3, #0
 8007176:	d004      	beq.n	8007182 <HAL_I2S_DMAResume+0x7a>
 8007178:	687b      	ldr	r3, [r7, #4]
 800717a:	685b      	ldr	r3, [r3, #4]
 800717c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8007180:	d12a      	bne.n	80071d8 <HAL_I2S_DMAResume+0xd0>
    {
      /* Enable the I2S DMA Tx request */
      hi2s->Instance->CR2 |= SPI_CR2_TXDMAEN;
 8007182:	687b      	ldr	r3, [r7, #4]
 8007184:	681b      	ldr	r3, [r3, #0]
 8007186:	687a      	ldr	r2, [r7, #4]
 8007188:	6812      	ldr	r2, [r2, #0]
 800718a:	6852      	ldr	r2, [r2, #4]
 800718c:	f042 0202 	orr.w	r2, r2, #2
 8007190:	605a      	str	r2, [r3, #4]
      /* Disable the I2SEx Rx DMA Request */  
      I2SxEXT(hi2s->Instance)->CR2 |= SPI_CR2_RXDMAEN;
 8007192:	687b      	ldr	r3, [r7, #4]
 8007194:	681a      	ldr	r2, [r3, #0]
 8007196:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800719a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800719e:	429a      	cmp	r2, r3
 80071a0:	d104      	bne.n	80071ac <HAL_I2S_DMAResume+0xa4>
 80071a2:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 80071a6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80071aa:	e001      	b.n	80071b0 <HAL_I2S_DMAResume+0xa8>
 80071ac:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 80071b0:	687a      	ldr	r2, [r7, #4]
 80071b2:	6811      	ldr	r1, [r2, #0]
 80071b4:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80071b8:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80071bc:	4291      	cmp	r1, r2
 80071be:	d104      	bne.n	80071ca <HAL_I2S_DMAResume+0xc2>
 80071c0:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 80071c4:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80071c8:	e001      	b.n	80071ce <HAL_I2S_DMAResume+0xc6>
 80071ca:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 80071ce:	6852      	ldr	r2, [r2, #4]
 80071d0:	f042 0201 	orr.w	r2, r2, #1
 80071d4:	605a      	str	r2, [r3, #4]
 80071d6:	e029      	b.n	800722c <HAL_I2S_DMAResume+0x124>
    }
    else
    {
      /* Enable the I2S DMA Rx request */
      hi2s->Instance->CR2 |= SPI_CR2_RXDMAEN;
 80071d8:	687b      	ldr	r3, [r7, #4]
 80071da:	681b      	ldr	r3, [r3, #0]
 80071dc:	687a      	ldr	r2, [r7, #4]
 80071de:	6812      	ldr	r2, [r2, #0]
 80071e0:	6852      	ldr	r2, [r2, #4]
 80071e2:	f042 0201 	orr.w	r2, r2, #1
 80071e6:	605a      	str	r2, [r3, #4]
      /* Enable the I2SEx Tx DMA Request */  
      I2SxEXT(hi2s->Instance)->CR2 |= SPI_CR2_TXDMAEN;
 80071e8:	687b      	ldr	r3, [r7, #4]
 80071ea:	681a      	ldr	r2, [r3, #0]
 80071ec:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80071f0:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80071f4:	429a      	cmp	r2, r3
 80071f6:	d104      	bne.n	8007202 <HAL_I2S_DMAResume+0xfa>
 80071f8:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 80071fc:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007200:	e001      	b.n	8007206 <HAL_I2S_DMAResume+0xfe>
 8007202:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8007206:	687a      	ldr	r2, [r7, #4]
 8007208:	6811      	ldr	r1, [r2, #0]
 800720a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800720e:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8007212:	4291      	cmp	r1, r2
 8007214:	d104      	bne.n	8007220 <HAL_I2S_DMAResume+0x118>
 8007216:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 800721a:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800721e:	e001      	b.n	8007224 <HAL_I2S_DMAResume+0x11c>
 8007220:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8007224:	6852      	ldr	r2, [r2, #4]
 8007226:	f042 0202 	orr.w	r2, r2, #2
 800722a:	605a      	str	r2, [r3, #4]
    }
  }

  /* If the I2S peripheral is still not enabled, enable it */
  if ((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SE) == 0)
 800722c:	687b      	ldr	r3, [r7, #4]
 800722e:	681b      	ldr	r3, [r3, #0]
 8007230:	69db      	ldr	r3, [r3, #28]
 8007232:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8007236:	2b00      	cmp	r3, #0
 8007238:	d107      	bne.n	800724a <HAL_I2S_DMAResume+0x142>
  {
    /* Enable I2S peripheral */    
    __HAL_I2S_ENABLE(hi2s);
 800723a:	687b      	ldr	r3, [r7, #4]
 800723c:	681b      	ldr	r3, [r3, #0]
 800723e:	687a      	ldr	r2, [r7, #4]
 8007240:	6812      	ldr	r2, [r2, #0]
 8007242:	69d2      	ldr	r2, [r2, #28]
 8007244:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8007248:	61da      	str	r2, [r3, #28]
  }
  
  /* Process Unlocked */
  __HAL_UNLOCK(hi2s);
 800724a:	687b      	ldr	r3, [r7, #4]
 800724c:	2200      	movs	r2, #0
 800724e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  return HAL_OK;
 8007252:	2300      	movs	r3, #0
}
 8007254:	4618      	mov	r0, r3
 8007256:	370c      	adds	r7, #12
 8007258:	46bd      	mov	sp, r7
 800725a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800725e:	4770      	bx	lr

08007260 <HAL_I2S_DMAStop>:
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2S_DMAStop(I2S_HandleTypeDef *hi2s)
{
 8007260:	b580      	push	{r7, lr}
 8007262:	b082      	sub	sp, #8
 8007264:	af00      	add	r7, sp, #0
 8007266:	6078      	str	r0, [r7, #4]
  /* Process Locked */
  __HAL_LOCK(hi2s);
 8007268:	687b      	ldr	r3, [r7, #4]
 800726a:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 800726e:	b2db      	uxtb	r3, r3
 8007270:	2b01      	cmp	r3, #1
 8007272:	d101      	bne.n	8007278 <HAL_I2S_DMAStop+0x18>
 8007274:	2302      	movs	r3, #2
 8007276:	e0a4      	b.n	80073c2 <HAL_I2S_DMAStop+0x162>
 8007278:	687b      	ldr	r3, [r7, #4]
 800727a:	2201      	movs	r2, #1
 800727c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Disable the I2S Tx/Rx DMA requests */
  hi2s->Instance->CR2 &= ~SPI_CR2_TXDMAEN;
 8007280:	687b      	ldr	r3, [r7, #4]
 8007282:	681b      	ldr	r3, [r3, #0]
 8007284:	687a      	ldr	r2, [r7, #4]
 8007286:	6812      	ldr	r2, [r2, #0]
 8007288:	6852      	ldr	r2, [r2, #4]
 800728a:	f022 0202 	bic.w	r2, r2, #2
 800728e:	605a      	str	r2, [r3, #4]
  hi2s->Instance->CR2 &= ~SPI_CR2_RXDMAEN;
 8007290:	687b      	ldr	r3, [r7, #4]
 8007292:	681b      	ldr	r3, [r3, #0]
 8007294:	687a      	ldr	r2, [r7, #4]
 8007296:	6812      	ldr	r2, [r2, #0]
 8007298:	6852      	ldr	r2, [r2, #4]
 800729a:	f022 0201 	bic.w	r2, r2, #1
 800729e:	605a      	str	r2, [r3, #4]
  
  if(hi2s->Init.FullDuplexMode == I2S_FULLDUPLEXMODE_ENABLE)
 80072a0:	687b      	ldr	r3, [r7, #4]
 80072a2:	6a1b      	ldr	r3, [r3, #32]
 80072a4:	2b01      	cmp	r3, #1
 80072a6:	d143      	bne.n	8007330 <HAL_I2S_DMAStop+0xd0>
  {
    /* Disable the I2S extended Tx/Rx DMA requests */  
    I2SxEXT(hi2s->Instance)->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
 80072a8:	687b      	ldr	r3, [r7, #4]
 80072aa:	681a      	ldr	r2, [r3, #0]
 80072ac:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80072b0:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80072b4:	429a      	cmp	r2, r3
 80072b6:	d104      	bne.n	80072c2 <HAL_I2S_DMAStop+0x62>
 80072b8:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 80072bc:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80072c0:	e001      	b.n	80072c6 <HAL_I2S_DMAStop+0x66>
 80072c2:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 80072c6:	687a      	ldr	r2, [r7, #4]
 80072c8:	6811      	ldr	r1, [r2, #0]
 80072ca:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80072ce:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80072d2:	4291      	cmp	r1, r2
 80072d4:	d104      	bne.n	80072e0 <HAL_I2S_DMAStop+0x80>
 80072d6:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 80072da:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80072de:	e001      	b.n	80072e4 <HAL_I2S_DMAStop+0x84>
 80072e0:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 80072e4:	6852      	ldr	r2, [r2, #4]
 80072e6:	f022 0202 	bic.w	r2, r2, #2
 80072ea:	605a      	str	r2, [r3, #4]
    I2SxEXT(hi2s->Instance)->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
 80072ec:	687b      	ldr	r3, [r7, #4]
 80072ee:	681a      	ldr	r2, [r3, #0]
 80072f0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80072f4:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80072f8:	429a      	cmp	r2, r3
 80072fa:	d104      	bne.n	8007306 <HAL_I2S_DMAStop+0xa6>
 80072fc:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8007300:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007304:	e001      	b.n	800730a <HAL_I2S_DMAStop+0xaa>
 8007306:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800730a:	687a      	ldr	r2, [r7, #4]
 800730c:	6811      	ldr	r1, [r2, #0]
 800730e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8007312:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8007316:	4291      	cmp	r1, r2
 8007318:	d104      	bne.n	8007324 <HAL_I2S_DMAStop+0xc4>
 800731a:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 800731e:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8007322:	e001      	b.n	8007328 <HAL_I2S_DMAStop+0xc8>
 8007324:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8007328:	6852      	ldr	r2, [r2, #4]
 800732a:	f022 0201 	bic.w	r2, r2, #1
 800732e:	605a      	str	r2, [r3, #4]
  }
  
  /* Abort the I2S DMA Stream tx */
  if(hi2s->hdmatx != NULL)
 8007330:	687b      	ldr	r3, [r7, #4]
 8007332:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007334:	2b00      	cmp	r3, #0
 8007336:	d004      	beq.n	8007342 <HAL_I2S_DMAStop+0xe2>
  {
    HAL_DMA_Abort(hi2s->hdmatx);
 8007338:	687b      	ldr	r3, [r7, #4]
 800733a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800733c:	4618      	mov	r0, r3
 800733e:	f7fd f975 	bl	800462c <HAL_DMA_Abort>
  }
  /* Abort the I2S DMA Stream rx */
  if(hi2s->hdmarx != NULL)
 8007342:	687b      	ldr	r3, [r7, #4]
 8007344:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007346:	2b00      	cmp	r3, #0
 8007348:	d004      	beq.n	8007354 <HAL_I2S_DMAStop+0xf4>
  {
    HAL_DMA_Abort(hi2s->hdmarx);
 800734a:	687b      	ldr	r3, [r7, #4]
 800734c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800734e:	4618      	mov	r0, r3
 8007350:	f7fd f96c 	bl	800462c <HAL_DMA_Abort>
  }

  /* Disable I2S peripheral */
  __HAL_I2S_DISABLE(hi2s);
 8007354:	687b      	ldr	r3, [r7, #4]
 8007356:	681b      	ldr	r3, [r3, #0]
 8007358:	687a      	ldr	r2, [r7, #4]
 800735a:	6812      	ldr	r2, [r2, #0]
 800735c:	69d2      	ldr	r2, [r2, #28]
 800735e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8007362:	61da      	str	r2, [r3, #28]
 
  if(hi2s->Init.FullDuplexMode == I2S_FULLDUPLEXMODE_ENABLE)
 8007364:	687b      	ldr	r3, [r7, #4]
 8007366:	6a1b      	ldr	r3, [r3, #32]
 8007368:	2b01      	cmp	r3, #1
 800736a:	d121      	bne.n	80073b0 <HAL_I2S_DMAStop+0x150>
  {
    /* Disable the I2Sext peripheral */
    I2SxEXT(hi2s->Instance)->I2SCFGR &= ~SPI_I2SCFGR_I2SE;
 800736c:	687b      	ldr	r3, [r7, #4]
 800736e:	681a      	ldr	r2, [r3, #0]
 8007370:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007374:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007378:	429a      	cmp	r2, r3
 800737a:	d104      	bne.n	8007386 <HAL_I2S_DMAStop+0x126>
 800737c:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8007380:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007384:	e001      	b.n	800738a <HAL_I2S_DMAStop+0x12a>
 8007386:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800738a:	687a      	ldr	r2, [r7, #4]
 800738c:	6811      	ldr	r1, [r2, #0]
 800738e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8007392:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8007396:	4291      	cmp	r1, r2
 8007398:	d104      	bne.n	80073a4 <HAL_I2S_DMAStop+0x144>
 800739a:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 800739e:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80073a2:	e001      	b.n	80073a8 <HAL_I2S_DMAStop+0x148>
 80073a4:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 80073a8:	69d2      	ldr	r2, [r2, #28]
 80073aa:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80073ae:	61da      	str	r2, [r3, #28]
  }
  hi2s->State = HAL_I2S_STATE_READY;
 80073b0:	687b      	ldr	r3, [r7, #4]
 80073b2:	2201      	movs	r2, #1
 80073b4:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Process Unlocked */
  __HAL_UNLOCK(hi2s);
 80073b8:	687b      	ldr	r3, [r7, #4]
 80073ba:	2200      	movs	r2, #0
 80073bc:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  return HAL_OK;
 80073c0:	2300      	movs	r3, #0
}
 80073c2:	4618      	mov	r0, r3
 80073c4:	3708      	adds	r7, #8
 80073c6:	46bd      	mov	sp, r7
 80073c8:	bd80      	pop	{r7, pc}
 80073ca:	bf00      	nop

080073cc <HAL_I2S_IRQHandler>:
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
void HAL_I2S_IRQHandler(I2S_HandleTypeDef *hi2s)
{  
 80073cc:	b580      	push	{r7, lr}
 80073ce:	b08a      	sub	sp, #40	; 0x28
 80073d0:	af00      	add	r7, sp, #0
 80073d2:	6078      	str	r0, [r7, #4]
  uint32_t tmp1 = 0, tmp2 = 0;
 80073d4:	2300      	movs	r3, #0
 80073d6:	627b      	str	r3, [r7, #36]	; 0x24
 80073d8:	2300      	movs	r3, #0
 80073da:	623b      	str	r3, [r7, #32]
  __IO uint32_t tmpreg1 = 0;    
 80073dc:	2300      	movs	r3, #0
 80073de:	61fb      	str	r3, [r7, #28]
  if(hi2s->Init.FullDuplexMode != I2S_FULLDUPLEXMODE_ENABLE)
 80073e0:	687b      	ldr	r3, [r7, #4]
 80073e2:	6a1b      	ldr	r3, [r3, #32]
 80073e4:	2b01      	cmp	r3, #1
 80073e6:	f000 80a0 	beq.w	800752a <HAL_I2S_IRQHandler+0x15e>
  {
    if(hi2s->State == HAL_I2S_STATE_BUSY_RX)
 80073ea:	687b      	ldr	r3, [r7, #4]
 80073ec:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80073f0:	b2db      	uxtb	r3, r3
 80073f2:	2b22      	cmp	r3, #34	; 0x22
 80073f4:	d149      	bne.n	800748a <HAL_I2S_IRQHandler+0xbe>
    {
      tmp1 = __HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_RXNE);
 80073f6:	687b      	ldr	r3, [r7, #4]
 80073f8:	681b      	ldr	r3, [r3, #0]
 80073fa:	689b      	ldr	r3, [r3, #8]
 80073fc:	f003 0301 	and.w	r3, r3, #1
 8007400:	2b00      	cmp	r3, #0
 8007402:	bf0c      	ite	eq
 8007404:	2300      	moveq	r3, #0
 8007406:	2301      	movne	r3, #1
 8007408:	b2db      	uxtb	r3, r3
 800740a:	627b      	str	r3, [r7, #36]	; 0x24
      tmp2 = __HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_RXNE);
 800740c:	687b      	ldr	r3, [r7, #4]
 800740e:	681b      	ldr	r3, [r3, #0]
 8007410:	685b      	ldr	r3, [r3, #4]
 8007412:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8007416:	2b00      	cmp	r3, #0
 8007418:	bf0c      	ite	eq
 800741a:	2300      	moveq	r3, #0
 800741c:	2301      	movne	r3, #1
 800741e:	b2db      	uxtb	r3, r3
 8007420:	623b      	str	r3, [r7, #32]
      /* I2S in mode Receiver ------------------------------------------------*/
      if((tmp1 != RESET) && (tmp2 != RESET))
 8007422:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007424:	2b00      	cmp	r3, #0
 8007426:	d005      	beq.n	8007434 <HAL_I2S_IRQHandler+0x68>
 8007428:	6a3b      	ldr	r3, [r7, #32]
 800742a:	2b00      	cmp	r3, #0
 800742c:	d002      	beq.n	8007434 <HAL_I2S_IRQHandler+0x68>
      {
        I2S_Receive_IT(hi2s);
 800742e:	6878      	ldr	r0, [r7, #4]
 8007430:	f7fe feb0 	bl	8006194 <I2S_Receive_IT>
      }

      tmp1 = __HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_OVR);
 8007434:	687b      	ldr	r3, [r7, #4]
 8007436:	681b      	ldr	r3, [r3, #0]
 8007438:	689b      	ldr	r3, [r3, #8]
 800743a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800743e:	2b00      	cmp	r3, #0
 8007440:	bf0c      	ite	eq
 8007442:	2300      	moveq	r3, #0
 8007444:	2301      	movne	r3, #1
 8007446:	b2db      	uxtb	r3, r3
 8007448:	627b      	str	r3, [r7, #36]	; 0x24
      tmp2 = __HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR);
 800744a:	687b      	ldr	r3, [r7, #4]
 800744c:	681b      	ldr	r3, [r3, #0]
 800744e:	685b      	ldr	r3, [r3, #4]
 8007450:	f003 0320 	and.w	r3, r3, #32
 8007454:	2b00      	cmp	r3, #0
 8007456:	bf0c      	ite	eq
 8007458:	2300      	moveq	r3, #0
 800745a:	2301      	movne	r3, #1
 800745c:	b2db      	uxtb	r3, r3
 800745e:	623b      	str	r3, [r7, #32]
      /* I2S Overrun error interrupt occurred ---------------------------------*/
      if((tmp1 != RESET) && (tmp2 != RESET))
 8007460:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007462:	2b00      	cmp	r3, #0
 8007464:	d011      	beq.n	800748a <HAL_I2S_IRQHandler+0xbe>
 8007466:	6a3b      	ldr	r3, [r7, #32]
 8007468:	2b00      	cmp	r3, #0
 800746a:	d00e      	beq.n	800748a <HAL_I2S_IRQHandler+0xbe>
      {
        __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 800746c:	687b      	ldr	r3, [r7, #4]
 800746e:	681b      	ldr	r3, [r3, #0]
 8007470:	68db      	ldr	r3, [r3, #12]
 8007472:	61bb      	str	r3, [r7, #24]
 8007474:	687b      	ldr	r3, [r7, #4]
 8007476:	681b      	ldr	r3, [r3, #0]
 8007478:	689b      	ldr	r3, [r3, #8]
 800747a:	61bb      	str	r3, [r7, #24]
 800747c:	69bb      	ldr	r3, [r7, #24]
        hi2s->ErrorCode |= HAL_I2S_ERROR_OVR;
 800747e:	687b      	ldr	r3, [r7, #4]
 8007480:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007482:	f043 0202 	orr.w	r2, r3, #2
 8007486:	687b      	ldr	r3, [r7, #4]
 8007488:	641a      	str	r2, [r3, #64]	; 0x40
      }
    }

    if(hi2s->State == HAL_I2S_STATE_BUSY_TX)
 800748a:	687b      	ldr	r3, [r7, #4]
 800748c:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8007490:	b2db      	uxtb	r3, r3
 8007492:	2b12      	cmp	r3, #18
 8007494:	f040 8234 	bne.w	8007900 <HAL_I2S_IRQHandler+0x534>
    {
      tmp1 = __HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_TXE);
 8007498:	687b      	ldr	r3, [r7, #4]
 800749a:	681b      	ldr	r3, [r3, #0]
 800749c:	689b      	ldr	r3, [r3, #8]
 800749e:	f003 0302 	and.w	r3, r3, #2
 80074a2:	2b00      	cmp	r3, #0
 80074a4:	bf0c      	ite	eq
 80074a6:	2300      	moveq	r3, #0
 80074a8:	2301      	movne	r3, #1
 80074aa:	b2db      	uxtb	r3, r3
 80074ac:	627b      	str	r3, [r7, #36]	; 0x24
      tmp2 = __HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_TXE);
 80074ae:	687b      	ldr	r3, [r7, #4]
 80074b0:	681b      	ldr	r3, [r3, #0]
 80074b2:	685b      	ldr	r3, [r3, #4]
 80074b4:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80074b8:	2b00      	cmp	r3, #0
 80074ba:	bf0c      	ite	eq
 80074bc:	2300      	moveq	r3, #0
 80074be:	2301      	movne	r3, #1
 80074c0:	b2db      	uxtb	r3, r3
 80074c2:	623b      	str	r3, [r7, #32]
      /* I2S in mode Tramitter -----------------------------------------------*/
      if((tmp1 != RESET) && (tmp2 != RESET))
 80074c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80074c6:	2b00      	cmp	r3, #0
 80074c8:	d005      	beq.n	80074d6 <HAL_I2S_IRQHandler+0x10a>
 80074ca:	6a3b      	ldr	r3, [r7, #32]
 80074cc:	2b00      	cmp	r3, #0
 80074ce:	d002      	beq.n	80074d6 <HAL_I2S_IRQHandler+0x10a>
      {
        I2S_Transmit_IT(hi2s);
 80074d0:	6878      	ldr	r0, [r7, #4]
 80074d2:	f7fe fe15 	bl	8006100 <I2S_Transmit_IT>
      } 

      tmp1 = __HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_UDR);
 80074d6:	687b      	ldr	r3, [r7, #4]
 80074d8:	681b      	ldr	r3, [r3, #0]
 80074da:	689b      	ldr	r3, [r3, #8]
 80074dc:	f003 0308 	and.w	r3, r3, #8
 80074e0:	2b00      	cmp	r3, #0
 80074e2:	bf0c      	ite	eq
 80074e4:	2300      	moveq	r3, #0
 80074e6:	2301      	movne	r3, #1
 80074e8:	b2db      	uxtb	r3, r3
 80074ea:	627b      	str	r3, [r7, #36]	; 0x24
      tmp2 = __HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR);
 80074ec:	687b      	ldr	r3, [r7, #4]
 80074ee:	681b      	ldr	r3, [r3, #0]
 80074f0:	685b      	ldr	r3, [r3, #4]
 80074f2:	f003 0320 	and.w	r3, r3, #32
 80074f6:	2b00      	cmp	r3, #0
 80074f8:	bf0c      	ite	eq
 80074fa:	2300      	moveq	r3, #0
 80074fc:	2301      	movne	r3, #1
 80074fe:	b2db      	uxtb	r3, r3
 8007500:	623b      	str	r3, [r7, #32]
      /* I2S Underrun error interrupt occurred --------------------------------*/
      if((tmp1 != RESET) && (tmp2 != RESET))
 8007502:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007504:	2b00      	cmp	r3, #0
 8007506:	f000 81fb 	beq.w	8007900 <HAL_I2S_IRQHandler+0x534>
 800750a:	6a3b      	ldr	r3, [r7, #32]
 800750c:	2b00      	cmp	r3, #0
 800750e:	f000 81f7 	beq.w	8007900 <HAL_I2S_IRQHandler+0x534>
      {
        __HAL_I2S_CLEAR_UDRFLAG(hi2s);
 8007512:	687b      	ldr	r3, [r7, #4]
 8007514:	681b      	ldr	r3, [r3, #0]
 8007516:	689b      	ldr	r3, [r3, #8]
 8007518:	617b      	str	r3, [r7, #20]
 800751a:	697b      	ldr	r3, [r7, #20]
        hi2s->ErrorCode |= HAL_I2S_ERROR_UDR;
 800751c:	687b      	ldr	r3, [r7, #4]
 800751e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007520:	f043 0201 	orr.w	r2, r3, #1
 8007524:	687b      	ldr	r3, [r7, #4]
 8007526:	641a      	str	r2, [r3, #64]	; 0x40
 8007528:	e1ea      	b.n	8007900 <HAL_I2S_IRQHandler+0x534>
      }
    }
  }
  else
  {
    tmp1 = hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG;
 800752a:	687b      	ldr	r3, [r7, #4]
 800752c:	681b      	ldr	r3, [r3, #0]
 800752e:	69db      	ldr	r3, [r3, #28]
 8007530:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8007534:	627b      	str	r3, [r7, #36]	; 0x24
    tmp2 = hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG;
 8007536:	687b      	ldr	r3, [r7, #4]
 8007538:	681b      	ldr	r3, [r3, #0]
 800753a:	69db      	ldr	r3, [r3, #28]
 800753c:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8007540:	623b      	str	r3, [r7, #32]
    /* Check if the I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX Mode is selected */
    if((tmp1 == I2S_MODE_MASTER_TX) || (tmp2 == I2S_MODE_SLAVE_TX))
 8007542:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007544:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8007548:	d003      	beq.n	8007552 <HAL_I2S_IRQHandler+0x186>
 800754a:	6a3b      	ldr	r3, [r7, #32]
 800754c:	2b00      	cmp	r3, #0
 800754e:	f040 80f2 	bne.w	8007736 <HAL_I2S_IRQHandler+0x36a>
    { 
      tmp1 = I2SxEXT(hi2s->Instance)->SR & SPI_SR_RXNE; 
 8007552:	687b      	ldr	r3, [r7, #4]
 8007554:	681a      	ldr	r2, [r3, #0]
 8007556:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800755a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800755e:	429a      	cmp	r2, r3
 8007560:	d104      	bne.n	800756c <HAL_I2S_IRQHandler+0x1a0>
 8007562:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8007566:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800756a:	e001      	b.n	8007570 <HAL_I2S_IRQHandler+0x1a4>
 800756c:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8007570:	689b      	ldr	r3, [r3, #8]
 8007572:	f003 0301 	and.w	r3, r3, #1
 8007576:	627b      	str	r3, [r7, #36]	; 0x24
      tmp2 = I2SxEXT(hi2s->Instance)->CR2 & I2S_IT_RXNE;  
 8007578:	687b      	ldr	r3, [r7, #4]
 800757a:	681a      	ldr	r2, [r3, #0]
 800757c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007580:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007584:	429a      	cmp	r2, r3
 8007586:	d104      	bne.n	8007592 <HAL_I2S_IRQHandler+0x1c6>
 8007588:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 800758c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007590:	e001      	b.n	8007596 <HAL_I2S_IRQHandler+0x1ca>
 8007592:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8007596:	685b      	ldr	r3, [r3, #4]
 8007598:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800759c:	623b      	str	r3, [r7, #32]
      /* I2Sext in mode Receiver ---------------------------------------------*/
      if((tmp1 == SPI_SR_RXNE) && (tmp2 == I2S_IT_RXNE))
 800759e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80075a0:	2b01      	cmp	r3, #1
 80075a2:	d118      	bne.n	80075d6 <HAL_I2S_IRQHandler+0x20a>
 80075a4:	6a3b      	ldr	r3, [r7, #32]
 80075a6:	2b40      	cmp	r3, #64	; 0x40
 80075a8:	d115      	bne.n	80075d6 <HAL_I2S_IRQHandler+0x20a>
      {
        tmp1 = hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG;
 80075aa:	687b      	ldr	r3, [r7, #4]
 80075ac:	681b      	ldr	r3, [r3, #0]
 80075ae:	69db      	ldr	r3, [r3, #28]
 80075b0:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80075b4:	627b      	str	r3, [r7, #36]	; 0x24
        tmp2 = hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG;
 80075b6:	687b      	ldr	r3, [r7, #4]
 80075b8:	681b      	ldr	r3, [r3, #0]
 80075ba:	69db      	ldr	r3, [r3, #28]
 80075bc:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80075c0:	623b      	str	r3, [r7, #32]
        /* When the I2S mode is configured as I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX,
        the I2Sext RXNE interrupt will be generated to manage the full-duplex receive phase. */
        if((tmp1 == I2S_MODE_MASTER_TX) || (tmp2 == I2S_MODE_SLAVE_TX))
 80075c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80075c4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80075c8:	d002      	beq.n	80075d0 <HAL_I2S_IRQHandler+0x204>
 80075ca:	6a3b      	ldr	r3, [r7, #32]
 80075cc:	2b00      	cmp	r3, #0
 80075ce:	d102      	bne.n	80075d6 <HAL_I2S_IRQHandler+0x20a>
        {
          I2SEx_TransmitReceive_IT(hi2s);
 80075d0:	6878      	ldr	r0, [r7, #4]
 80075d2:	f000 f9a3 	bl	800791c <I2SEx_TransmitReceive_IT>
        }
      }

      tmp1 = I2SxEXT(hi2s->Instance)->SR & SPI_SR_OVR;
 80075d6:	687b      	ldr	r3, [r7, #4]
 80075d8:	681a      	ldr	r2, [r3, #0]
 80075da:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80075de:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80075e2:	429a      	cmp	r2, r3
 80075e4:	d104      	bne.n	80075f0 <HAL_I2S_IRQHandler+0x224>
 80075e6:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 80075ea:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80075ee:	e001      	b.n	80075f4 <HAL_I2S_IRQHandler+0x228>
 80075f0:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 80075f4:	689b      	ldr	r3, [r3, #8]
 80075f6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80075fa:	627b      	str	r3, [r7, #36]	; 0x24
      tmp2 = I2SxEXT(hi2s->Instance)->CR2 & I2S_IT_ERR;
 80075fc:	687b      	ldr	r3, [r7, #4]
 80075fe:	681a      	ldr	r2, [r3, #0]
 8007600:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007604:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007608:	429a      	cmp	r2, r3
 800760a:	d104      	bne.n	8007616 <HAL_I2S_IRQHandler+0x24a>
 800760c:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8007610:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007614:	e001      	b.n	800761a <HAL_I2S_IRQHandler+0x24e>
 8007616:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800761a:	685b      	ldr	r3, [r3, #4]
 800761c:	f003 0320 	and.w	r3, r3, #32
 8007620:	623b      	str	r3, [r7, #32]
      /* I2Sext Overrun error interrupt occurred -----------------------------*/
      if((tmp1 == SPI_SR_OVR) && (tmp2 == I2S_IT_ERR))
 8007622:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007624:	2b40      	cmp	r3, #64	; 0x40
 8007626:	d12b      	bne.n	8007680 <HAL_I2S_IRQHandler+0x2b4>
 8007628:	6a3b      	ldr	r3, [r7, #32]
 800762a:	2b20      	cmp	r3, #32
 800762c:	d128      	bne.n	8007680 <HAL_I2S_IRQHandler+0x2b4>
      {
        /* Clear I2Sext OVR Flag */ 
        tmpreg1 = I2SxEXT(hi2s->Instance)->DR;
 800762e:	687b      	ldr	r3, [r7, #4]
 8007630:	681a      	ldr	r2, [r3, #0]
 8007632:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007636:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800763a:	429a      	cmp	r2, r3
 800763c:	d104      	bne.n	8007648 <HAL_I2S_IRQHandler+0x27c>
 800763e:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8007642:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007646:	e001      	b.n	800764c <HAL_I2S_IRQHandler+0x280>
 8007648:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800764c:	68db      	ldr	r3, [r3, #12]
 800764e:	61fb      	str	r3, [r7, #28]
        tmpreg1 = I2SxEXT(hi2s->Instance)->SR;
 8007650:	687b      	ldr	r3, [r7, #4]
 8007652:	681a      	ldr	r2, [r3, #0]
 8007654:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007658:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800765c:	429a      	cmp	r2, r3
 800765e:	d104      	bne.n	800766a <HAL_I2S_IRQHandler+0x29e>
 8007660:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8007664:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007668:	e001      	b.n	800766e <HAL_I2S_IRQHandler+0x2a2>
 800766a:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800766e:	689b      	ldr	r3, [r3, #8]
 8007670:	61fb      	str	r3, [r7, #28]
        hi2s->ErrorCode |= HAL_I2SEX_ERROR_OVR;
 8007672:	687b      	ldr	r3, [r7, #4]
 8007674:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007676:	f043 0208 	orr.w	r2, r3, #8
 800767a:	687b      	ldr	r3, [r7, #4]
 800767c:	641a      	str	r2, [r3, #64]	; 0x40
        UNUSED(tmpreg1);
 800767e:	69fb      	ldr	r3, [r7, #28]
      }

      tmp1 = __HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_TXE);
 8007680:	687b      	ldr	r3, [r7, #4]
 8007682:	681b      	ldr	r3, [r3, #0]
 8007684:	689b      	ldr	r3, [r3, #8]
 8007686:	f003 0302 	and.w	r3, r3, #2
 800768a:	2b00      	cmp	r3, #0
 800768c:	bf0c      	ite	eq
 800768e:	2300      	moveq	r3, #0
 8007690:	2301      	movne	r3, #1
 8007692:	b2db      	uxtb	r3, r3
 8007694:	627b      	str	r3, [r7, #36]	; 0x24
      tmp2 = __HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_TXE);
 8007696:	687b      	ldr	r3, [r7, #4]
 8007698:	681b      	ldr	r3, [r3, #0]
 800769a:	685b      	ldr	r3, [r3, #4]
 800769c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80076a0:	2b00      	cmp	r3, #0
 80076a2:	bf0c      	ite	eq
 80076a4:	2300      	moveq	r3, #0
 80076a6:	2301      	movne	r3, #1
 80076a8:	b2db      	uxtb	r3, r3
 80076aa:	623b      	str	r3, [r7, #32]
      /* I2S in mode Tramitter -----------------------------------------------*/
      if((tmp1 != RESET) && (tmp2 != RESET))
 80076ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80076ae:	2b00      	cmp	r3, #0
 80076b0:	d018      	beq.n	80076e4 <HAL_I2S_IRQHandler+0x318>
 80076b2:	6a3b      	ldr	r3, [r7, #32]
 80076b4:	2b00      	cmp	r3, #0
 80076b6:	d015      	beq.n	80076e4 <HAL_I2S_IRQHandler+0x318>
      {
        tmp1 = hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG;
 80076b8:	687b      	ldr	r3, [r7, #4]
 80076ba:	681b      	ldr	r3, [r3, #0]
 80076bc:	69db      	ldr	r3, [r3, #28]
 80076be:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80076c2:	627b      	str	r3, [r7, #36]	; 0x24
        tmp2 = hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG;
 80076c4:	687b      	ldr	r3, [r7, #4]
 80076c6:	681b      	ldr	r3, [r3, #0]
 80076c8:	69db      	ldr	r3, [r3, #28]
 80076ca:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80076ce:	623b      	str	r3, [r7, #32]
        /* When the I2S mode is configured as I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX,
        the I2S TXE interrupt will be generated to manage the full-duplex transmit phase. */
        if((tmp1 == I2S_MODE_MASTER_TX) || (tmp2 == I2S_MODE_SLAVE_TX))
 80076d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80076d2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80076d6:	d002      	beq.n	80076de <HAL_I2S_IRQHandler+0x312>
 80076d8:	6a3b      	ldr	r3, [r7, #32]
 80076da:	2b00      	cmp	r3, #0
 80076dc:	d102      	bne.n	80076e4 <HAL_I2S_IRQHandler+0x318>
        {
          I2SEx_TransmitReceive_IT(hi2s);
 80076de:	6878      	ldr	r0, [r7, #4]
 80076e0:	f000 f91c 	bl	800791c <I2SEx_TransmitReceive_IT>
        }
      }

      tmp1 = __HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_UDR);
 80076e4:	687b      	ldr	r3, [r7, #4]
 80076e6:	681b      	ldr	r3, [r3, #0]
 80076e8:	689b      	ldr	r3, [r3, #8]
 80076ea:	f003 0308 	and.w	r3, r3, #8
 80076ee:	2b00      	cmp	r3, #0
 80076f0:	bf0c      	ite	eq
 80076f2:	2300      	moveq	r3, #0
 80076f4:	2301      	movne	r3, #1
 80076f6:	b2db      	uxtb	r3, r3
 80076f8:	627b      	str	r3, [r7, #36]	; 0x24
      tmp2 = __HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR);
 80076fa:	687b      	ldr	r3, [r7, #4]
 80076fc:	681b      	ldr	r3, [r3, #0]
 80076fe:	685b      	ldr	r3, [r3, #4]
 8007700:	f003 0320 	and.w	r3, r3, #32
 8007704:	2b00      	cmp	r3, #0
 8007706:	bf0c      	ite	eq
 8007708:	2300      	moveq	r3, #0
 800770a:	2301      	movne	r3, #1
 800770c:	b2db      	uxtb	r3, r3
 800770e:	623b      	str	r3, [r7, #32]
      /* I2S Underrun error interrupt occurred -------------------------------*/
      if((tmp1 != RESET) && (tmp2 != RESET))
 8007710:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007712:	2b00      	cmp	r3, #0
 8007714:	d00e      	beq.n	8007734 <HAL_I2S_IRQHandler+0x368>
 8007716:	6a3b      	ldr	r3, [r7, #32]
 8007718:	2b00      	cmp	r3, #0
 800771a:	d00b      	beq.n	8007734 <HAL_I2S_IRQHandler+0x368>
      {
        __HAL_I2S_CLEAR_UDRFLAG(hi2s);
 800771c:	687b      	ldr	r3, [r7, #4]
 800771e:	681b      	ldr	r3, [r3, #0]
 8007720:	689b      	ldr	r3, [r3, #8]
 8007722:	613b      	str	r3, [r7, #16]
 8007724:	693b      	ldr	r3, [r7, #16]
        hi2s->ErrorCode |= HAL_I2S_ERROR_UDR;
 8007726:	687b      	ldr	r3, [r7, #4]
 8007728:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800772a:	f043 0201 	orr.w	r2, r3, #1
 800772e:	687b      	ldr	r3, [r7, #4]
 8007730:	641a      	str	r2, [r3, #64]	; 0x40
      }

      tmp1 = __HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_UDR);
      tmp2 = __HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR);
      /* I2S Underrun error interrupt occurred -------------------------------*/
      if((tmp1 != RESET) && (tmp2 != RESET))
 8007732:	e0e5      	b.n	8007900 <HAL_I2S_IRQHandler+0x534>
 8007734:	e0e4      	b.n	8007900 <HAL_I2S_IRQHandler+0x534>
      }
    }
    /* The I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX Mode is selected */
    else
    {
      tmp1 = __HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_RXNE);
 8007736:	687b      	ldr	r3, [r7, #4]
 8007738:	681b      	ldr	r3, [r3, #0]
 800773a:	689b      	ldr	r3, [r3, #8]
 800773c:	f003 0301 	and.w	r3, r3, #1
 8007740:	2b00      	cmp	r3, #0
 8007742:	bf0c      	ite	eq
 8007744:	2300      	moveq	r3, #0
 8007746:	2301      	movne	r3, #1
 8007748:	b2db      	uxtb	r3, r3
 800774a:	627b      	str	r3, [r7, #36]	; 0x24
      tmp2 = __HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_RXNE);
 800774c:	687b      	ldr	r3, [r7, #4]
 800774e:	681b      	ldr	r3, [r3, #0]
 8007750:	685b      	ldr	r3, [r3, #4]
 8007752:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8007756:	2b00      	cmp	r3, #0
 8007758:	bf0c      	ite	eq
 800775a:	2300      	moveq	r3, #0
 800775c:	2301      	movne	r3, #1
 800775e:	b2db      	uxtb	r3, r3
 8007760:	623b      	str	r3, [r7, #32]
      /* I2S in mode Receiver ------------------------------------------------*/
      if((tmp1 != RESET) && (tmp2 != RESET))
 8007762:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007764:	2b00      	cmp	r3, #0
 8007766:	d019      	beq.n	800779c <HAL_I2S_IRQHandler+0x3d0>
 8007768:	6a3b      	ldr	r3, [r7, #32]
 800776a:	2b00      	cmp	r3, #0
 800776c:	d016      	beq.n	800779c <HAL_I2S_IRQHandler+0x3d0>
      {
        tmp1 = hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG;
 800776e:	687b      	ldr	r3, [r7, #4]
 8007770:	681b      	ldr	r3, [r3, #0]
 8007772:	69db      	ldr	r3, [r3, #28]
 8007774:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8007778:	627b      	str	r3, [r7, #36]	; 0x24
        tmp2 = hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG;
 800777a:	687b      	ldr	r3, [r7, #4]
 800777c:	681b      	ldr	r3, [r3, #0]
 800777e:	69db      	ldr	r3, [r3, #28]
 8007780:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8007784:	623b      	str	r3, [r7, #32]
        /* When the I2S mode is configured as I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX,
        the I2S RXNE interrupt will be generated to manage the full-duplex receive phase. */
        if((tmp1 == I2S_MODE_MASTER_RX) || (tmp2 == I2S_MODE_SLAVE_RX))
 8007786:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007788:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800778c:	d003      	beq.n	8007796 <HAL_I2S_IRQHandler+0x3ca>
 800778e:	6a3b      	ldr	r3, [r7, #32]
 8007790:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8007794:	d102      	bne.n	800779c <HAL_I2S_IRQHandler+0x3d0>
        {
          I2SEx_TransmitReceive_IT(hi2s);
 8007796:	6878      	ldr	r0, [r7, #4]
 8007798:	f000 f8c0 	bl	800791c <I2SEx_TransmitReceive_IT>
        }
      }

      tmp1 = __HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_OVR);
 800779c:	687b      	ldr	r3, [r7, #4]
 800779e:	681b      	ldr	r3, [r3, #0]
 80077a0:	689b      	ldr	r3, [r3, #8]
 80077a2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80077a6:	2b00      	cmp	r3, #0
 80077a8:	bf0c      	ite	eq
 80077aa:	2300      	moveq	r3, #0
 80077ac:	2301      	movne	r3, #1
 80077ae:	b2db      	uxtb	r3, r3
 80077b0:	627b      	str	r3, [r7, #36]	; 0x24
      tmp2 = __HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR);
 80077b2:	687b      	ldr	r3, [r7, #4]
 80077b4:	681b      	ldr	r3, [r3, #0]
 80077b6:	685b      	ldr	r3, [r3, #4]
 80077b8:	f003 0320 	and.w	r3, r3, #32
 80077bc:	2b00      	cmp	r3, #0
 80077be:	bf0c      	ite	eq
 80077c0:	2300      	moveq	r3, #0
 80077c2:	2301      	movne	r3, #1
 80077c4:	b2db      	uxtb	r3, r3
 80077c6:	623b      	str	r3, [r7, #32]
      /* I2S Overrun error interrupt occurred --------------------------------*/
      if((tmp1 != RESET) && (tmp2 != RESET))
 80077c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80077ca:	2b00      	cmp	r3, #0
 80077cc:	d011      	beq.n	80077f2 <HAL_I2S_IRQHandler+0x426>
 80077ce:	6a3b      	ldr	r3, [r7, #32]
 80077d0:	2b00      	cmp	r3, #0
 80077d2:	d00e      	beq.n	80077f2 <HAL_I2S_IRQHandler+0x426>
      {
        __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 80077d4:	687b      	ldr	r3, [r7, #4]
 80077d6:	681b      	ldr	r3, [r3, #0]
 80077d8:	68db      	ldr	r3, [r3, #12]
 80077da:	60fb      	str	r3, [r7, #12]
 80077dc:	687b      	ldr	r3, [r7, #4]
 80077de:	681b      	ldr	r3, [r3, #0]
 80077e0:	689b      	ldr	r3, [r3, #8]
 80077e2:	60fb      	str	r3, [r7, #12]
 80077e4:	68fb      	ldr	r3, [r7, #12]
        hi2s->ErrorCode |= HAL_I2S_ERROR_OVR;
 80077e6:	687b      	ldr	r3, [r7, #4]
 80077e8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80077ea:	f043 0202 	orr.w	r2, r3, #2
 80077ee:	687b      	ldr	r3, [r7, #4]
 80077f0:	641a      	str	r2, [r3, #64]	; 0x40
      }

      tmp1 = I2SxEXT(hi2s->Instance)->SR & SPI_SR_TXE;
 80077f2:	687b      	ldr	r3, [r7, #4]
 80077f4:	681a      	ldr	r2, [r3, #0]
 80077f6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80077fa:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80077fe:	429a      	cmp	r2, r3
 8007800:	d104      	bne.n	800780c <HAL_I2S_IRQHandler+0x440>
 8007802:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8007806:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800780a:	e001      	b.n	8007810 <HAL_I2S_IRQHandler+0x444>
 800780c:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8007810:	689b      	ldr	r3, [r3, #8]
 8007812:	f003 0302 	and.w	r3, r3, #2
 8007816:	627b      	str	r3, [r7, #36]	; 0x24
      tmp2 = I2SxEXT(hi2s->Instance)->CR2 & I2S_IT_TXE; 
 8007818:	687b      	ldr	r3, [r7, #4]
 800781a:	681a      	ldr	r2, [r3, #0]
 800781c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007820:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007824:	429a      	cmp	r2, r3
 8007826:	d104      	bne.n	8007832 <HAL_I2S_IRQHandler+0x466>
 8007828:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 800782c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007830:	e001      	b.n	8007836 <HAL_I2S_IRQHandler+0x46a>
 8007832:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8007836:	685b      	ldr	r3, [r3, #4]
 8007838:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800783c:	623b      	str	r3, [r7, #32]
      /* I2Sext in mode Tramitter --------------------------------------------*/
      if((tmp1 == SPI_SR_TXE) && (tmp2 == I2S_IT_TXE))
 800783e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007840:	2b02      	cmp	r3, #2
 8007842:	d119      	bne.n	8007878 <HAL_I2S_IRQHandler+0x4ac>
 8007844:	6a3b      	ldr	r3, [r7, #32]
 8007846:	2b80      	cmp	r3, #128	; 0x80
 8007848:	d116      	bne.n	8007878 <HAL_I2S_IRQHandler+0x4ac>
      {
        tmp1 = hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG;
 800784a:	687b      	ldr	r3, [r7, #4]
 800784c:	681b      	ldr	r3, [r3, #0]
 800784e:	69db      	ldr	r3, [r3, #28]
 8007850:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8007854:	627b      	str	r3, [r7, #36]	; 0x24
        tmp2 = hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG;
 8007856:	687b      	ldr	r3, [r7, #4]
 8007858:	681b      	ldr	r3, [r3, #0]
 800785a:	69db      	ldr	r3, [r3, #28]
 800785c:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8007860:	623b      	str	r3, [r7, #32]
        /* When the I2S mode is configured as I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX,
        the I2Sext TXE interrupt will be generated to manage the full-duplex transmit phase. */
        if((tmp1 == I2S_MODE_MASTER_RX) || (tmp2 == I2S_MODE_SLAVE_RX))
 8007862:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007864:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8007868:	d003      	beq.n	8007872 <HAL_I2S_IRQHandler+0x4a6>
 800786a:	6a3b      	ldr	r3, [r7, #32]
 800786c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8007870:	d102      	bne.n	8007878 <HAL_I2S_IRQHandler+0x4ac>
        {
          I2SEx_TransmitReceive_IT(hi2s);
 8007872:	6878      	ldr	r0, [r7, #4]
 8007874:	f000 f852 	bl	800791c <I2SEx_TransmitReceive_IT>
        }
      }

      tmp1 = I2SxEXT(hi2s->Instance)->SR & SPI_SR_UDR;
 8007878:	687b      	ldr	r3, [r7, #4]
 800787a:	681a      	ldr	r2, [r3, #0]
 800787c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007880:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007884:	429a      	cmp	r2, r3
 8007886:	d104      	bne.n	8007892 <HAL_I2S_IRQHandler+0x4c6>
 8007888:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 800788c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007890:	e001      	b.n	8007896 <HAL_I2S_IRQHandler+0x4ca>
 8007892:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8007896:	689b      	ldr	r3, [r3, #8]
 8007898:	f003 0308 	and.w	r3, r3, #8
 800789c:	627b      	str	r3, [r7, #36]	; 0x24
      tmp2 = I2SxEXT(hi2s->Instance)->CR2 & I2S_IT_ERR;
 800789e:	687b      	ldr	r3, [r7, #4]
 80078a0:	681a      	ldr	r2, [r3, #0]
 80078a2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80078a6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80078aa:	429a      	cmp	r2, r3
 80078ac:	d104      	bne.n	80078b8 <HAL_I2S_IRQHandler+0x4ec>
 80078ae:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 80078b2:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80078b6:	e001      	b.n	80078bc <HAL_I2S_IRQHandler+0x4f0>
 80078b8:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 80078bc:	685b      	ldr	r3, [r3, #4]
 80078be:	f003 0320 	and.w	r3, r3, #32
 80078c2:	623b      	str	r3, [r7, #32]
      /* I2Sext Underrun error interrupt occurred ----------------------------*/
      if((tmp1 == SPI_SR_UDR) && (tmp2 == I2S_IT_ERR))
 80078c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80078c6:	2b08      	cmp	r3, #8
 80078c8:	d11a      	bne.n	8007900 <HAL_I2S_IRQHandler+0x534>
 80078ca:	6a3b      	ldr	r3, [r7, #32]
 80078cc:	2b20      	cmp	r3, #32
 80078ce:	d117      	bne.n	8007900 <HAL_I2S_IRQHandler+0x534>
      {
        /* Clear I2Sext UDR Flag */ 
        tmpreg1 = I2SxEXT(hi2s->Instance)->SR;
 80078d0:	687b      	ldr	r3, [r7, #4]
 80078d2:	681a      	ldr	r2, [r3, #0]
 80078d4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80078d8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80078dc:	429a      	cmp	r2, r3
 80078de:	d104      	bne.n	80078ea <HAL_I2S_IRQHandler+0x51e>
 80078e0:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 80078e4:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80078e8:	e001      	b.n	80078ee <HAL_I2S_IRQHandler+0x522>
 80078ea:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 80078ee:	689b      	ldr	r3, [r3, #8]
 80078f0:	61fb      	str	r3, [r7, #28]
        hi2s->ErrorCode |= HAL_I2SEX_ERROR_UDR;
 80078f2:	687b      	ldr	r3, [r7, #4]
 80078f4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80078f6:	f043 0204 	orr.w	r2, r3, #4
 80078fa:	687b      	ldr	r3, [r7, #4]
 80078fc:	641a      	str	r2, [r3, #64]	; 0x40
        UNUSED(tmpreg1);
 80078fe:	69fb      	ldr	r3, [r7, #28]
      }
    }
  }

  /* Call the Error call Back in case of Errors */
  if(hi2s->ErrorCode != HAL_I2S_ERROR_NONE)
 8007900:	687b      	ldr	r3, [r7, #4]
 8007902:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007904:	2b00      	cmp	r3, #0
 8007906:	d006      	beq.n	8007916 <HAL_I2S_IRQHandler+0x54a>
  {
    /* Set the I2S state ready to be able to start again the process */
    hi2s->State= HAL_I2S_STATE_READY;
 8007908:	687b      	ldr	r3, [r7, #4]
 800790a:	2201      	movs	r2, #1
 800790c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    HAL_I2S_ErrorCallback(hi2s);
 8007910:	6878      	ldr	r0, [r7, #4]
 8007912:	f7fe fb97 	bl	8006044 <HAL_I2S_ErrorCallback>
  }
}
 8007916:	3728      	adds	r7, #40	; 0x28
 8007918:	46bd      	mov	sp, r7
 800791a:	bd80      	pop	{r7, pc}

0800791c <I2SEx_TransmitReceive_IT>:
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval HAL status
  */
HAL_StatusTypeDef I2SEx_TransmitReceive_IT(I2S_HandleTypeDef *hi2s)
{
 800791c:	b580      	push	{r7, lr}
 800791e:	b084      	sub	sp, #16
 8007920:	af00      	add	r7, sp, #0
 8007922:	6078      	str	r0, [r7, #4]
  uint32_t tmp1 = 0, tmp2 = 0;
 8007924:	2300      	movs	r3, #0
 8007926:	60fb      	str	r3, [r7, #12]
 8007928:	2300      	movs	r3, #0
 800792a:	60bb      	str	r3, [r7, #8]
  
  if(hi2s->State == HAL_I2S_STATE_BUSY_TX_RX)
 800792c:	687b      	ldr	r3, [r7, #4]
 800792e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8007932:	b2db      	uxtb	r3, r3
 8007934:	2b32      	cmp	r3, #50	; 0x32
 8007936:	f040 8178 	bne.w	8007c2a <I2SEx_TransmitReceive_IT+0x30e>
  {
    /* Process Locked */
    __HAL_LOCK(hi2s);
 800793a:	687b      	ldr	r3, [r7, #4]
 800793c:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8007940:	b2db      	uxtb	r3, r3
 8007942:	2b01      	cmp	r3, #1
 8007944:	d101      	bne.n	800794a <I2SEx_TransmitReceive_IT+0x2e>
 8007946:	2302      	movs	r3, #2
 8007948:	e170      	b.n	8007c2c <I2SEx_TransmitReceive_IT+0x310>
 800794a:	687b      	ldr	r3, [r7, #4]
 800794c:	2201      	movs	r2, #1
 800794e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    tmp1 = hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG;
 8007952:	687b      	ldr	r3, [r7, #4]
 8007954:	681b      	ldr	r3, [r3, #0]
 8007956:	69db      	ldr	r3, [r3, #28]
 8007958:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800795c:	60fb      	str	r3, [r7, #12]
    tmp2 = hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG;
 800795e:	687b      	ldr	r3, [r7, #4]
 8007960:	681b      	ldr	r3, [r3, #0]
 8007962:	69db      	ldr	r3, [r3, #28]
 8007964:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8007968:	60bb      	str	r3, [r7, #8]
    /* Check if the I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX Mode is selected */
    if((tmp1 == I2S_MODE_MASTER_TX) || (tmp2 == I2S_MODE_SLAVE_TX))
 800796a:	68fb      	ldr	r3, [r7, #12]
 800796c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8007970:	d003      	beq.n	800797a <I2SEx_TransmitReceive_IT+0x5e>
 8007972:	68bb      	ldr	r3, [r7, #8]
 8007974:	2b00      	cmp	r3, #0
 8007976:	f040 8089 	bne.w	8007a8c <I2SEx_TransmitReceive_IT+0x170>
    {
      if(hi2s->TxXferCount != 0)
 800797a:	687b      	ldr	r3, [r7, #4]
 800797c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800797e:	b29b      	uxth	r3, r3
 8007980:	2b00      	cmp	r3, #0
 8007982:	d023      	beq.n	80079cc <I2SEx_TransmitReceive_IT+0xb0>
      {
        if(__HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_TXE) != RESET)
 8007984:	687b      	ldr	r3, [r7, #4]
 8007986:	681b      	ldr	r3, [r3, #0]
 8007988:	689b      	ldr	r3, [r3, #8]
 800798a:	f003 0302 	and.w	r3, r3, #2
 800798e:	2b00      	cmp	r3, #0
 8007990:	d01c      	beq.n	80079cc <I2SEx_TransmitReceive_IT+0xb0>
        {        
          /* Transmit data */
          hi2s->Instance->DR = (*hi2s->pTxBuffPtr++);
 8007992:	687b      	ldr	r3, [r7, #4]
 8007994:	681a      	ldr	r2, [r3, #0]
 8007996:	687b      	ldr	r3, [r7, #4]
 8007998:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800799a:	1c98      	adds	r0, r3, #2
 800799c:	6879      	ldr	r1, [r7, #4]
 800799e:	6248      	str	r0, [r1, #36]	; 0x24
 80079a0:	881b      	ldrh	r3, [r3, #0]
 80079a2:	60d3      	str	r3, [r2, #12]
          hi2s->TxXferCount--;
 80079a4:	687b      	ldr	r3, [r7, #4]
 80079a6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80079a8:	b29b      	uxth	r3, r3
 80079aa:	3b01      	subs	r3, #1
 80079ac:	b29a      	uxth	r2, r3
 80079ae:	687b      	ldr	r3, [r7, #4]
 80079b0:	855a      	strh	r2, [r3, #42]	; 0x2a

          if(hi2s->TxXferCount == 0)
 80079b2:	687b      	ldr	r3, [r7, #4]
 80079b4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80079b6:	b29b      	uxth	r3, r3
 80079b8:	2b00      	cmp	r3, #0
 80079ba:	d107      	bne.n	80079cc <I2SEx_TransmitReceive_IT+0xb0>
          {
            /* Disable TXE interrupt */
            __HAL_I2S_DISABLE_IT(hi2s, I2S_IT_TXE);
 80079bc:	687b      	ldr	r3, [r7, #4]
 80079be:	681b      	ldr	r3, [r3, #0]
 80079c0:	687a      	ldr	r2, [r7, #4]
 80079c2:	6812      	ldr	r2, [r2, #0]
 80079c4:	6852      	ldr	r2, [r2, #4]
 80079c6:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80079ca:	605a      	str	r2, [r3, #4]
          }
        }
      }

      if(hi2s->RxXferCount != 0)
 80079cc:	687b      	ldr	r3, [r7, #4]
 80079ce:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 80079d0:	b29b      	uxth	r3, r3
 80079d2:	2b00      	cmp	r3, #0
 80079d4:	d059      	beq.n	8007a8a <I2SEx_TransmitReceive_IT+0x16e>
      {
        if((I2SxEXT(hi2s->Instance)->SR & SPI_SR_RXNE) == SPI_SR_RXNE)
 80079d6:	687b      	ldr	r3, [r7, #4]
 80079d8:	681a      	ldr	r2, [r3, #0]
 80079da:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80079de:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80079e2:	429a      	cmp	r2, r3
 80079e4:	d104      	bne.n	80079f0 <I2SEx_TransmitReceive_IT+0xd4>
 80079e6:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 80079ea:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80079ee:	e001      	b.n	80079f4 <I2SEx_TransmitReceive_IT+0xd8>
 80079f0:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 80079f4:	689b      	ldr	r3, [r3, #8]
 80079f6:	f003 0301 	and.w	r3, r3, #1
 80079fa:	2b00      	cmp	r3, #0
 80079fc:	d045      	beq.n	8007a8a <I2SEx_TransmitReceive_IT+0x16e>
        {
          /* Receive data */
          (*hi2s->pRxBuffPtr++) = I2SxEXT(hi2s->Instance)->DR;
 80079fe:	687b      	ldr	r3, [r7, #4]
 8007a00:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8007a02:	1c91      	adds	r1, r2, #2
 8007a04:	687b      	ldr	r3, [r7, #4]
 8007a06:	62d9      	str	r1, [r3, #44]	; 0x2c
 8007a08:	687b      	ldr	r3, [r7, #4]
 8007a0a:	6819      	ldr	r1, [r3, #0]
 8007a0c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007a10:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007a14:	4299      	cmp	r1, r3
 8007a16:	d104      	bne.n	8007a22 <I2SEx_TransmitReceive_IT+0x106>
 8007a18:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8007a1c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007a20:	e001      	b.n	8007a26 <I2SEx_TransmitReceive_IT+0x10a>
 8007a22:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8007a26:	68db      	ldr	r3, [r3, #12]
 8007a28:	b29b      	uxth	r3, r3
 8007a2a:	8013      	strh	r3, [r2, #0]
          hi2s->RxXferCount--;
 8007a2c:	687b      	ldr	r3, [r7, #4]
 8007a2e:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8007a30:	b29b      	uxth	r3, r3
 8007a32:	3b01      	subs	r3, #1
 8007a34:	b29a      	uxth	r2, r3
 8007a36:	687b      	ldr	r3, [r7, #4]
 8007a38:	865a      	strh	r2, [r3, #50]	; 0x32

          if(hi2s->RxXferCount == 0)
 8007a3a:	687b      	ldr	r3, [r7, #4]
 8007a3c:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8007a3e:	b29b      	uxth	r3, r3
 8007a40:	2b00      	cmp	r3, #0
 8007a42:	d122      	bne.n	8007a8a <I2SEx_TransmitReceive_IT+0x16e>
          {
            /* Disable I2Sext RXNE interrupt */
            I2SxEXT(hi2s->Instance)->CR2 &= ~I2S_IT_RXNE;
 8007a44:	687b      	ldr	r3, [r7, #4]
 8007a46:	681a      	ldr	r2, [r3, #0]
 8007a48:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007a4c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007a50:	429a      	cmp	r2, r3
 8007a52:	d104      	bne.n	8007a5e <I2SEx_TransmitReceive_IT+0x142>
 8007a54:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8007a58:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007a5c:	e001      	b.n	8007a62 <I2SEx_TransmitReceive_IT+0x146>
 8007a5e:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8007a62:	687a      	ldr	r2, [r7, #4]
 8007a64:	6811      	ldr	r1, [r2, #0]
 8007a66:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8007a6a:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8007a6e:	4291      	cmp	r1, r2
 8007a70:	d104      	bne.n	8007a7c <I2SEx_TransmitReceive_IT+0x160>
 8007a72:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 8007a76:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8007a7a:	e001      	b.n	8007a80 <I2SEx_TransmitReceive_IT+0x164>
 8007a7c:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8007a80:	6852      	ldr	r2, [r2, #4]
 8007a82:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8007a86:	605a      	str	r2, [r3, #4]
            __HAL_I2S_DISABLE_IT(hi2s, I2S_IT_TXE);
          }
        }
      }

      if(hi2s->RxXferCount != 0)
 8007a88:	e08d      	b.n	8007ba6 <I2SEx_TransmitReceive_IT+0x28a>
 8007a8a:	e08c      	b.n	8007ba6 <I2SEx_TransmitReceive_IT+0x28a>
      }
    }
    /* The I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX Mode is selected */ 
    else
    {
      if(hi2s->TxXferCount != 0)
 8007a8c:	687b      	ldr	r3, [r7, #4]
 8007a8e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8007a90:	b29b      	uxth	r3, r3
 8007a92:	2b00      	cmp	r3, #0
 8007a94:	d05a      	beq.n	8007b4c <I2SEx_TransmitReceive_IT+0x230>
      {
        if((I2SxEXT(hi2s->Instance)->SR & SPI_SR_TXE) == SPI_SR_TXE)
 8007a96:	687b      	ldr	r3, [r7, #4]
 8007a98:	681a      	ldr	r2, [r3, #0]
 8007a9a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007a9e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007aa2:	429a      	cmp	r2, r3
 8007aa4:	d104      	bne.n	8007ab0 <I2SEx_TransmitReceive_IT+0x194>
 8007aa6:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8007aaa:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007aae:	e001      	b.n	8007ab4 <I2SEx_TransmitReceive_IT+0x198>
 8007ab0:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8007ab4:	689b      	ldr	r3, [r3, #8]
 8007ab6:	f003 0302 	and.w	r3, r3, #2
 8007aba:	2b00      	cmp	r3, #0
 8007abc:	d046      	beq.n	8007b4c <I2SEx_TransmitReceive_IT+0x230>
        {        
          /* Transmit data */
          I2SxEXT(hi2s->Instance)->DR = (*hi2s->pTxBuffPtr++);
 8007abe:	687b      	ldr	r3, [r7, #4]
 8007ac0:	681a      	ldr	r2, [r3, #0]
 8007ac2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007ac6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007aca:	429a      	cmp	r2, r3
 8007acc:	d104      	bne.n	8007ad8 <I2SEx_TransmitReceive_IT+0x1bc>
 8007ace:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8007ad2:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007ad6:	e001      	b.n	8007adc <I2SEx_TransmitReceive_IT+0x1c0>
 8007ad8:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8007adc:	687a      	ldr	r2, [r7, #4]
 8007ade:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8007ae0:	1c90      	adds	r0, r2, #2
 8007ae2:	6879      	ldr	r1, [r7, #4]
 8007ae4:	6248      	str	r0, [r1, #36]	; 0x24
 8007ae6:	8812      	ldrh	r2, [r2, #0]
 8007ae8:	60da      	str	r2, [r3, #12]
          hi2s->TxXferCount--;
 8007aea:	687b      	ldr	r3, [r7, #4]
 8007aec:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8007aee:	b29b      	uxth	r3, r3
 8007af0:	3b01      	subs	r3, #1
 8007af2:	b29a      	uxth	r2, r3
 8007af4:	687b      	ldr	r3, [r7, #4]
 8007af6:	855a      	strh	r2, [r3, #42]	; 0x2a

          if(hi2s->TxXferCount == 0)
 8007af8:	687b      	ldr	r3, [r7, #4]
 8007afa:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8007afc:	b29b      	uxth	r3, r3
 8007afe:	2b00      	cmp	r3, #0
 8007b00:	d124      	bne.n	8007b4c <I2SEx_TransmitReceive_IT+0x230>
          {
            /* Disable I2Sext TXE interrupt */
            I2SxEXT(hi2s->Instance)->CR2 &= ~I2S_IT_TXE;
 8007b02:	687b      	ldr	r3, [r7, #4]
 8007b04:	681a      	ldr	r2, [r3, #0]
 8007b06:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007b0a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007b0e:	429a      	cmp	r2, r3
 8007b10:	d104      	bne.n	8007b1c <I2SEx_TransmitReceive_IT+0x200>
 8007b12:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8007b16:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007b1a:	e001      	b.n	8007b20 <I2SEx_TransmitReceive_IT+0x204>
 8007b1c:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8007b20:	687a      	ldr	r2, [r7, #4]
 8007b22:	6811      	ldr	r1, [r2, #0]
 8007b24:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8007b28:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8007b2c:	4291      	cmp	r1, r2
 8007b2e:	d104      	bne.n	8007b3a <I2SEx_TransmitReceive_IT+0x21e>
 8007b30:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 8007b34:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8007b38:	e001      	b.n	8007b3e <I2SEx_TransmitReceive_IT+0x222>
 8007b3a:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8007b3e:	6852      	ldr	r2, [r2, #4]
 8007b40:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8007b44:	605a      	str	r2, [r3, #4]

            HAL_I2S_TxCpltCallback(hi2s);
 8007b46:	6878      	ldr	r0, [r7, #4]
 8007b48:	f7f9 fb14 	bl	8001174 <HAL_I2S_TxCpltCallback>
          }
        }
      }
      if(hi2s->RxXferCount != 0)
 8007b4c:	687b      	ldr	r3, [r7, #4]
 8007b4e:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8007b50:	b29b      	uxth	r3, r3
 8007b52:	2b00      	cmp	r3, #0
 8007b54:	d027      	beq.n	8007ba6 <I2SEx_TransmitReceive_IT+0x28a>
      {
        if(__HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_RXNE) != RESET)
 8007b56:	687b      	ldr	r3, [r7, #4]
 8007b58:	681b      	ldr	r3, [r3, #0]
 8007b5a:	689b      	ldr	r3, [r3, #8]
 8007b5c:	f003 0301 	and.w	r3, r3, #1
 8007b60:	2b00      	cmp	r3, #0
 8007b62:	d020      	beq.n	8007ba6 <I2SEx_TransmitReceive_IT+0x28a>
        {
          /* Receive data */
          (*hi2s->pRxBuffPtr++) = hi2s->Instance->DR;
 8007b64:	687b      	ldr	r3, [r7, #4]
 8007b66:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007b68:	1c99      	adds	r1, r3, #2
 8007b6a:	687a      	ldr	r2, [r7, #4]
 8007b6c:	62d1      	str	r1, [r2, #44]	; 0x2c
 8007b6e:	687a      	ldr	r2, [r7, #4]
 8007b70:	6812      	ldr	r2, [r2, #0]
 8007b72:	68d2      	ldr	r2, [r2, #12]
 8007b74:	b292      	uxth	r2, r2
 8007b76:	801a      	strh	r2, [r3, #0]
          hi2s->RxXferCount--;
 8007b78:	687b      	ldr	r3, [r7, #4]
 8007b7a:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8007b7c:	b29b      	uxth	r3, r3
 8007b7e:	3b01      	subs	r3, #1
 8007b80:	b29a      	uxth	r2, r3
 8007b82:	687b      	ldr	r3, [r7, #4]
 8007b84:	865a      	strh	r2, [r3, #50]	; 0x32

          if(hi2s->RxXferCount == 0)
 8007b86:	687b      	ldr	r3, [r7, #4]
 8007b88:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8007b8a:	b29b      	uxth	r3, r3
 8007b8c:	2b00      	cmp	r3, #0
 8007b8e:	d10a      	bne.n	8007ba6 <I2SEx_TransmitReceive_IT+0x28a>
          {
            /* Disable RXNE interrupt */
            __HAL_I2S_DISABLE_IT(hi2s, I2S_IT_RXNE);
 8007b90:	687b      	ldr	r3, [r7, #4]
 8007b92:	681b      	ldr	r3, [r3, #0]
 8007b94:	687a      	ldr	r2, [r7, #4]
 8007b96:	6812      	ldr	r2, [r2, #0]
 8007b98:	6852      	ldr	r2, [r2, #4]
 8007b9a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8007b9e:	605a      	str	r2, [r3, #4]

            HAL_I2S_RxCpltCallback(hi2s);
 8007ba0:	6878      	ldr	r0, [r7, #4]
 8007ba2:	f7f9 fafb 	bl	800119c <HAL_I2S_RxCpltCallback>
          }
        }
      }
    }

    tmp1 = hi2s->RxXferCount;
 8007ba6:	687b      	ldr	r3, [r7, #4]
 8007ba8:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8007baa:	b29b      	uxth	r3, r3
 8007bac:	60fb      	str	r3, [r7, #12]
    tmp2 = hi2s->TxXferCount;
 8007bae:	687b      	ldr	r3, [r7, #4]
 8007bb0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8007bb2:	b29b      	uxth	r3, r3
 8007bb4:	60bb      	str	r3, [r7, #8]
    if((tmp1 == 0) && (tmp2 == 0))
 8007bb6:	68fb      	ldr	r3, [r7, #12]
 8007bb8:	2b00      	cmp	r3, #0
 8007bba:	d130      	bne.n	8007c1e <I2SEx_TransmitReceive_IT+0x302>
 8007bbc:	68bb      	ldr	r3, [r7, #8]
 8007bbe:	2b00      	cmp	r3, #0
 8007bc0:	d12d      	bne.n	8007c1e <I2SEx_TransmitReceive_IT+0x302>
    {
      /* Disable I2Sx ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, I2S_IT_ERR);
 8007bc2:	687b      	ldr	r3, [r7, #4]
 8007bc4:	681b      	ldr	r3, [r3, #0]
 8007bc6:	687a      	ldr	r2, [r7, #4]
 8007bc8:	6812      	ldr	r2, [r2, #0]
 8007bca:	6852      	ldr	r2, [r2, #4]
 8007bcc:	f022 0220 	bic.w	r2, r2, #32
 8007bd0:	605a      	str	r2, [r3, #4]
      /* Disable I2Sext ERR interrupt */
      I2SxEXT(hi2s->Instance)->CR2 &= ~I2S_IT_ERR;
 8007bd2:	687b      	ldr	r3, [r7, #4]
 8007bd4:	681a      	ldr	r2, [r3, #0]
 8007bd6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007bda:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007bde:	429a      	cmp	r2, r3
 8007be0:	d104      	bne.n	8007bec <I2SEx_TransmitReceive_IT+0x2d0>
 8007be2:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8007be6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007bea:	e001      	b.n	8007bf0 <I2SEx_TransmitReceive_IT+0x2d4>
 8007bec:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8007bf0:	687a      	ldr	r2, [r7, #4]
 8007bf2:	6811      	ldr	r1, [r2, #0]
 8007bf4:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8007bf8:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8007bfc:	4291      	cmp	r1, r2
 8007bfe:	d104      	bne.n	8007c0a <I2SEx_TransmitReceive_IT+0x2ee>
 8007c00:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 8007c04:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8007c08:	e001      	b.n	8007c0e <I2SEx_TransmitReceive_IT+0x2f2>
 8007c0a:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8007c0e:	6852      	ldr	r2, [r2, #4]
 8007c10:	f022 0220 	bic.w	r2, r2, #32
 8007c14:	605a      	str	r2, [r3, #4]
      
      hi2s->State = HAL_I2S_STATE_READY; 
 8007c16:	687b      	ldr	r3, [r7, #4]
 8007c18:	2201      	movs	r2, #1
 8007c1a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2s);
 8007c1e:	687b      	ldr	r3, [r7, #4]
 8007c20:	2200      	movs	r2, #0
 8007c22:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    return HAL_OK;
 8007c26:	2300      	movs	r3, #0
 8007c28:	e000      	b.n	8007c2c <I2SEx_TransmitReceive_IT+0x310>
  }
  else
  {
    return HAL_BUSY; 
 8007c2a:	2302      	movs	r3, #2
  }
}
 8007c2c:	4618      	mov	r0, r3
 8007c2e:	3710      	adds	r7, #16
 8007c30:	46bd      	mov	sp, r7
 8007c32:	bd80      	pop	{r7, pc}

08007c34 <I2S_DMATxCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
void I2S_DMATxCplt(DMA_HandleTypeDef *hdma)
{
 8007c34:	b580      	push	{r7, lr}
 8007c36:	b084      	sub	sp, #16
 8007c38:	af00      	add	r7, sp, #0
 8007c3a:	6078      	str	r0, [r7, #4]
  I2S_HandleTypeDef* hi2s = (I2S_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
 8007c3c:	687b      	ldr	r3, [r7, #4]
 8007c3e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007c40:	60fb      	str	r3, [r7, #12]
  
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 8007c42:	687b      	ldr	r3, [r7, #4]
 8007c44:	681b      	ldr	r3, [r3, #0]
 8007c46:	681b      	ldr	r3, [r3, #0]
 8007c48:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8007c4c:	2b00      	cmp	r3, #0
 8007c4e:	d144      	bne.n	8007cda <I2S_DMATxCplt+0xa6>
  {
    hi2s->TxXferCount = 0;
 8007c50:	68fb      	ldr	r3, [r7, #12]
 8007c52:	2200      	movs	r2, #0
 8007c54:	855a      	strh	r2, [r3, #42]	; 0x2a

    /* Disable Tx DMA Request */
    hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
 8007c56:	68fb      	ldr	r3, [r7, #12]
 8007c58:	681b      	ldr	r3, [r3, #0]
 8007c5a:	68fa      	ldr	r2, [r7, #12]
 8007c5c:	6812      	ldr	r2, [r2, #0]
 8007c5e:	6852      	ldr	r2, [r2, #4]
 8007c60:	f022 0202 	bic.w	r2, r2, #2
 8007c64:	605a      	str	r2, [r3, #4]
#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
    defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) ||\
    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F469xx) ||\
    defined(STM32F479xx) 
    if(hi2s->Init.FullDuplexMode == I2S_FULLDUPLEXMODE_ENABLE)
 8007c66:	68fb      	ldr	r3, [r7, #12]
 8007c68:	6a1b      	ldr	r3, [r3, #32]
 8007c6a:	2b01      	cmp	r3, #1
 8007c6c:	d121      	bne.n	8007cb2 <I2S_DMATxCplt+0x7e>
    {
      /* Disable Rx DMA Request for the slave*/  
      I2SxEXT(hi2s->Instance)->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
 8007c6e:	68fb      	ldr	r3, [r7, #12]
 8007c70:	681a      	ldr	r2, [r3, #0]
 8007c72:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007c76:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007c7a:	429a      	cmp	r2, r3
 8007c7c:	d104      	bne.n	8007c88 <I2S_DMATxCplt+0x54>
 8007c7e:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8007c82:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007c86:	e001      	b.n	8007c8c <I2S_DMATxCplt+0x58>
 8007c88:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8007c8c:	68fa      	ldr	r2, [r7, #12]
 8007c8e:	6811      	ldr	r1, [r2, #0]
 8007c90:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8007c94:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8007c98:	4291      	cmp	r1, r2
 8007c9a:	d104      	bne.n	8007ca6 <I2S_DMATxCplt+0x72>
 8007c9c:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 8007ca0:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8007ca4:	e001      	b.n	8007caa <I2S_DMATxCplt+0x76>
 8007ca6:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8007caa:	6852      	ldr	r2, [r2, #4]
 8007cac:	f022 0201 	bic.w	r2, r2, #1
 8007cb0:	605a      	str	r2, [r3, #4]
    }
#endif /* STM32F40xxx || STM32F41xxx || STM32F42xxx || STM32F43xxx || STM32F401xx || STM32F411xx ||\
          STM32F469xx || STM32F479xx  */
    if(hi2s->State == HAL_I2S_STATE_BUSY_TX_RX)
 8007cb2:	68fb      	ldr	r3, [r7, #12]
 8007cb4:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8007cb8:	b2db      	uxtb	r3, r3
 8007cba:	2b32      	cmp	r3, #50	; 0x32
 8007cbc:	d109      	bne.n	8007cd2 <I2S_DMATxCplt+0x9e>
    {
      if(hi2s->RxXferCount == 0)
 8007cbe:	68fb      	ldr	r3, [r7, #12]
 8007cc0:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8007cc2:	b29b      	uxth	r3, r3
 8007cc4:	2b00      	cmp	r3, #0
 8007cc6:	d108      	bne.n	8007cda <I2S_DMATxCplt+0xa6>
      {
        hi2s->State = HAL_I2S_STATE_READY;
 8007cc8:	68fb      	ldr	r3, [r7, #12]
 8007cca:	2201      	movs	r2, #1
 8007ccc:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8007cd0:	e003      	b.n	8007cda <I2S_DMATxCplt+0xa6>
      }
    }
    else
    {
      hi2s->State = HAL_I2S_STATE_READY; 
 8007cd2:	68fb      	ldr	r3, [r7, #12]
 8007cd4:	2201      	movs	r2, #1
 8007cd6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    }
  }
  HAL_I2S_TxCpltCallback(hi2s);
 8007cda:	68f8      	ldr	r0, [r7, #12]
 8007cdc:	f7f9 fa4a 	bl	8001174 <HAL_I2S_TxCpltCallback>
}
 8007ce0:	3710      	adds	r7, #16
 8007ce2:	46bd      	mov	sp, r7
 8007ce4:	bd80      	pop	{r7, pc}
 8007ce6:	bf00      	nop

08007ce8 <I2S_DMARxCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
void I2S_DMARxCplt(DMA_HandleTypeDef *hdma)
{
 8007ce8:	b580      	push	{r7, lr}
 8007cea:	b084      	sub	sp, #16
 8007cec:	af00      	add	r7, sp, #0
 8007cee:	6078      	str	r0, [r7, #4]
  I2S_HandleTypeDef* hi2s = (I2S_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
 8007cf0:	687b      	ldr	r3, [r7, #4]
 8007cf2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007cf4:	60fb      	str	r3, [r7, #12]

  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 8007cf6:	687b      	ldr	r3, [r7, #4]
 8007cf8:	681b      	ldr	r3, [r3, #0]
 8007cfa:	681b      	ldr	r3, [r3, #0]
 8007cfc:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8007d00:	2b00      	cmp	r3, #0
 8007d02:	d144      	bne.n	8007d8e <I2S_DMARxCplt+0xa6>
  {
    /* Disable Rx DMA Request */
    hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
 8007d04:	68fb      	ldr	r3, [r7, #12]
 8007d06:	681b      	ldr	r3, [r3, #0]
 8007d08:	68fa      	ldr	r2, [r7, #12]
 8007d0a:	6812      	ldr	r2, [r2, #0]
 8007d0c:	6852      	ldr	r2, [r2, #4]
 8007d0e:	f022 0201 	bic.w	r2, r2, #1
 8007d12:	605a      	str	r2, [r3, #4]
#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
    defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) ||\
    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F469xx) ||\
    defined(STM32F479xx) 
    if(hi2s->Init.FullDuplexMode == I2S_FULLDUPLEXMODE_ENABLE)
 8007d14:	68fb      	ldr	r3, [r7, #12]
 8007d16:	6a1b      	ldr	r3, [r3, #32]
 8007d18:	2b01      	cmp	r3, #1
 8007d1a:	d121      	bne.n	8007d60 <I2S_DMARxCplt+0x78>
    {
      /* Disable Tx DMA Request for the slave*/  
      I2SxEXT(hi2s->Instance)->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
 8007d1c:	68fb      	ldr	r3, [r7, #12]
 8007d1e:	681a      	ldr	r2, [r3, #0]
 8007d20:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007d24:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007d28:	429a      	cmp	r2, r3
 8007d2a:	d104      	bne.n	8007d36 <I2S_DMARxCplt+0x4e>
 8007d2c:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 8007d30:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007d34:	e001      	b.n	8007d3a <I2S_DMARxCplt+0x52>
 8007d36:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 8007d3a:	68fa      	ldr	r2, [r7, #12]
 8007d3c:	6811      	ldr	r1, [r2, #0]
 8007d3e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8007d42:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8007d46:	4291      	cmp	r1, r2
 8007d48:	d104      	bne.n	8007d54 <I2S_DMARxCplt+0x6c>
 8007d4a:	f44f 5250 	mov.w	r2, #13312	; 0x3400
 8007d4e:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8007d52:	e001      	b.n	8007d58 <I2S_DMARxCplt+0x70>
 8007d54:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8007d58:	6852      	ldr	r2, [r2, #4]
 8007d5a:	f022 0202 	bic.w	r2, r2, #2
 8007d5e:	605a      	str	r2, [r3, #4]
    }
#endif /* STM32F40xxx || STM32F41xxx || STM32F42xxx || STM32F43xxx || STM32F401xx || STM32F411xx ||\
          STM32F469xx || STM32F479xx  */
    hi2s->RxXferCount = 0;
 8007d60:	68fb      	ldr	r3, [r7, #12]
 8007d62:	2200      	movs	r2, #0
 8007d64:	865a      	strh	r2, [r3, #50]	; 0x32
    if(hi2s->State == HAL_I2S_STATE_BUSY_TX_RX)
 8007d66:	68fb      	ldr	r3, [r7, #12]
 8007d68:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8007d6c:	b2db      	uxtb	r3, r3
 8007d6e:	2b32      	cmp	r3, #50	; 0x32
 8007d70:	d109      	bne.n	8007d86 <I2S_DMARxCplt+0x9e>
    {
      if(hi2s->TxXferCount == 0)
 8007d72:	68fb      	ldr	r3, [r7, #12]
 8007d74:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8007d76:	b29b      	uxth	r3, r3
 8007d78:	2b00      	cmp	r3, #0
 8007d7a:	d108      	bne.n	8007d8e <I2S_DMARxCplt+0xa6>
      {
        hi2s->State = HAL_I2S_STATE_READY;
 8007d7c:	68fb      	ldr	r3, [r7, #12]
 8007d7e:	2201      	movs	r2, #1
 8007d80:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8007d84:	e003      	b.n	8007d8e <I2S_DMARxCplt+0xa6>
      }
    }
    else
    {
      hi2s->State = HAL_I2S_STATE_READY; 
 8007d86:	68fb      	ldr	r3, [r7, #12]
 8007d88:	2201      	movs	r2, #1
 8007d8a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    }
  }
  HAL_I2S_RxCpltCallback(hi2s); 
 8007d8e:	68f8      	ldr	r0, [r7, #12]
 8007d90:	f7f9 fa04 	bl	800119c <HAL_I2S_RxCpltCallback>
}
 8007d94:	3710      	adds	r7, #16
 8007d96:	46bd      	mov	sp, r7
 8007d98:	bd80      	pop	{r7, pc}
 8007d9a:	bf00      	nop

08007d9c <I2S_GetInputClock>:
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval I2S Clock Input
  */
uint32_t I2S_GetInputClock(I2S_HandleTypeDef *hi2s)
{
 8007d9c:	b480      	push	{r7}
 8007d9e:	b087      	sub	sp, #28
 8007da0:	af00      	add	r7, sp, #0
 8007da2:	6078      	str	r0, [r7, #4]
  /* This variable used to store the VCO Input (value in Hz) */
  uint32_t vcoinput = 0;
 8007da4:	2300      	movs	r3, #0
 8007da6:	617b      	str	r3, [r7, #20]
  /* This variable used to store the VCO Output (value in Hz) */
  uint32_t vcooutput = 0;
 8007da8:	2300      	movs	r3, #0
 8007daa:	60fb      	str	r3, [r7, #12]
  /* This variable used to store the I2S_CK_x (value in Hz) */
  uint32_t i2ssourceclock = 0;
 8007dac:	2300      	movs	r3, #0
 8007dae:	613b      	str	r3, [r7, #16]
    defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F469xx) || defined(STM32F479xx)
      
  /* If an external I2S clock has to be used, the specific define should be set  
  in the project configuration or in the stm32f4xx_conf.h file */
  if(hi2s->Init.ClockSource == I2S_CLOCK_EXTERNAL)
 8007db0:	687b      	ldr	r3, [r7, #4]
 8007db2:	69db      	ldr	r3, [r3, #28]
 8007db4:	2b01      	cmp	r3, #1
 8007db6:	d105      	bne.n	8007dc4 <I2S_GetInputClock+0x28>
  {
    /* Set the I2S clock to the external clock  value */
    i2ssourceclock = EXTERNAL_CLOCK_VALUE;
 8007db8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8007dbc:	f2c0 03bb 	movt	r3, #187	; 0xbb
 8007dc0:	613b      	str	r3, [r7, #16]
 8007dc2:	e044      	b.n	8007e4e <I2S_GetInputClock+0xb2>
  }
  else
  { 
    /* Configure the PLLI2S division factor */
    /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
    if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
 8007dc4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007dc8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007dcc:	685b      	ldr	r3, [r3, #4]
 8007dce:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8007dd2:	2b00      	cmp	r3, #0
 8007dd4:	d00e      	beq.n	8007df4 <I2S_GetInputClock+0x58>
    {
      /* Get the I2S source clock value */
      vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 8007dd6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007dda:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007dde:	685b      	ldr	r3, [r3, #4]
 8007de0:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 8007de4:	f44f 5390 	mov.w	r3, #4608	; 0x1200
 8007de8:	f2c0 037a 	movt	r3, #122	; 0x7a
 8007dec:	fbb3 f3f2 	udiv	r3, r3, r2
 8007df0:	617b      	str	r3, [r7, #20]
 8007df2:	e00d      	b.n	8007e10 <I2S_GetInputClock+0x74>
    }
    else
    {
      /* Get the I2S source clock value */
      vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 8007df4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007df8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007dfc:	685b      	ldr	r3, [r3, #4]
 8007dfe:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 8007e02:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 8007e06:	f2c0 03f4 	movt	r3, #244	; 0xf4
 8007e0a:	fbb3 f3f2 	udiv	r3, r3, r2
 8007e0e:	617b      	str	r3, [r7, #20]
    }
    
    /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
    vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & (RCC_PLLI2SCFGR_PLLI2SN >> 6)));
 8007e10:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007e14:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007e18:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 8007e1c:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8007e20:	4013      	ands	r3, r2
 8007e22:	099b      	lsrs	r3, r3, #6
 8007e24:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8007e28:	697a      	ldr	r2, [r7, #20]
 8007e2a:	fb02 f303 	mul.w	r3, r2, r3
 8007e2e:	60fb      	str	r3, [r7, #12]
    /* I2S_CLK = PLLI2S_VCO Output/PLLI2SR */
    i2ssourceclock = (uint32_t)(vcooutput /(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & (RCC_PLLI2SCFGR_PLLI2SR >> 28)));
 8007e30:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007e34:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007e38:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8007e3c:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
 8007e40:	0f1b      	lsrs	r3, r3, #28
 8007e42:	f003 0307 	and.w	r3, r3, #7
 8007e46:	68fa      	ldr	r2, [r7, #12]
 8007e48:	fbb2 f3f3 	udiv	r3, r2, r3
 8007e4c:	613b      	str	r3, [r7, #16]
    i2ssourceclock = (uint32_t)(vcooutput /(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & (RCC_PLLI2SCFGR_PLLI2SR >> 28)));
  }
#endif /* STM32F411xE */

  /* the return result is the value of SAI clock */
  return i2ssourceclock; 
 8007e4e:	693b      	ldr	r3, [r7, #16]
}
 8007e50:	4618      	mov	r0, r3
 8007e52:	371c      	adds	r7, #28
 8007e54:	46bd      	mov	sp, r7
 8007e56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007e5a:	4770      	bx	lr
  *            - Peripheral clocks  
  *            - LSI, LSE and RTC clocks 
  * @retval None
  */
__weak void HAL_RCC_DeInit(void)
{}
 8007e5c:	b480      	push	{r7}
 8007e5e:	af00      	add	r7, sp, #0
 8007e60:	46bd      	mov	sp, r7
 8007e62:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007e66:	4770      	bx	lr

08007e68 <HAL_RCC_OscConfig>:
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8007e68:	b580      	push	{r7, lr}
 8007e6a:	b08e      	sub	sp, #56	; 0x38
 8007e6c:	af00      	add	r7, sp, #0
 8007e6e:	6078      	str	r0, [r7, #4]
 uint32_t tickstart = 0;  
 8007e70:	2300      	movs	r3, #0
 8007e72:	637b      	str	r3, [r7, #52]	; 0x34
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8007e74:	687b      	ldr	r3, [r7, #4]
 8007e76:	681b      	ldr	r3, [r3, #0]
 8007e78:	f003 0301 	and.w	r3, r3, #1
 8007e7c:	2b00      	cmp	r3, #0
 8007e7e:	f000 8086 	beq.w	8007f8e <HAL_RCC_OscConfig+0x126>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
 8007e82:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007e86:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007e8a:	689b      	ldr	r3, [r3, #8]
 8007e8c:	f003 030c 	and.w	r3, r3, #12
 8007e90:	2b04      	cmp	r3, #4
 8007e92:	d011      	beq.n	8007eb8 <HAL_RCC_OscConfig+0x50>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8007e94:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007e98:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007e9c:	689b      	ldr	r3, [r3, #8]
 8007e9e:	f003 030c 	and.w	r3, r3, #12
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
 8007ea2:	2b08      	cmp	r3, #8
 8007ea4:	d118      	bne.n	8007ed8 <HAL_RCC_OscConfig+0x70>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8007ea6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007eaa:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007eae:	685b      	ldr	r3, [r3, #4]
 8007eb0:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8007eb4:	2b00      	cmp	r3, #0
 8007eb6:	d00f      	beq.n	8007ed8 <HAL_RCC_OscConfig+0x70>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8007eb8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007ebc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007ec0:	681b      	ldr	r3, [r3, #0]
 8007ec2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8007ec6:	2b00      	cmp	r3, #0
 8007ec8:	d005      	beq.n	8007ed6 <HAL_RCC_OscConfig+0x6e>
 8007eca:	687b      	ldr	r3, [r7, #4]
 8007ecc:	685b      	ldr	r3, [r3, #4]
 8007ece:	2b00      	cmp	r3, #0
 8007ed0:	d101      	bne.n	8007ed6 <HAL_RCC_OscConfig+0x6e>
      {
        return HAL_ERROR;
 8007ed2:	2301      	movs	r3, #1
 8007ed4:	e27a      	b.n	80083cc <HAL_RCC_OscConfig+0x564>
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8007ed6:	e05a      	b.n	8007f8e <HAL_RCC_OscConfig+0x126>
      }
    }
    else
    {
      /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 8007ed8:	f643 0302 	movw	r3, #14338	; 0x3802
 8007edc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007ee0:	2200      	movs	r2, #0
 8007ee2:	701a      	strb	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8007ee4:	f7f9 fd70 	bl	80019c8 <HAL_GetTick>
 8007ee8:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8007eea:	e00a      	b.n	8007f02 <HAL_RCC_OscConfig+0x9a>
      {
        if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8007eec:	f7f9 fd6c 	bl	80019c8 <HAL_GetTick>
 8007ef0:	4602      	mov	r2, r0
 8007ef2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007ef4:	1ad2      	subs	r2, r2, r3
 8007ef6:	f241 3388 	movw	r3, #5000	; 0x1388
 8007efa:	429a      	cmp	r2, r3
 8007efc:	d901      	bls.n	8007f02 <HAL_RCC_OscConfig+0x9a>
        {
          return HAL_TIMEOUT;
 8007efe:	2303      	movs	r3, #3
 8007f00:	e264      	b.n	80083cc <HAL_RCC_OscConfig+0x564>
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8007f02:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007f06:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007f0a:	681b      	ldr	r3, [r3, #0]
 8007f0c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8007f10:	2b00      	cmp	r3, #0
 8007f12:	d1eb      	bne.n	8007eec <HAL_RCC_OscConfig+0x84>
          return HAL_TIMEOUT;
        }       
      }
      
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8007f14:	f643 0302 	movw	r3, #14338	; 0x3802
 8007f18:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007f1c:	687a      	ldr	r2, [r7, #4]
 8007f1e:	6852      	ldr	r2, [r2, #4]
 8007f20:	b2d2      	uxtb	r2, r2
 8007f22:	701a      	strb	r2, [r3, #0]
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8007f24:	687b      	ldr	r3, [r7, #4]
 8007f26:	685b      	ldr	r3, [r3, #4]
 8007f28:	2b00      	cmp	r3, #0
 8007f2a:	d018      	beq.n	8007f5e <HAL_RCC_OscConfig+0xf6>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8007f2c:	f7f9 fd4c 	bl	80019c8 <HAL_GetTick>
 8007f30:	6378      	str	r0, [r7, #52]	; 0x34
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8007f32:	e00a      	b.n	8007f4a <HAL_RCC_OscConfig+0xe2>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8007f34:	f7f9 fd48 	bl	80019c8 <HAL_GetTick>
 8007f38:	4602      	mov	r2, r0
 8007f3a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007f3c:	1ad2      	subs	r2, r2, r3
 8007f3e:	f241 3388 	movw	r3, #5000	; 0x1388
 8007f42:	429a      	cmp	r2, r3
 8007f44:	d901      	bls.n	8007f4a <HAL_RCC_OscConfig+0xe2>
          {
            return HAL_TIMEOUT;
 8007f46:	2303      	movs	r3, #3
 8007f48:	e240      	b.n	80083cc <HAL_RCC_OscConfig+0x564>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8007f4a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007f4e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007f52:	681b      	ldr	r3, [r3, #0]
 8007f54:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8007f58:	2b00      	cmp	r3, #0
 8007f5a:	d0eb      	beq.n	8007f34 <HAL_RCC_OscConfig+0xcc>
 8007f5c:	e017      	b.n	8007f8e <HAL_RCC_OscConfig+0x126>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8007f5e:	f7f9 fd33 	bl	80019c8 <HAL_GetTick>
 8007f62:	6378      	str	r0, [r7, #52]	; 0x34

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8007f64:	e00a      	b.n	8007f7c <HAL_RCC_OscConfig+0x114>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8007f66:	f7f9 fd2f 	bl	80019c8 <HAL_GetTick>
 8007f6a:	4602      	mov	r2, r0
 8007f6c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007f6e:	1ad2      	subs	r2, r2, r3
 8007f70:	f241 3388 	movw	r3, #5000	; 0x1388
 8007f74:	429a      	cmp	r2, r3
 8007f76:	d901      	bls.n	8007f7c <HAL_RCC_OscConfig+0x114>
          {
            return HAL_TIMEOUT;
 8007f78:	2303      	movs	r3, #3
 8007f7a:	e227      	b.n	80083cc <HAL_RCC_OscConfig+0x564>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8007f7c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007f80:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007f84:	681b      	ldr	r3, [r3, #0]
 8007f86:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8007f8a:	2b00      	cmp	r3, #0
 8007f8c:	d1eb      	bne.n	8007f66 <HAL_RCC_OscConfig+0xfe>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8007f8e:	687b      	ldr	r3, [r7, #4]
 8007f90:	681b      	ldr	r3, [r3, #0]
 8007f92:	f003 0302 	and.w	r3, r3, #2
 8007f96:	2b00      	cmp	r3, #0
 8007f98:	f000 809a 	beq.w	80080d0 <HAL_RCC_OscConfig+0x268>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
 8007f9c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007fa0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007fa4:	689b      	ldr	r3, [r3, #8]
 8007fa6:	f003 030c 	and.w	r3, r3, #12
 8007faa:	2b00      	cmp	r3, #0
 8007fac:	d011      	beq.n	8007fd2 <HAL_RCC_OscConfig+0x16a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8007fae:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007fb2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007fb6:	689b      	ldr	r3, [r3, #8]
 8007fb8:	f003 030c 	and.w	r3, r3, #12
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
 8007fbc:	2b08      	cmp	r3, #8
 8007fbe:	d132      	bne.n	8008026 <HAL_RCC_OscConfig+0x1be>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8007fc0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007fc4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007fc8:	685b      	ldr	r3, [r3, #4]
 8007fca:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8007fce:	2b00      	cmp	r3, #0
 8007fd0:	d129      	bne.n	8008026 <HAL_RCC_OscConfig+0x1be>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8007fd2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007fd6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007fda:	681b      	ldr	r3, [r3, #0]
 8007fdc:	f003 0302 	and.w	r3, r3, #2
 8007fe0:	2b00      	cmp	r3, #0
 8007fe2:	d005      	beq.n	8007ff0 <HAL_RCC_OscConfig+0x188>
 8007fe4:	687b      	ldr	r3, [r7, #4]
 8007fe6:	68db      	ldr	r3, [r3, #12]
 8007fe8:	2b01      	cmp	r3, #1
 8007fea:	d001      	beq.n	8007ff0 <HAL_RCC_OscConfig+0x188>
      {
        return HAL_ERROR;
 8007fec:	2301      	movs	r3, #1
 8007fee:	e1ed      	b.n	80083cc <HAL_RCC_OscConfig+0x564>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8007ff0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007ff4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007ff8:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8007ffc:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008000:	6812      	ldr	r2, [r2, #0]
 8008002:	f022 01f8 	bic.w	r1, r2, #248	; 0xf8
 8008006:	687a      	ldr	r2, [r7, #4]
 8008008:	6910      	ldr	r0, [r2, #16]
 800800a:	22f8      	movs	r2, #248	; 0xf8
 800800c:	633a      	str	r2, [r7, #48]	; 0x30
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800800e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8008010:	fa92 f2a2 	rbit	r2, r2
 8008014:	62fa      	str	r2, [r7, #44]	; 0x2c
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8008016:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8008018:	fab2 f282 	clz	r2, r2
 800801c:	fa00 f202 	lsl.w	r2, r0, r2
 8008020:	430a      	orrs	r2, r1
 8008022:	601a      	str	r2, [r3, #0]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8008024:	e054      	b.n	80080d0 <HAL_RCC_OscConfig+0x268>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8008026:	687b      	ldr	r3, [r7, #4]
 8008028:	68db      	ldr	r3, [r3, #12]
 800802a:	2b00      	cmp	r3, #0
 800802c:	d035      	beq.n	800809a <HAL_RCC_OscConfig+0x232>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800802e:	2300      	movs	r3, #0
 8008030:	f2c4 2347 	movt	r3, #16967	; 0x4247
 8008034:	2201      	movs	r2, #1
 8008036:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8008038:	f7f9 fcc6 	bl	80019c8 <HAL_GetTick>
 800803c:	6378      	str	r0, [r7, #52]	; 0x34

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800803e:	e008      	b.n	8008052 <HAL_RCC_OscConfig+0x1ea>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8008040:	f7f9 fcc2 	bl	80019c8 <HAL_GetTick>
 8008044:	4602      	mov	r2, r0
 8008046:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008048:	1ad3      	subs	r3, r2, r3
 800804a:	2b64      	cmp	r3, #100	; 0x64
 800804c:	d901      	bls.n	8008052 <HAL_RCC_OscConfig+0x1ea>
          {
            return HAL_TIMEOUT;
 800804e:	2303      	movs	r3, #3
 8008050:	e1bc      	b.n	80083cc <HAL_RCC_OscConfig+0x564>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8008052:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008056:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800805a:	681b      	ldr	r3, [r3, #0]
 800805c:	f003 0302 	and.w	r3, r3, #2
 8008060:	2b00      	cmp	r3, #0
 8008062:	d0ed      	beq.n	8008040 <HAL_RCC_OscConfig+0x1d8>
            return HAL_TIMEOUT;
          }       
        } 
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8008064:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008068:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800806c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008070:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008074:	6812      	ldr	r2, [r2, #0]
 8008076:	f022 01f8 	bic.w	r1, r2, #248	; 0xf8
 800807a:	687a      	ldr	r2, [r7, #4]
 800807c:	6910      	ldr	r0, [r2, #16]
 800807e:	22f8      	movs	r2, #248	; 0xf8
 8008080:	62ba      	str	r2, [r7, #40]	; 0x28
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008082:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8008084:	fa92 f2a2 	rbit	r2, r2
 8008088:	627a      	str	r2, [r7, #36]	; 0x24
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800808a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800808c:	fab2 f282 	clz	r2, r2
 8008090:	fa00 f202 	lsl.w	r2, r0, r2
 8008094:	430a      	orrs	r2, r1
 8008096:	601a      	str	r2, [r3, #0]
 8008098:	e01a      	b.n	80080d0 <HAL_RCC_OscConfig+0x268>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800809a:	2300      	movs	r3, #0
 800809c:	f2c4 2347 	movt	r3, #16967	; 0x4247
 80080a0:	2200      	movs	r2, #0
 80080a2:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80080a4:	f7f9 fc90 	bl	80019c8 <HAL_GetTick>
 80080a8:	6378      	str	r0, [r7, #52]	; 0x34
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80080aa:	e008      	b.n	80080be <HAL_RCC_OscConfig+0x256>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80080ac:	f7f9 fc8c 	bl	80019c8 <HAL_GetTick>
 80080b0:	4602      	mov	r2, r0
 80080b2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80080b4:	1ad3      	subs	r3, r2, r3
 80080b6:	2b64      	cmp	r3, #100	; 0x64
 80080b8:	d901      	bls.n	80080be <HAL_RCC_OscConfig+0x256>
          {
            return HAL_TIMEOUT;
 80080ba:	2303      	movs	r3, #3
 80080bc:	e186      	b.n	80083cc <HAL_RCC_OscConfig+0x564>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80080be:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80080c2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80080c6:	681b      	ldr	r3, [r3, #0]
 80080c8:	f003 0302 	and.w	r3, r3, #2
 80080cc:	2b00      	cmp	r3, #0
 80080ce:	d1ed      	bne.n	80080ac <HAL_RCC_OscConfig+0x244>
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80080d0:	687b      	ldr	r3, [r7, #4]
 80080d2:	681b      	ldr	r3, [r3, #0]
 80080d4:	f003 0308 	and.w	r3, r3, #8
 80080d8:	2b00      	cmp	r3, #0
 80080da:	d03c      	beq.n	8008156 <HAL_RCC_OscConfig+0x2ee>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 80080dc:	687b      	ldr	r3, [r7, #4]
 80080de:	695b      	ldr	r3, [r3, #20]
 80080e0:	2b00      	cmp	r3, #0
 80080e2:	d01c      	beq.n	800811e <HAL_RCC_OscConfig+0x2b6>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 80080e4:	f44f 6368 	mov.w	r3, #3712	; 0xe80
 80080e8:	f2c4 2347 	movt	r3, #16967	; 0x4247
 80080ec:	2201      	movs	r2, #1
 80080ee:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80080f0:	f7f9 fc6a 	bl	80019c8 <HAL_GetTick>
 80080f4:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80080f6:	e008      	b.n	800810a <HAL_RCC_OscConfig+0x2a2>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80080f8:	f7f9 fc66 	bl	80019c8 <HAL_GetTick>
 80080fc:	4602      	mov	r2, r0
 80080fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008100:	1ad3      	subs	r3, r2, r3
 8008102:	2b64      	cmp	r3, #100	; 0x64
 8008104:	d901      	bls.n	800810a <HAL_RCC_OscConfig+0x2a2>
        {
          return HAL_TIMEOUT;
 8008106:	2303      	movs	r3, #3
 8008108:	e160      	b.n	80083cc <HAL_RCC_OscConfig+0x564>
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800810a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800810e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008112:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8008114:	f003 0302 	and.w	r3, r3, #2
 8008118:	2b00      	cmp	r3, #0
 800811a:	d0ed      	beq.n	80080f8 <HAL_RCC_OscConfig+0x290>
 800811c:	e01b      	b.n	8008156 <HAL_RCC_OscConfig+0x2ee>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 800811e:	f44f 6368 	mov.w	r3, #3712	; 0xe80
 8008122:	f2c4 2347 	movt	r3, #16967	; 0x4247
 8008126:	2200      	movs	r2, #0
 8008128:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800812a:	f7f9 fc4d 	bl	80019c8 <HAL_GetTick>
 800812e:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8008130:	e008      	b.n	8008144 <HAL_RCC_OscConfig+0x2dc>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8008132:	f7f9 fc49 	bl	80019c8 <HAL_GetTick>
 8008136:	4602      	mov	r2, r0
 8008138:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800813a:	1ad3      	subs	r3, r2, r3
 800813c:	2b64      	cmp	r3, #100	; 0x64
 800813e:	d901      	bls.n	8008144 <HAL_RCC_OscConfig+0x2dc>
        {
          return HAL_TIMEOUT;
 8008140:	2303      	movs	r3, #3
 8008142:	e143      	b.n	80083cc <HAL_RCC_OscConfig+0x564>
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8008144:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008148:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800814c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800814e:	f003 0302 	and.w	r3, r3, #2
 8008152:	2b00      	cmp	r3, #0
 8008154:	d1ed      	bne.n	8008132 <HAL_RCC_OscConfig+0x2ca>
        }       
      } 
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8008156:	687b      	ldr	r3, [r7, #4]
 8008158:	681b      	ldr	r3, [r3, #0]
 800815a:	f003 0304 	and.w	r3, r3, #4
 800815e:	2b00      	cmp	r3, #0
 8008160:	f000 8092 	beq.w	8008288 <HAL_RCC_OscConfig+0x420>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8008164:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008168:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800816c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008170:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008174:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8008176:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800817a:	641a      	str	r2, [r3, #64]	; 0x40
 800817c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008180:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008184:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008186:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800818a:	60bb      	str	r3, [r7, #8]
 800818c:	68bb      	ldr	r3, [r7, #8]
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 800818e:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8008192:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8008196:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 800819a:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800819e:	6812      	ldr	r2, [r2, #0]
 80081a0:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80081a4:	601a      	str	r2, [r3, #0]
    
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 80081a6:	f7f9 fc0f 	bl	80019c8 <HAL_GetTick>
 80081aa:	6378      	str	r0, [r7, #52]	; 0x34
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 80081ac:	e008      	b.n	80081c0 <HAL_RCC_OscConfig+0x358>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 80081ae:	f7f9 fc0b 	bl	80019c8 <HAL_GetTick>
 80081b2:	4602      	mov	r2, r0
 80081b4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80081b6:	1ad3      	subs	r3, r2, r3
 80081b8:	2b64      	cmp	r3, #100	; 0x64
 80081ba:	d901      	bls.n	80081c0 <HAL_RCC_OscConfig+0x358>
      {
        return HAL_TIMEOUT;
 80081bc:	2303      	movs	r3, #3
 80081be:	e105      	b.n	80083cc <HAL_RCC_OscConfig+0x564>
    PWR->CR |= PWR_CR_DBP;
    
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 80081c0:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 80081c4:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80081c8:	681b      	ldr	r3, [r3, #0]
 80081ca:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80081ce:	2b00      	cmp	r3, #0
 80081d0:	d0ed      	beq.n	80081ae <HAL_RCC_OscConfig+0x346>
        return HAL_TIMEOUT;
      }      
    }
    
    /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 80081d2:	f643 0370 	movw	r3, #14448	; 0x3870
 80081d6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80081da:	2200      	movs	r2, #0
 80081dc:	701a      	strb	r2, [r3, #0]
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80081de:	f7f9 fbf3 	bl	80019c8 <HAL_GetTick>
 80081e2:	6378      	str	r0, [r7, #52]	; 0x34
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80081e4:	e00a      	b.n	80081fc <HAL_RCC_OscConfig+0x394>
    {
      if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80081e6:	f7f9 fbef 	bl	80019c8 <HAL_GetTick>
 80081ea:	4602      	mov	r2, r0
 80081ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80081ee:	1ad2      	subs	r2, r2, r3
 80081f0:	f241 3388 	movw	r3, #5000	; 0x1388
 80081f4:	429a      	cmp	r2, r3
 80081f6:	d901      	bls.n	80081fc <HAL_RCC_OscConfig+0x394>
      {
        return HAL_TIMEOUT;
 80081f8:	2303      	movs	r3, #3
 80081fa:	e0e7      	b.n	80083cc <HAL_RCC_OscConfig+0x564>
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80081fc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008200:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008204:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008206:	f003 0302 	and.w	r3, r3, #2
 800820a:	2b00      	cmp	r3, #0
 800820c:	d1eb      	bne.n	80081e6 <HAL_RCC_OscConfig+0x37e>
        return HAL_TIMEOUT;
      }    
    } 
    
    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800820e:	f643 0370 	movw	r3, #14448	; 0x3870
 8008212:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008216:	687a      	ldr	r2, [r7, #4]
 8008218:	6892      	ldr	r2, [r2, #8]
 800821a:	b2d2      	uxtb	r2, r2
 800821c:	701a      	strb	r2, [r3, #0]
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 800821e:	687b      	ldr	r3, [r7, #4]
 8008220:	689b      	ldr	r3, [r3, #8]
 8008222:	2b00      	cmp	r3, #0
 8008224:	d018      	beq.n	8008258 <HAL_RCC_OscConfig+0x3f0>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8008226:	f7f9 fbcf 	bl	80019c8 <HAL_GetTick>
 800822a:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800822c:	e00a      	b.n	8008244 <HAL_RCC_OscConfig+0x3dc>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800822e:	f7f9 fbcb 	bl	80019c8 <HAL_GetTick>
 8008232:	4602      	mov	r2, r0
 8008234:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008236:	1ad2      	subs	r2, r2, r3
 8008238:	f241 3388 	movw	r3, #5000	; 0x1388
 800823c:	429a      	cmp	r2, r3
 800823e:	d901      	bls.n	8008244 <HAL_RCC_OscConfig+0x3dc>
        {
          return HAL_TIMEOUT;
 8008240:	2303      	movs	r3, #3
 8008242:	e0c3      	b.n	80083cc <HAL_RCC_OscConfig+0x564>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8008244:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008248:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800824c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800824e:	f003 0302 	and.w	r3, r3, #2
 8008252:	2b00      	cmp	r3, #0
 8008254:	d0eb      	beq.n	800822e <HAL_RCC_OscConfig+0x3c6>
 8008256:	e017      	b.n	8008288 <HAL_RCC_OscConfig+0x420>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8008258:	f7f9 fbb6 	bl	80019c8 <HAL_GetTick>
 800825c:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800825e:	e00a      	b.n	8008276 <HAL_RCC_OscConfig+0x40e>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8008260:	f7f9 fbb2 	bl	80019c8 <HAL_GetTick>
 8008264:	4602      	mov	r2, r0
 8008266:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008268:	1ad2      	subs	r2, r2, r3
 800826a:	f241 3388 	movw	r3, #5000	; 0x1388
 800826e:	429a      	cmp	r2, r3
 8008270:	d901      	bls.n	8008276 <HAL_RCC_OscConfig+0x40e>
        {
          return HAL_TIMEOUT;
 8008272:	2303      	movs	r3, #3
 8008274:	e0aa      	b.n	80083cc <HAL_RCC_OscConfig+0x564>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8008276:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800827a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800827e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008280:	f003 0302 	and.w	r3, r3, #2
 8008284:	2b00      	cmp	r3, #0
 8008286:	d1eb      	bne.n	8008260 <HAL_RCC_OscConfig+0x3f8>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8008288:	687b      	ldr	r3, [r7, #4]
 800828a:	699b      	ldr	r3, [r3, #24]
 800828c:	2b00      	cmp	r3, #0
 800828e:	f000 809c 	beq.w	80083ca <HAL_RCC_OscConfig+0x562>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8008292:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008296:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800829a:	689b      	ldr	r3, [r3, #8]
 800829c:	f003 030c 	and.w	r3, r3, #12
 80082a0:	2b08      	cmp	r3, #8
 80082a2:	f000 8090 	beq.w	80083c6 <HAL_RCC_OscConfig+0x55e>
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80082a6:	687b      	ldr	r3, [r7, #4]
 80082a8:	699b      	ldr	r3, [r3, #24]
 80082aa:	2b02      	cmp	r3, #2
 80082ac:	d16f      	bne.n	800838e <HAL_RCC_OscConfig+0x526>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80082ae:	2360      	movs	r3, #96	; 0x60
 80082b0:	f2c4 2347 	movt	r3, #16967	; 0x4247
 80082b4:	2200      	movs	r2, #0
 80082b6:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80082b8:	f7f9 fb86 	bl	80019c8 <HAL_GetTick>
 80082bc:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80082be:	e008      	b.n	80082d2 <HAL_RCC_OscConfig+0x46a>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80082c0:	f7f9 fb82 	bl	80019c8 <HAL_GetTick>
 80082c4:	4602      	mov	r2, r0
 80082c6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80082c8:	1ad3      	subs	r3, r2, r3
 80082ca:	2b64      	cmp	r3, #100	; 0x64
 80082cc:	d901      	bls.n	80082d2 <HAL_RCC_OscConfig+0x46a>
          {
            return HAL_TIMEOUT;
 80082ce:	2303      	movs	r3, #3
 80082d0:	e07c      	b.n	80083cc <HAL_RCC_OscConfig+0x564>
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80082d2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80082d6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80082da:	681b      	ldr	r3, [r3, #0]
 80082dc:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80082e0:	2b00      	cmp	r3, #0
 80082e2:	d1ed      	bne.n	80082c0 <HAL_RCC_OscConfig+0x458>
            return HAL_TIMEOUT;
          }
        }        

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 80082e4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80082e8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80082ec:	687a      	ldr	r2, [r7, #4]
 80082ee:	69d1      	ldr	r1, [r2, #28]
 80082f0:	687a      	ldr	r2, [r7, #4]
 80082f2:	6a12      	ldr	r2, [r2, #32]
 80082f4:	4311      	orrs	r1, r2
 80082f6:	687a      	ldr	r2, [r7, #4]
 80082f8:	6a50      	ldr	r0, [r2, #36]	; 0x24
 80082fa:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 80082fe:	623a      	str	r2, [r7, #32]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008300:	6a3a      	ldr	r2, [r7, #32]
 8008302:	fa92 f2a2 	rbit	r2, r2
 8008306:	61fa      	str	r2, [r7, #28]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8008308:	69fa      	ldr	r2, [r7, #28]
 800830a:	fab2 f282 	clz	r2, r2
 800830e:	fa00 f202 	lsl.w	r2, r0, r2
 8008312:	4311      	orrs	r1, r2
 8008314:	687a      	ldr	r2, [r7, #4]
 8008316:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8008318:	0852      	lsrs	r2, r2, #1
 800831a:	1e50      	subs	r0, r2, #1
 800831c:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 8008320:	61ba      	str	r2, [r7, #24]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008322:	69ba      	ldr	r2, [r7, #24]
 8008324:	fa92 f2a2 	rbit	r2, r2
 8008328:	617a      	str	r2, [r7, #20]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800832a:	697a      	ldr	r2, [r7, #20]
 800832c:	fab2 f282 	clz	r2, r2
 8008330:	fa00 f202 	lsl.w	r2, r0, r2
 8008334:	4311      	orrs	r1, r2
 8008336:	687a      	ldr	r2, [r7, #4]
 8008338:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 800833a:	f04f 6270 	mov.w	r2, #251658240	; 0xf000000
 800833e:	613a      	str	r2, [r7, #16]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008340:	693a      	ldr	r2, [r7, #16]
 8008342:	fa92 f2a2 	rbit	r2, r2
 8008346:	60fa      	str	r2, [r7, #12]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8008348:	68fa      	ldr	r2, [r7, #12]
 800834a:	fab2 f282 	clz	r2, r2
 800834e:	fa00 f202 	lsl.w	r2, r0, r2
 8008352:	430a      	orrs	r2, r1
 8008354:	605a      	str	r2, [r3, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << POSITION_VAL(RCC_PLLCFGR_PLLN))             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1) -1) << POSITION_VAL(RCC_PLLCFGR_PLLP)) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << POSITION_VAL(RCC_PLLCFGR_PLLQ))));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8008356:	2360      	movs	r3, #96	; 0x60
 8008358:	f2c4 2347 	movt	r3, #16967	; 0x4247
 800835c:	2201      	movs	r2, #1
 800835e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8008360:	f7f9 fb32 	bl	80019c8 <HAL_GetTick>
 8008364:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8008366:	e008      	b.n	800837a <HAL_RCC_OscConfig+0x512>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8008368:	f7f9 fb2e 	bl	80019c8 <HAL_GetTick>
 800836c:	4602      	mov	r2, r0
 800836e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008370:	1ad3      	subs	r3, r2, r3
 8008372:	2b64      	cmp	r3, #100	; 0x64
 8008374:	d901      	bls.n	800837a <HAL_RCC_OscConfig+0x512>
          {
            return HAL_TIMEOUT;
 8008376:	2303      	movs	r3, #3
 8008378:	e028      	b.n	80083cc <HAL_RCC_OscConfig+0x564>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800837a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800837e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008382:	681b      	ldr	r3, [r3, #0]
 8008384:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8008388:	2b00      	cmp	r3, #0
 800838a:	d0ed      	beq.n	8008368 <HAL_RCC_OscConfig+0x500>
 800838c:	e01d      	b.n	80083ca <HAL_RCC_OscConfig+0x562>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800838e:	2360      	movs	r3, #96	; 0x60
 8008390:	f2c4 2347 	movt	r3, #16967	; 0x4247
 8008394:	2200      	movs	r2, #0
 8008396:	601a      	str	r2, [r3, #0]
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8008398:	f7f9 fb16 	bl	80019c8 <HAL_GetTick>
 800839c:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800839e:	e008      	b.n	80083b2 <HAL_RCC_OscConfig+0x54a>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80083a0:	f7f9 fb12 	bl	80019c8 <HAL_GetTick>
 80083a4:	4602      	mov	r2, r0
 80083a6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80083a8:	1ad3      	subs	r3, r2, r3
 80083aa:	2b64      	cmp	r3, #100	; 0x64
 80083ac:	d901      	bls.n	80083b2 <HAL_RCC_OscConfig+0x54a>
          {
            return HAL_TIMEOUT;
 80083ae:	2303      	movs	r3, #3
 80083b0:	e00c      	b.n	80083cc <HAL_RCC_OscConfig+0x564>
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80083b2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80083b6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80083ba:	681b      	ldr	r3, [r3, #0]
 80083bc:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80083c0:	2b00      	cmp	r3, #0
 80083c2:	d1ed      	bne.n	80083a0 <HAL_RCC_OscConfig+0x538>
 80083c4:	e001      	b.n	80083ca <HAL_RCC_OscConfig+0x562>
        }
      }
    }
    else
    {
      return HAL_ERROR;
 80083c6:	2301      	movs	r3, #1
 80083c8:	e000      	b.n	80083cc <HAL_RCC_OscConfig+0x564>
    }
  }
  return HAL_OK;
 80083ca:	2300      	movs	r3, #0
}
 80083cc:	4618      	mov	r0, r3
 80083ce:	3738      	adds	r7, #56	; 0x38
 80083d0:	46bd      	mov	sp, r7
 80083d2:	bd80      	pop	{r7, pc}

080083d4 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 80083d4:	b580      	push	{r7, lr}
 80083d6:	b084      	sub	sp, #16
 80083d8:	af00      	add	r7, sp, #0
 80083da:	6078      	str	r0, [r7, #4]
 80083dc:	6039      	str	r1, [r7, #0]
  uint32_t tickstart = 0;   
 80083de:	2300      	movs	r3, #0
 80083e0:	60fb      	str	r3, [r7, #12]
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) and the supply voltage of the device. */
  
  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 80083e2:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 80083e6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80083ea:	681b      	ldr	r3, [r3, #0]
 80083ec:	f003 020f 	and.w	r2, r3, #15
 80083f0:	683b      	ldr	r3, [r7, #0]
 80083f2:	429a      	cmp	r2, r3
 80083f4:	f080 80cf 	bcs.w	8008596 <HAL_RCC_ClockConfig+0x1c2>
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80083f8:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 80083fc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008400:	683a      	ldr	r2, [r7, #0]
 8008402:	b2d2      	uxtb	r2, r2
 8008404:	701a      	strb	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8008406:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 800840a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800840e:	681b      	ldr	r3, [r3, #0]
 8008410:	f003 020f 	and.w	r2, r3, #15
 8008414:	683b      	ldr	r3, [r7, #0]
 8008416:	429a      	cmp	r2, r3
 8008418:	d001      	beq.n	800841e <HAL_RCC_ClockConfig+0x4a>
    {
      return HAL_ERROR;
 800841a:	2301      	movs	r3, #1
 800841c:	e1b8      	b.n	8008790 <HAL_RCC_ClockConfig+0x3bc>
    }

    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800841e:	687b      	ldr	r3, [r7, #4]
 8008420:	681b      	ldr	r3, [r3, #0]
 8008422:	f003 0302 	and.w	r3, r3, #2
 8008426:	2b00      	cmp	r3, #0
 8008428:	d00e      	beq.n	8008448 <HAL_RCC_ClockConfig+0x74>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800842a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800842e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008432:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008436:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800843a:	6892      	ldr	r2, [r2, #8]
 800843c:	f022 01f0 	bic.w	r1, r2, #240	; 0xf0
 8008440:	687a      	ldr	r2, [r7, #4]
 8008442:	6892      	ldr	r2, [r2, #8]
 8008444:	430a      	orrs	r2, r1
 8008446:	609a      	str	r2, [r3, #8]
    }

    /*------------------------- SYSCLK Configuration ---------------------------*/ 
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8008448:	687b      	ldr	r3, [r7, #4]
 800844a:	681b      	ldr	r3, [r3, #0]
 800844c:	f003 0301 	and.w	r3, r3, #1
 8008450:	2b00      	cmp	r3, #0
 8008452:	f000 816e 	beq.w	8008732 <HAL_RCC_ClockConfig+0x35e>
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8008456:	687b      	ldr	r3, [r7, #4]
 8008458:	685b      	ldr	r3, [r3, #4]
 800845a:	2b01      	cmp	r3, #1
 800845c:	d10a      	bne.n	8008474 <HAL_RCC_ClockConfig+0xa0>
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800845e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008462:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008466:	681b      	ldr	r3, [r3, #0]
 8008468:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800846c:	2b00      	cmp	r3, #0
 800846e:	d120      	bne.n	80084b2 <HAL_RCC_ClockConfig+0xde>
        {
          return HAL_ERROR;
 8008470:	2301      	movs	r3, #1
 8008472:	e18d      	b.n	8008790 <HAL_RCC_ClockConfig+0x3bc>
        }
      }
      /* PLL is selected as System Clock Source */
      else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 8008474:	687b      	ldr	r3, [r7, #4]
 8008476:	685b      	ldr	r3, [r3, #4]
 8008478:	2b02      	cmp	r3, #2
 800847a:	d003      	beq.n	8008484 <HAL_RCC_ClockConfig+0xb0>
              (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
 800847c:	687b      	ldr	r3, [r7, #4]
 800847e:	685b      	ldr	r3, [r3, #4]
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 8008480:	2b03      	cmp	r3, #3
 8008482:	d10b      	bne.n	800849c <HAL_RCC_ClockConfig+0xc8>
              (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
      {
        /* Check the PLL ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8008484:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008488:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800848c:	681b      	ldr	r3, [r3, #0]
 800848e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8008492:	2b00      	cmp	r3, #0
 8008494:	d101      	bne.n	800849a <HAL_RCC_ClockConfig+0xc6>
        {
          return HAL_ERROR;
 8008496:	2301      	movs	r3, #1
 8008498:	e17a      	b.n	8008790 <HAL_RCC_ClockConfig+0x3bc>
      /* PLL is selected as System Clock Source */
      else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
              (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
      {
        /* Check the PLL ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800849a:	e00a      	b.n	80084b2 <HAL_RCC_ClockConfig+0xde>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800849c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80084a0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80084a4:	681b      	ldr	r3, [r3, #0]
 80084a6:	f003 0302 	and.w	r3, r3, #2
 80084aa:	2b00      	cmp	r3, #0
 80084ac:	d101      	bne.n	80084b2 <HAL_RCC_ClockConfig+0xde>
        {
          return HAL_ERROR;
 80084ae:	2301      	movs	r3, #1
 80084b0:	e16e      	b.n	8008790 <HAL_RCC_ClockConfig+0x3bc>
        }
      }

      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80084b2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80084b6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80084ba:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80084be:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80084c2:	6892      	ldr	r2, [r2, #8]
 80084c4:	f022 0103 	bic.w	r1, r2, #3
 80084c8:	687a      	ldr	r2, [r7, #4]
 80084ca:	6852      	ldr	r2, [r2, #4]
 80084cc:	430a      	orrs	r2, r1
 80084ce:	609a      	str	r2, [r3, #8]
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80084d0:	f7f9 fa7a 	bl	80019c8 <HAL_GetTick>
 80084d4:	60f8      	str	r0, [r7, #12]
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80084d6:	687b      	ldr	r3, [r7, #4]
 80084d8:	685b      	ldr	r3, [r3, #4]
 80084da:	2b01      	cmp	r3, #1
 80084dc:	d115      	bne.n	800850a <HAL_RCC_ClockConfig+0x136>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 80084de:	e00a      	b.n	80084f6 <HAL_RCC_ClockConfig+0x122>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80084e0:	f7f9 fa72 	bl	80019c8 <HAL_GetTick>
 80084e4:	4602      	mov	r2, r0
 80084e6:	68fb      	ldr	r3, [r7, #12]
 80084e8:	1ad2      	subs	r2, r2, r3
 80084ea:	f241 3388 	movw	r3, #5000	; 0x1388
 80084ee:	429a      	cmp	r2, r3
 80084f0:	d901      	bls.n	80084f6 <HAL_RCC_ClockConfig+0x122>
          {
            return HAL_TIMEOUT;
 80084f2:	2303      	movs	r3, #3
 80084f4:	e14c      	b.n	8008790 <HAL_RCC_ClockConfig+0x3bc>
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 80084f6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80084fa:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80084fe:	689b      	ldr	r3, [r3, #8]
 8008500:	f003 030c 	and.w	r3, r3, #12
 8008504:	2b04      	cmp	r3, #4
 8008506:	d1eb      	bne.n	80084e0 <HAL_RCC_ClockConfig+0x10c>
 8008508:	e113      	b.n	8008732 <HAL_RCC_ClockConfig+0x35e>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800850a:	687b      	ldr	r3, [r7, #4]
 800850c:	685b      	ldr	r3, [r3, #4]
 800850e:	2b02      	cmp	r3, #2
 8008510:	d115      	bne.n	800853e <HAL_RCC_ClockConfig+0x16a>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8008512:	e00a      	b.n	800852a <HAL_RCC_ClockConfig+0x156>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8008514:	f7f9 fa58 	bl	80019c8 <HAL_GetTick>
 8008518:	4602      	mov	r2, r0
 800851a:	68fb      	ldr	r3, [r7, #12]
 800851c:	1ad2      	subs	r2, r2, r3
 800851e:	f241 3388 	movw	r3, #5000	; 0x1388
 8008522:	429a      	cmp	r2, r3
 8008524:	d901      	bls.n	800852a <HAL_RCC_ClockConfig+0x156>
          {
            return HAL_TIMEOUT;
 8008526:	2303      	movs	r3, #3
 8008528:	e132      	b.n	8008790 <HAL_RCC_ClockConfig+0x3bc>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800852a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800852e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008532:	689b      	ldr	r3, [r3, #8]
 8008534:	f003 030c 	and.w	r3, r3, #12
 8008538:	2b08      	cmp	r3, #8
 800853a:	d1eb      	bne.n	8008514 <HAL_RCC_ClockConfig+0x140>
 800853c:	e0f9      	b.n	8008732 <HAL_RCC_ClockConfig+0x35e>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK)
 800853e:	687b      	ldr	r3, [r7, #4]
 8008540:	685b      	ldr	r3, [r3, #4]
 8008542:	2b03      	cmp	r3, #3
 8008544:	d111      	bne.n	800856a <HAL_RCC_ClockConfig+0x196>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
 8008546:	e001      	b.n	800854c <HAL_RCC_ClockConfig+0x178>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 8008548:	2303      	movs	r3, #3
 800854a:	e121      	b.n	8008790 <HAL_RCC_ClockConfig+0x3bc>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
 800854c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008550:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008554:	689b      	ldr	r3, [r3, #8]
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8008556:	f7f9 fa37 	bl	80019c8 <HAL_GetTick>
 800855a:	4602      	mov	r2, r0
 800855c:	68fb      	ldr	r3, [r7, #12]
 800855e:	1ad2      	subs	r2, r2, r3
 8008560:	f241 3388 	movw	r3, #5000	; 0x1388
 8008564:	429a      	cmp	r2, r3
 8008566:	d9f1      	bls.n	800854c <HAL_RCC_ClockConfig+0x178>
 8008568:	e7ee      	b.n	8008548 <HAL_RCC_ClockConfig+0x174>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800856a:	e00a      	b.n	8008582 <HAL_RCC_ClockConfig+0x1ae>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800856c:	f7f9 fa2c 	bl	80019c8 <HAL_GetTick>
 8008570:	4602      	mov	r2, r0
 8008572:	68fb      	ldr	r3, [r7, #12]
 8008574:	1ad2      	subs	r2, r2, r3
 8008576:	f241 3388 	movw	r3, #5000	; 0x1388
 800857a:	429a      	cmp	r2, r3
 800857c:	d901      	bls.n	8008582 <HAL_RCC_ClockConfig+0x1ae>
          {
            return HAL_TIMEOUT;
 800857e:	2303      	movs	r3, #3
 8008580:	e106      	b.n	8008790 <HAL_RCC_ClockConfig+0x3bc>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8008582:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008586:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800858a:	689b      	ldr	r3, [r3, #8]
 800858c:	f003 030c 	and.w	r3, r3, #12
 8008590:	2b00      	cmp	r3, #0
 8008592:	d1eb      	bne.n	800856c <HAL_RCC_ClockConfig+0x198>
 8008594:	e0cd      	b.n	8008732 <HAL_RCC_ClockConfig+0x35e>
  }
  /* Decreasing the CPU frequency */
  else
  {
    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8008596:	687b      	ldr	r3, [r7, #4]
 8008598:	681b      	ldr	r3, [r3, #0]
 800859a:	f003 0302 	and.w	r3, r3, #2
 800859e:	2b00      	cmp	r3, #0
 80085a0:	d00e      	beq.n	80085c0 <HAL_RCC_ClockConfig+0x1ec>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80085a2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80085a6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80085aa:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80085ae:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80085b2:	6892      	ldr	r2, [r2, #8]
 80085b4:	f022 01f0 	bic.w	r1, r2, #240	; 0xf0
 80085b8:	687a      	ldr	r2, [r7, #4]
 80085ba:	6892      	ldr	r2, [r2, #8]
 80085bc:	430a      	orrs	r2, r1
 80085be:	609a      	str	r2, [r3, #8]
    }

    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80085c0:	687b      	ldr	r3, [r7, #4]
 80085c2:	681b      	ldr	r3, [r3, #0]
 80085c4:	f003 0301 	and.w	r3, r3, #1
 80085c8:	2b00      	cmp	r3, #0
 80085ca:	f000 809f 	beq.w	800870c <HAL_RCC_ClockConfig+0x338>
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80085ce:	687b      	ldr	r3, [r7, #4]
 80085d0:	685b      	ldr	r3, [r3, #4]
 80085d2:	2b01      	cmp	r3, #1
 80085d4:	d10a      	bne.n	80085ec <HAL_RCC_ClockConfig+0x218>
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80085d6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80085da:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80085de:	681b      	ldr	r3, [r3, #0]
 80085e0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80085e4:	2b00      	cmp	r3, #0
 80085e6:	d120      	bne.n	800862a <HAL_RCC_ClockConfig+0x256>
        {
          return HAL_ERROR;
 80085e8:	2301      	movs	r3, #1
 80085ea:	e0d1      	b.n	8008790 <HAL_RCC_ClockConfig+0x3bc>
        }
      }
      /* PLL is selected as System Clock Source */
      else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK) || 
 80085ec:	687b      	ldr	r3, [r7, #4]
 80085ee:	685b      	ldr	r3, [r3, #4]
 80085f0:	2b02      	cmp	r3, #2
 80085f2:	d003      	beq.n	80085fc <HAL_RCC_ClockConfig+0x228>
              (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
 80085f4:	687b      	ldr	r3, [r7, #4]
 80085f6:	685b      	ldr	r3, [r3, #4]
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK) || 
 80085f8:	2b03      	cmp	r3, #3
 80085fa:	d10b      	bne.n	8008614 <HAL_RCC_ClockConfig+0x240>
              (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
      {
        /* Check the PLL ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80085fc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008600:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008604:	681b      	ldr	r3, [r3, #0]
 8008606:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800860a:	2b00      	cmp	r3, #0
 800860c:	d101      	bne.n	8008612 <HAL_RCC_ClockConfig+0x23e>
        {
          return HAL_ERROR;
 800860e:	2301      	movs	r3, #1
 8008610:	e0be      	b.n	8008790 <HAL_RCC_ClockConfig+0x3bc>
      /* PLL is selected as System Clock Source */
      else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK) || 
              (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
      {
        /* Check the PLL ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8008612:	e00a      	b.n	800862a <HAL_RCC_ClockConfig+0x256>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8008614:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008618:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800861c:	681b      	ldr	r3, [r3, #0]
 800861e:	f003 0302 	and.w	r3, r3, #2
 8008622:	2b00      	cmp	r3, #0
 8008624:	d101      	bne.n	800862a <HAL_RCC_ClockConfig+0x256>
        {
          return HAL_ERROR;
 8008626:	2301      	movs	r3, #1
 8008628:	e0b2      	b.n	8008790 <HAL_RCC_ClockConfig+0x3bc>
        }
      }
      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800862a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800862e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008632:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008636:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800863a:	6892      	ldr	r2, [r2, #8]
 800863c:	f022 0103 	bic.w	r1, r2, #3
 8008640:	687a      	ldr	r2, [r7, #4]
 8008642:	6852      	ldr	r2, [r2, #4]
 8008644:	430a      	orrs	r2, r1
 8008646:	609a      	str	r2, [r3, #8]
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8008648:	f7f9 f9be 	bl	80019c8 <HAL_GetTick>
 800864c:	60f8      	str	r0, [r7, #12]
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800864e:	687b      	ldr	r3, [r7, #4]
 8008650:	685b      	ldr	r3, [r3, #4]
 8008652:	2b01      	cmp	r3, #1
 8008654:	d115      	bne.n	8008682 <HAL_RCC_ClockConfig+0x2ae>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8008656:	e00a      	b.n	800866e <HAL_RCC_ClockConfig+0x29a>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8008658:	f7f9 f9b6 	bl	80019c8 <HAL_GetTick>
 800865c:	4602      	mov	r2, r0
 800865e:	68fb      	ldr	r3, [r7, #12]
 8008660:	1ad2      	subs	r2, r2, r3
 8008662:	f241 3388 	movw	r3, #5000	; 0x1388
 8008666:	429a      	cmp	r2, r3
 8008668:	d901      	bls.n	800866e <HAL_RCC_ClockConfig+0x29a>
          {
            return HAL_TIMEOUT;
 800866a:	2303      	movs	r3, #3
 800866c:	e090      	b.n	8008790 <HAL_RCC_ClockConfig+0x3bc>
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800866e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008672:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008676:	689b      	ldr	r3, [r3, #8]
 8008678:	f003 030c 	and.w	r3, r3, #12
 800867c:	2b04      	cmp	r3, #4
 800867e:	d1eb      	bne.n	8008658 <HAL_RCC_ClockConfig+0x284>
 8008680:	e044      	b.n	800870c <HAL_RCC_ClockConfig+0x338>
          {
            return HAL_TIMEOUT;
          } 
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8008682:	687b      	ldr	r3, [r7, #4]
 8008684:	685b      	ldr	r3, [r3, #4]
 8008686:	2b02      	cmp	r3, #2
 8008688:	d115      	bne.n	80086b6 <HAL_RCC_ClockConfig+0x2e2>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800868a:	e00a      	b.n	80086a2 <HAL_RCC_ClockConfig+0x2ce>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800868c:	f7f9 f99c 	bl	80019c8 <HAL_GetTick>
 8008690:	4602      	mov	r2, r0
 8008692:	68fb      	ldr	r3, [r7, #12]
 8008694:	1ad2      	subs	r2, r2, r3
 8008696:	f241 3388 	movw	r3, #5000	; 0x1388
 800869a:	429a      	cmp	r2, r3
 800869c:	d901      	bls.n	80086a2 <HAL_RCC_ClockConfig+0x2ce>
          {
            return HAL_TIMEOUT;
 800869e:	2303      	movs	r3, #3
 80086a0:	e076      	b.n	8008790 <HAL_RCC_ClockConfig+0x3bc>
          } 
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80086a2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80086a6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80086aa:	689b      	ldr	r3, [r3, #8]
 80086ac:	f003 030c 	and.w	r3, r3, #12
 80086b0:	2b08      	cmp	r3, #8
 80086b2:	d1eb      	bne.n	800868c <HAL_RCC_ClockConfig+0x2b8>
 80086b4:	e02a      	b.n	800870c <HAL_RCC_ClockConfig+0x338>
          {
            return HAL_TIMEOUT;
          } 
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK)
 80086b6:	687b      	ldr	r3, [r7, #4]
 80086b8:	685b      	ldr	r3, [r3, #4]
 80086ba:	2b03      	cmp	r3, #3
 80086bc:	d111      	bne.n	80086e2 <HAL_RCC_ClockConfig+0x30e>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
 80086be:	e001      	b.n	80086c4 <HAL_RCC_ClockConfig+0x2f0>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 80086c0:	2303      	movs	r3, #3
 80086c2:	e065      	b.n	8008790 <HAL_RCC_ClockConfig+0x3bc>
          } 
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
 80086c4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80086c8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80086cc:	689b      	ldr	r3, [r3, #8]
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80086ce:	f7f9 f97b 	bl	80019c8 <HAL_GetTick>
 80086d2:	4602      	mov	r2, r0
 80086d4:	68fb      	ldr	r3, [r7, #12]
 80086d6:	1ad2      	subs	r2, r2, r3
 80086d8:	f241 3388 	movw	r3, #5000	; 0x1388
 80086dc:	429a      	cmp	r2, r3
 80086de:	d9f1      	bls.n	80086c4 <HAL_RCC_ClockConfig+0x2f0>
 80086e0:	e7ee      	b.n	80086c0 <HAL_RCC_ClockConfig+0x2ec>
          } 
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 80086e2:	e00a      	b.n	80086fa <HAL_RCC_ClockConfig+0x326>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80086e4:	f7f9 f970 	bl	80019c8 <HAL_GetTick>
 80086e8:	4602      	mov	r2, r0
 80086ea:	68fb      	ldr	r3, [r7, #12]
 80086ec:	1ad2      	subs	r2, r2, r3
 80086ee:	f241 3388 	movw	r3, #5000	; 0x1388
 80086f2:	429a      	cmp	r2, r3
 80086f4:	d901      	bls.n	80086fa <HAL_RCC_ClockConfig+0x326>
          {
            return HAL_TIMEOUT;
 80086f6:	2303      	movs	r3, #3
 80086f8:	e04a      	b.n	8008790 <HAL_RCC_ClockConfig+0x3bc>
          } 
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 80086fa:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80086fe:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008702:	689b      	ldr	r3, [r3, #8]
 8008704:	f003 030c 	and.w	r3, r3, #12
 8008708:	2b00      	cmp	r3, #0
 800870a:	d1eb      	bne.n	80086e4 <HAL_RCC_ClockConfig+0x310>
        }
      }
    }
    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800870c:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8008710:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008714:	683a      	ldr	r2, [r7, #0]
 8008716:	b2d2      	uxtb	r2, r2
 8008718:	701a      	strb	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 800871a:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 800871e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008722:	681b      	ldr	r3, [r3, #0]
 8008724:	f003 020f 	and.w	r2, r3, #15
 8008728:	683b      	ldr	r3, [r7, #0]
 800872a:	429a      	cmp	r2, r3
 800872c:	d001      	beq.n	8008732 <HAL_RCC_ClockConfig+0x35e>
    {
      return HAL_ERROR;
 800872e:	2301      	movs	r3, #1
 8008730:	e02e      	b.n	8008790 <HAL_RCC_ClockConfig+0x3bc>
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8008732:	687b      	ldr	r3, [r7, #4]
 8008734:	681b      	ldr	r3, [r3, #0]
 8008736:	f003 0304 	and.w	r3, r3, #4
 800873a:	2b00      	cmp	r3, #0
 800873c:	d00e      	beq.n	800875c <HAL_RCC_ClockConfig+0x388>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800873e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008742:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008746:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800874a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800874e:	6892      	ldr	r2, [r2, #8]
 8008750:	f422 51e0 	bic.w	r1, r2, #7168	; 0x1c00
 8008754:	687a      	ldr	r2, [r7, #4]
 8008756:	68d2      	ldr	r2, [r2, #12]
 8008758:	430a      	orrs	r2, r1
 800875a:	609a      	str	r2, [r3, #8]
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800875c:	687b      	ldr	r3, [r7, #4]
 800875e:	681b      	ldr	r3, [r3, #0]
 8008760:	f003 0308 	and.w	r3, r3, #8
 8008764:	2b00      	cmp	r3, #0
 8008766:	d00f      	beq.n	8008788 <HAL_RCC_ClockConfig+0x3b4>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8008768:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800876c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008770:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008774:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008778:	6892      	ldr	r2, [r2, #8]
 800877a:	f422 4160 	bic.w	r1, r2, #57344	; 0xe000
 800877e:	687a      	ldr	r2, [r7, #4]
 8008780:	6912      	ldr	r2, [r2, #16]
 8008782:	00d2      	lsls	r2, r2, #3
 8008784:	430a      	orrs	r2, r1
 8008786:	609a      	str	r2, [r3, #8]
  }

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 8008788:	2000      	movs	r0, #0
 800878a:	f7f9 f8ef 	bl	800196c <HAL_InitTick>
  
  return HAL_OK;
 800878e:	2300      	movs	r3, #0
}
 8008790:	4618      	mov	r0, r3
 8008792:	3710      	adds	r7, #16
 8008794:	46bd      	mov	sp, r7
 8008796:	bd80      	pop	{r7, pc}

08008798 <HAL_RCC_MCOConfig>:
  * @note  For STM32F410Rx devices to output I2SCLK clock on MCO2 you should have
  *        at last one of the SPI clocks enabled (SPI1, SPI2 or SPI5).
  * @retval None
  */
void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 8008798:	b580      	push	{r7, lr}
 800879a:	b08c      	sub	sp, #48	; 0x30
 800879c:	af00      	add	r7, sp, #0
 800879e:	60f8      	str	r0, [r7, #12]
 80087a0:	60b9      	str	r1, [r7, #8]
 80087a2:	607a      	str	r2, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  /* RCC_MCO1 */
  if(RCC_MCOx == RCC_MCO1)
 80087a4:	68fb      	ldr	r3, [r7, #12]
 80087a6:	2b00      	cmp	r3, #0
 80087a8:	d138      	bne.n	800881c <HAL_RCC_MCOConfig+0x84>
  {
    assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
    
    /* MCO1 Clock Enable */
    __MCO1_CLK_ENABLE();
 80087aa:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80087ae:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80087b2:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80087b6:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80087ba:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80087bc:	f042 0201 	orr.w	r2, r2, #1
 80087c0:	631a      	str	r2, [r3, #48]	; 0x30
 80087c2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80087c6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80087ca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80087cc:	f003 0301 	and.w	r3, r3, #1
 80087d0:	61bb      	str	r3, [r7, #24]
 80087d2:	69bb      	ldr	r3, [r7, #24]
    
    /* Configure the MCO1 pin in alternate function mode */    
    GPIO_InitStruct.Pin = MCO1_PIN;
 80087d4:	f44f 7380 	mov.w	r3, #256	; 0x100
 80087d8:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80087da:	2302      	movs	r3, #2
 80087dc:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 80087de:	2303      	movs	r3, #3
 80087e0:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80087e2:	2300      	movs	r3, #0
 80087e4:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 80087e6:	2300      	movs	r3, #0
 80087e8:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
 80087ea:	f107 031c 	add.w	r3, r7, #28
 80087ee:	2000      	movs	r0, #0
 80087f0:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80087f4:	4619      	mov	r1, r3
 80087f6:	f7fc fa57 	bl	8004ca8 <HAL_GPIO_Init>
    
    /* Mask MCO1 and MCO1PRE[2:0] bits then Select MCO1 clock source and prescaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
 80087fa:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80087fe:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008802:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008806:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800880a:	6892      	ldr	r2, [r2, #8]
 800880c:	f022 61ec 	bic.w	r1, r2, #123731968	; 0x7600000
 8008810:	68b8      	ldr	r0, [r7, #8]
 8008812:	687a      	ldr	r2, [r7, #4]
 8008814:	4302      	orrs	r2, r0
 8008816:	430a      	orrs	r2, r1
 8008818:	609a      	str	r2, [r3, #8]
 800881a:	e039      	b.n	8008890 <HAL_RCC_MCOConfig+0xf8>
  else
  {
    assert_param(IS_RCC_MCO2SOURCE(RCC_MCOSource));
    
    /* MCO2 Clock Enable */
    __MCO2_CLK_ENABLE();
 800881c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008820:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008824:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008828:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800882c:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800882e:	f042 0204 	orr.w	r2, r2, #4
 8008832:	631a      	str	r2, [r3, #48]	; 0x30
 8008834:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008838:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800883c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800883e:	f003 0304 	and.w	r3, r3, #4
 8008842:	617b      	str	r3, [r7, #20]
 8008844:	697b      	ldr	r3, [r7, #20]
    
    /* Configure the MCO2 pin in alternate function mode */
    GPIO_InitStruct.Pin = MCO2_PIN;
 8008846:	f44f 7300 	mov.w	r3, #512	; 0x200
 800884a:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800884c:	2302      	movs	r3, #2
 800884e:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8008850:	2303      	movs	r3, #3
 8008852:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008854:	2300      	movs	r3, #0
 8008856:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 8008858:	2300      	movs	r3, #0
 800885a:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
 800885c:	f107 031c 	add.w	r3, r7, #28
 8008860:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8008864:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8008868:	4619      	mov	r1, r3
 800886a:	f7fc fa1d 	bl	8004ca8 <HAL_GPIO_Init>
    
    /* Mask MCO2 and MCO2PRE[2:0] bits then Select MCO2 clock source and prescaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 3)));
 800886e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008872:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008876:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800887a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800887e:	6892      	ldr	r2, [r2, #8]
 8008880:	f022 4178 	bic.w	r1, r2, #4160749568	; 0xf8000000
 8008884:	687a      	ldr	r2, [r7, #4]
 8008886:	00d0      	lsls	r0, r2, #3
 8008888:	68ba      	ldr	r2, [r7, #8]
 800888a:	4302      	orrs	r2, r0
 800888c:	430a      	orrs	r2, r1
 800888e:	609a      	str	r2, [r3, #8]
   /* This RCC MCO2 enable feature is available only on STM32F410Rx devices */
#if defined(RCC_CFGR_MCO2EN)
    __HAL_RCC_MCO2_ENABLE();
#endif /* RCC_CFGR_MCO2EN */
  }
}
 8008890:	3730      	adds	r7, #48	; 0x30
 8008892:	46bd      	mov	sp, r7
 8008894:	bd80      	pop	{r7, pc}
 8008896:	bf00      	nop

08008898 <HAL_RCC_EnableCSS>:
  *         allowing the MCU to perform rescue operations. The CSSI is linked to 
  *         the Cortex-M4 NMI (Non-Maskable Interrupt) exception vector.  
  * @retval None
  */
void HAL_RCC_EnableCSS(void)
{
 8008898:	b480      	push	{r7}
 800889a:	af00      	add	r7, sp, #0
  *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)ENABLE;
 800889c:	234c      	movs	r3, #76	; 0x4c
 800889e:	f2c4 2347 	movt	r3, #16967	; 0x4247
 80088a2:	2201      	movs	r2, #1
 80088a4:	601a      	str	r2, [r3, #0]
}
 80088a6:	46bd      	mov	sp, r7
 80088a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80088ac:	4770      	bx	lr
 80088ae:	bf00      	nop

080088b0 <HAL_RCC_DisableCSS>:
/**
  * @brief  Disables the Clock Security System.
  * @retval None
  */
void HAL_RCC_DisableCSS(void)
{
 80088b0:	b480      	push	{r7}
 80088b2:	af00      	add	r7, sp, #0
  *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)DISABLE;
 80088b4:	234c      	movs	r3, #76	; 0x4c
 80088b6:	f2c4 2347 	movt	r3, #16967	; 0x4247
 80088ba:	2200      	movs	r2, #0
 80088bc:	601a      	str	r2, [r3, #0]
}
 80088be:	46bd      	mov	sp, r7
 80088c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80088c4:	4770      	bx	lr
 80088c6:	bf00      	nop

080088c8 <HAL_RCC_GetSysClockFreq>:
  *         
  *               
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80088c8:	b480      	push	{r7}
 80088ca:	b08b      	sub	sp, #44	; 0x2c
 80088cc:	af00      	add	r7, sp, #0
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
 80088ce:	2300      	movs	r3, #0
 80088d0:	61fb      	str	r3, [r7, #28]
 80088d2:	2300      	movs	r3, #0
 80088d4:	627b      	str	r3, [r7, #36]	; 0x24
 80088d6:	2300      	movs	r3, #0
 80088d8:	61bb      	str	r3, [r7, #24]
  uint32_t sysclockfreq = 0;
 80088da:	2300      	movs	r3, #0
 80088dc:	623b      	str	r3, [r7, #32]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80088de:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80088e2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80088e6:	689b      	ldr	r3, [r3, #8]
 80088e8:	f003 030c 	and.w	r3, r3, #12
 80088ec:	2b04      	cmp	r3, #4
 80088ee:	d009      	beq.n	8008904 <HAL_RCC_GetSysClockFreq+0x3c>
 80088f0:	2b08      	cmp	r3, #8
 80088f2:	d00d      	beq.n	8008910 <HAL_RCC_GetSysClockFreq+0x48>
 80088f4:	2b00      	cmp	r3, #0
 80088f6:	d173      	bne.n	80089e0 <HAL_RCC_GetSysClockFreq+0x118>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 80088f8:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 80088fc:	f2c0 03f4 	movt	r3, #244	; 0xf4
 8008900:	623b      	str	r3, [r7, #32]
       break;
 8008902:	e073      	b.n	80089ec <HAL_RCC_GetSysClockFreq+0x124>
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 8008904:	f44f 5390 	mov.w	r3, #4608	; 0x1200
 8008908:	f2c0 037a 	movt	r3, #122	; 0x7a
 800890c:	623b      	str	r3, [r7, #32]
      break;
 800890e:	e06d      	b.n	80089ec <HAL_RCC_GetSysClockFreq+0x124>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8008910:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008914:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008918:	685b      	ldr	r3, [r3, #4]
 800891a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800891e:	61fb      	str	r3, [r7, #28]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8008920:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008924:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008928:	685b      	ldr	r3, [r3, #4]
 800892a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800892e:	2b00      	cmp	r3, #0
 8008930:	d01d      	beq.n	800896e <HAL_RCC_GetSysClockFreq+0xa6>
      {
        /* HSE used as PLL clock source */
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 8008932:	f44f 5390 	mov.w	r3, #4608	; 0x1200
 8008936:	f2c0 037a 	movt	r3, #122	; 0x7a
 800893a:	69fa      	ldr	r2, [r7, #28]
 800893c:	fbb3 f2f2 	udiv	r2, r3, r2
 8008940:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008944:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008948:	6859      	ldr	r1, [r3, #4]
 800894a:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800894e:	400b      	ands	r3, r1
 8008950:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 8008954:	6179      	str	r1, [r7, #20]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008956:	6979      	ldr	r1, [r7, #20]
 8008958:	fa91 f1a1 	rbit	r1, r1
 800895c:	6139      	str	r1, [r7, #16]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800895e:	6939      	ldr	r1, [r7, #16]
 8008960:	fab1 f181 	clz	r1, r1
 8008964:	40cb      	lsrs	r3, r1
 8008966:	fb03 f302 	mul.w	r3, r3, r2
 800896a:	627b      	str	r3, [r7, #36]	; 0x24
 800896c:	e01c      	b.n	80089a8 <HAL_RCC_GetSysClockFreq+0xe0>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 800896e:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 8008972:	f2c0 03f4 	movt	r3, #244	; 0xf4
 8008976:	69fa      	ldr	r2, [r7, #28]
 8008978:	fbb3 f2f2 	udiv	r2, r3, r2
 800897c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008980:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008984:	6859      	ldr	r1, [r3, #4]
 8008986:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800898a:	400b      	ands	r3, r1
 800898c:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 8008990:	60f9      	str	r1, [r7, #12]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008992:	68f9      	ldr	r1, [r7, #12]
 8008994:	fa91 f1a1 	rbit	r1, r1
 8008998:	60b9      	str	r1, [r7, #8]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800899a:	68b9      	ldr	r1, [r7, #8]
 800899c:	fab1 f181 	clz	r1, r1
 80089a0:	40cb      	lsrs	r3, r1
 80089a2:	fb03 f302 	mul.w	r3, r3, r2
 80089a6:	627b      	str	r3, [r7, #36]	; 0x24
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1 ) *2);
 80089a8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80089ac:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80089b0:	685b      	ldr	r3, [r3, #4]
 80089b2:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 80089b6:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 80089ba:	607b      	str	r3, [r7, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80089bc:	687b      	ldr	r3, [r7, #4]
 80089be:	fa93 f3a3 	rbit	r3, r3
 80089c2:	603b      	str	r3, [r7, #0]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 80089c4:	683b      	ldr	r3, [r7, #0]
 80089c6:	fab3 f383 	clz	r3, r3
 80089ca:	fa22 f303 	lsr.w	r3, r2, r3
 80089ce:	3301      	adds	r3, #1
 80089d0:	005b      	lsls	r3, r3, #1
 80089d2:	61bb      	str	r3, [r7, #24]
      
      sysclockfreq = pllvco/pllp;
 80089d4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80089d6:	69bb      	ldr	r3, [r7, #24]
 80089d8:	fbb2 f3f3 	udiv	r3, r2, r3
 80089dc:	623b      	str	r3, [r7, #32]
      break;
 80089de:	e005      	b.n	80089ec <HAL_RCC_GetSysClockFreq+0x124>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 80089e0:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 80089e4:	f2c0 03f4 	movt	r3, #244	; 0xf4
 80089e8:	623b      	str	r3, [r7, #32]
      break;
 80089ea:	bf00      	nop
    }
  }
  return sysclockfreq;
 80089ec:	6a3b      	ldr	r3, [r7, #32]
}
 80089ee:	4618      	mov	r0, r3
 80089f0:	372c      	adds	r7, #44	; 0x2c
 80089f2:	46bd      	mov	sp, r7
 80089f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80089f8:	4770      	bx	lr
 80089fa:	bf00      	nop

080089fc <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 80089fc:	b580      	push	{r7, lr}
 80089fe:	b082      	sub	sp, #8
 8008a00:	af00      	add	r7, sp, #0
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 8008a02:	f7ff ff61 	bl	80088c8 <HAL_RCC_GetSysClockFreq>
 8008a06:	4602      	mov	r2, r0
 8008a08:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008a0c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008a10:	689b      	ldr	r3, [r3, #8]
 8008a12:	f003 01f0 	and.w	r1, r3, #240	; 0xf0
 8008a16:	23f0      	movs	r3, #240	; 0xf0
 8008a18:	607b      	str	r3, [r7, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008a1a:	687b      	ldr	r3, [r7, #4]
 8008a1c:	fa93 f3a3 	rbit	r3, r3
 8008a20:	603b      	str	r3, [r7, #0]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8008a22:	683b      	ldr	r3, [r7, #0]
 8008a24:	fab3 f383 	clz	r3, r3
 8008a28:	40d9      	lsrs	r1, r3
 8008a2a:	f64b 2314 	movw	r3, #47636	; 0xba14
 8008a2e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008a32:	5c5b      	ldrb	r3, [r3, r1]
 8008a34:	40da      	lsrs	r2, r3
 8008a36:	f240 0300 	movw	r3, #0
 8008a3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008a3e:	601a      	str	r2, [r3, #0]
  return SystemCoreClock;
 8008a40:	f240 0300 	movw	r3, #0
 8008a44:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008a48:	681b      	ldr	r3, [r3, #0]
}
 8008a4a:	4618      	mov	r0, r3
 8008a4c:	3708      	adds	r7, #8
 8008a4e:	46bd      	mov	sp, r7
 8008a50:	bd80      	pop	{r7, pc}
 8008a52:	bf00      	nop

08008a54 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{  
 8008a54:	b580      	push	{r7, lr}
 8008a56:	b082      	sub	sp, #8
 8008a58:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 8008a5a:	f7ff ffcf 	bl	80089fc <HAL_RCC_GetHCLKFreq>
 8008a5e:	4602      	mov	r2, r0
 8008a60:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008a64:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008a68:	689b      	ldr	r3, [r3, #8]
 8008a6a:	f403 51e0 	and.w	r1, r3, #7168	; 0x1c00
 8008a6e:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 8008a72:	607b      	str	r3, [r7, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008a74:	687b      	ldr	r3, [r7, #4]
 8008a76:	fa93 f3a3 	rbit	r3, r3
 8008a7a:	603b      	str	r3, [r7, #0]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8008a7c:	683b      	ldr	r3, [r7, #0]
 8008a7e:	fab3 f383 	clz	r3, r3
 8008a82:	40d9      	lsrs	r1, r3
 8008a84:	f64b 2314 	movw	r3, #47636	; 0xba14
 8008a88:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008a8c:	5c5b      	ldrb	r3, [r3, r1]
 8008a8e:	fa22 f303 	lsr.w	r3, r2, r3
}
 8008a92:	4618      	mov	r0, r3
 8008a94:	3708      	adds	r7, #8
 8008a96:	46bd      	mov	sp, r7
 8008a98:	bd80      	pop	{r7, pc}
 8008a9a:	bf00      	nop

08008a9c <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8008a9c:	b580      	push	{r7, lr}
 8008a9e:	b082      	sub	sp, #8
 8008aa0:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
 8008aa2:	f7ff ffab 	bl	80089fc <HAL_RCC_GetHCLKFreq>
 8008aa6:	4602      	mov	r2, r0
 8008aa8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008aac:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008ab0:	689b      	ldr	r3, [r3, #8]
 8008ab2:	f403 4160 	and.w	r1, r3, #57344	; 0xe000
 8008ab6:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 8008aba:	607b      	str	r3, [r7, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008abc:	687b      	ldr	r3, [r7, #4]
 8008abe:	fa93 f3a3 	rbit	r3, r3
 8008ac2:	603b      	str	r3, [r7, #0]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8008ac4:	683b      	ldr	r3, [r7, #0]
 8008ac6:	fab3 f383 	clz	r3, r3
 8008aca:	40d9      	lsrs	r1, r3
 8008acc:	f64b 2314 	movw	r3, #47636	; 0xba14
 8008ad0:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008ad4:	5c5b      	ldrb	r3, [r3, r1]
 8008ad6:	fa22 f303 	lsr.w	r3, r2, r3
} 
 8008ada:	4618      	mov	r0, r3
 8008adc:	3708      	adds	r7, #8
 8008ade:	46bd      	mov	sp, r7
 8008ae0:	bd80      	pop	{r7, pc}
 8008ae2:	bf00      	nop

08008ae4 <HAL_RCC_GetOscConfig>:
  * @param  RCC_OscInitStruct: pointer to an RCC_OscInitTypeDef structure that 
  * will be configured.
  * @retval None
  */
__weak void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8008ae4:	b480      	push	{r7}
 8008ae6:	b08b      	sub	sp, #44	; 0x2c
 8008ae8:	af00      	add	r7, sp, #0
 8008aea:	6078      	str	r0, [r7, #4]
  /* Set all possible values for the Oscillator type parameter ---------------*/
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;
 8008aec:	687b      	ldr	r3, [r7, #4]
 8008aee:	220f      	movs	r2, #15
 8008af0:	601a      	str	r2, [r3, #0]
  
  /* Get the HSE configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
 8008af2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008af6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008afa:	681b      	ldr	r3, [r3, #0]
 8008afc:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8008b00:	2b00      	cmp	r3, #0
 8008b02:	d003      	beq.n	8008b0c <HAL_RCC_GetOscConfig+0x28>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
 8008b04:	687b      	ldr	r3, [r7, #4]
 8008b06:	2205      	movs	r2, #5
 8008b08:	605a      	str	r2, [r3, #4]
 8008b0a:	e00f      	b.n	8008b2c <HAL_RCC_GetOscConfig+0x48>
  }
  else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
 8008b0c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008b10:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008b14:	681b      	ldr	r3, [r3, #0]
 8008b16:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8008b1a:	2b00      	cmp	r3, #0
 8008b1c:	d003      	beq.n	8008b26 <HAL_RCC_GetOscConfig+0x42>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_ON;
 8008b1e:	687b      	ldr	r3, [r7, #4]
 8008b20:	2201      	movs	r2, #1
 8008b22:	605a      	str	r2, [r3, #4]
 8008b24:	e002      	b.n	8008b2c <HAL_RCC_GetOscConfig+0x48>
  }
  else
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
 8008b26:	687b      	ldr	r3, [r7, #4]
 8008b28:	2200      	movs	r2, #0
 8008b2a:	605a      	str	r2, [r3, #4]
  }
  
  /* Get the HSI configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
 8008b2c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008b30:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008b34:	681b      	ldr	r3, [r3, #0]
 8008b36:	f003 0301 	and.w	r3, r3, #1
 8008b3a:	2b00      	cmp	r3, #0
 8008b3c:	d003      	beq.n	8008b46 <HAL_RCC_GetOscConfig+0x62>
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_ON;
 8008b3e:	687b      	ldr	r3, [r7, #4]
 8008b40:	2201      	movs	r2, #1
 8008b42:	60da      	str	r2, [r3, #12]
 8008b44:	e002      	b.n	8008b4c <HAL_RCC_GetOscConfig+0x68>
  }
  else
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
 8008b46:	687b      	ldr	r3, [r7, #4]
 8008b48:	2200      	movs	r2, #0
 8008b4a:	60da      	str	r2, [r3, #12]
  }
  
  RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->CR &RCC_CR_HSITRIM) >> POSITION_VAL(RCC_CR_HSITRIM));
 8008b4c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008b50:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008b54:	681b      	ldr	r3, [r3, #0]
 8008b56:	f003 02f8 	and.w	r2, r3, #248	; 0xf8
 8008b5a:	23f8      	movs	r3, #248	; 0xf8
 8008b5c:	627b      	str	r3, [r7, #36]	; 0x24
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008b5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008b60:	fa93 f3a3 	rbit	r3, r3
 8008b64:	623b      	str	r3, [r7, #32]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8008b66:	6a3b      	ldr	r3, [r7, #32]
 8008b68:	fab3 f383 	clz	r3, r3
 8008b6c:	40da      	lsrs	r2, r3
 8008b6e:	687b      	ldr	r3, [r7, #4]
 8008b70:	611a      	str	r2, [r3, #16]
  
  /* Get the LSE configuration -----------------------------------------------*/
  if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
 8008b72:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008b76:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008b7a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008b7c:	f003 0304 	and.w	r3, r3, #4
 8008b80:	2b00      	cmp	r3, #0
 8008b82:	d003      	beq.n	8008b8c <HAL_RCC_GetOscConfig+0xa8>
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
 8008b84:	687b      	ldr	r3, [r7, #4]
 8008b86:	2205      	movs	r2, #5
 8008b88:	609a      	str	r2, [r3, #8]
 8008b8a:	e00f      	b.n	8008bac <HAL_RCC_GetOscConfig+0xc8>
  }
  else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
 8008b8c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008b90:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008b94:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008b96:	f003 0301 	and.w	r3, r3, #1
 8008b9a:	2b00      	cmp	r3, #0
 8008b9c:	d003      	beq.n	8008ba6 <HAL_RCC_GetOscConfig+0xc2>
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_ON;
 8008b9e:	687b      	ldr	r3, [r7, #4]
 8008ba0:	2201      	movs	r2, #1
 8008ba2:	609a      	str	r2, [r3, #8]
 8008ba4:	e002      	b.n	8008bac <HAL_RCC_GetOscConfig+0xc8>
  }
  else
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
 8008ba6:	687b      	ldr	r3, [r7, #4]
 8008ba8:	2200      	movs	r2, #0
 8008baa:	609a      	str	r2, [r3, #8]
  }
  
  /* Get the LSI configuration -----------------------------------------------*/
  if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
 8008bac:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008bb0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008bb4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8008bb6:	f003 0301 	and.w	r3, r3, #1
 8008bba:	2b00      	cmp	r3, #0
 8008bbc:	d003      	beq.n	8008bc6 <HAL_RCC_GetOscConfig+0xe2>
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_ON;
 8008bbe:	687b      	ldr	r3, [r7, #4]
 8008bc0:	2201      	movs	r2, #1
 8008bc2:	615a      	str	r2, [r3, #20]
 8008bc4:	e002      	b.n	8008bcc <HAL_RCC_GetOscConfig+0xe8>
  }
  else
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
 8008bc6:	687b      	ldr	r3, [r7, #4]
 8008bc8:	2200      	movs	r2, #0
 8008bca:	615a      	str	r2, [r3, #20]
  }
  
  /* Get the PLL configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
 8008bcc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008bd0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008bd4:	681b      	ldr	r3, [r3, #0]
 8008bd6:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8008bda:	2b00      	cmp	r3, #0
 8008bdc:	d003      	beq.n	8008be6 <HAL_RCC_GetOscConfig+0x102>
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
 8008bde:	687b      	ldr	r3, [r7, #4]
 8008be0:	2202      	movs	r2, #2
 8008be2:	619a      	str	r2, [r3, #24]
 8008be4:	e002      	b.n	8008bec <HAL_RCC_GetOscConfig+0x108>
  }
  else
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
 8008be6:	687b      	ldr	r3, [r7, #4]
 8008be8:	2201      	movs	r2, #1
 8008bea:	619a      	str	r2, [r3, #24]
  }
  RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 8008bec:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008bf0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008bf4:	685b      	ldr	r3, [r3, #4]
 8008bf6:	f403 0280 	and.w	r2, r3, #4194304	; 0x400000
 8008bfa:	687b      	ldr	r3, [r7, #4]
 8008bfc:	61da      	str	r2, [r3, #28]
  RCC_OscInitStruct->PLL.PLLM = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);
 8008bfe:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008c02:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008c06:	685b      	ldr	r3, [r3, #4]
 8008c08:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 8008c0c:	687b      	ldr	r3, [r7, #4]
 8008c0e:	621a      	str	r2, [r3, #32]
  RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN));
 8008c10:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008c14:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008c18:	685a      	ldr	r2, [r3, #4]
 8008c1a:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8008c1e:	4013      	ands	r3, r2
 8008c20:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 8008c24:	61fa      	str	r2, [r7, #28]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008c26:	69fa      	ldr	r2, [r7, #28]
 8008c28:	fa92 f2a2 	rbit	r2, r2
 8008c2c:	61ba      	str	r2, [r7, #24]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8008c2e:	69ba      	ldr	r2, [r7, #24]
 8008c30:	fab2 f282 	clz	r2, r2
 8008c34:	fa23 f202 	lsr.w	r2, r3, r2
 8008c38:	687b      	ldr	r3, [r7, #4]
 8008c3a:	625a      	str	r2, [r3, #36]	; 0x24
  RCC_OscInitStruct->PLL.PLLP = (uint32_t)((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) + RCC_PLLCFGR_PLLP_0) << 1) >> POSITION_VAL(RCC_PLLCFGR_PLLP));
 8008c3c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008c40:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008c44:	685b      	ldr	r3, [r3, #4]
 8008c46:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8008c4a:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8008c4e:	005a      	lsls	r2, r3, #1
 8008c50:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 8008c54:	617b      	str	r3, [r7, #20]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008c56:	697b      	ldr	r3, [r7, #20]
 8008c58:	fa93 f3a3 	rbit	r3, r3
 8008c5c:	613b      	str	r3, [r7, #16]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8008c5e:	693b      	ldr	r3, [r7, #16]
 8008c60:	fab3 f383 	clz	r3, r3
 8008c64:	40da      	lsrs	r2, r3
 8008c66:	687b      	ldr	r3, [r7, #4]
 8008c68:	629a      	str	r2, [r3, #40]	; 0x28
  RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLQ) >> POSITION_VAL(RCC_PLLCFGR_PLLQ));
 8008c6a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008c6e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008c72:	685b      	ldr	r3, [r3, #4]
 8008c74:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
 8008c78:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
 8008c7c:	60fb      	str	r3, [r7, #12]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008c7e:	68fb      	ldr	r3, [r7, #12]
 8008c80:	fa93 f3a3 	rbit	r3, r3
 8008c84:	60bb      	str	r3, [r7, #8]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8008c86:	68bb      	ldr	r3, [r7, #8]
 8008c88:	fab3 f383 	clz	r3, r3
 8008c8c:	40da      	lsrs	r2, r3
 8008c8e:	687b      	ldr	r3, [r7, #4]
 8008c90:	62da      	str	r2, [r3, #44]	; 0x2c
}
 8008c92:	372c      	adds	r7, #44	; 0x2c
 8008c94:	46bd      	mov	sp, r7
 8008c96:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008c9a:	4770      	bx	lr

08008c9c <HAL_RCC_GetClockConfig>:
  * will be configured.
  * @param  pFLatency: Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
 8008c9c:	b480      	push	{r7}
 8008c9e:	b083      	sub	sp, #12
 8008ca0:	af00      	add	r7, sp, #0
 8008ca2:	6078      	str	r0, [r7, #4]
 8008ca4:	6039      	str	r1, [r7, #0]
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 8008ca6:	687b      	ldr	r3, [r7, #4]
 8008ca8:	220f      	movs	r2, #15
 8008caa:	601a      	str	r2, [r3, #0]
   
  /* Get the SYSCLK configuration --------------------------------------------*/ 
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8008cac:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008cb0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008cb4:	689b      	ldr	r3, [r3, #8]
 8008cb6:	f003 0203 	and.w	r2, r3, #3
 8008cba:	687b      	ldr	r3, [r7, #4]
 8008cbc:	605a      	str	r2, [r3, #4]
  
  /* Get the HCLK configuration ----------------------------------------------*/ 
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
 8008cbe:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008cc2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008cc6:	689b      	ldr	r3, [r3, #8]
 8008cc8:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 8008ccc:	687b      	ldr	r3, [r7, #4]
 8008cce:	609a      	str	r2, [r3, #8]
  
  /* Get the APB1 configuration ----------------------------------------------*/ 
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);   
 8008cd0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008cd4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008cd8:	689b      	ldr	r3, [r3, #8]
 8008cda:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
 8008cde:	687b      	ldr	r3, [r7, #4]
 8008ce0:	60da      	str	r2, [r3, #12]
  
  /* Get the APB2 configuration ----------------------------------------------*/ 
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 8008ce2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008ce6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008cea:	689b      	ldr	r3, [r3, #8]
 8008cec:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8008cf0:	08da      	lsrs	r2, r3, #3
 8008cf2:	687b      	ldr	r3, [r7, #4]
 8008cf4:	611a      	str	r2, [r3, #16]
  
  /* Get the Flash Wait State (Latency) configuration ------------------------*/   
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY); 
 8008cf6:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8008cfa:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008cfe:	681b      	ldr	r3, [r3, #0]
 8008d00:	f003 020f 	and.w	r2, r3, #15
 8008d04:	683b      	ldr	r3, [r7, #0]
 8008d06:	601a      	str	r2, [r3, #0]
}
 8008d08:	370c      	adds	r7, #12
 8008d0a:	46bd      	mov	sp, r7
 8008d0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d10:	4770      	bx	lr
 8008d12:	bf00      	nop

08008d14 <HAL_RCC_NMI_IRQHandler>:
  * @brief This function handles the RCC CSS interrupt request.
  * @note This API should be called under the NMI_Handler().
  * @retval None
  */
void HAL_RCC_NMI_IRQHandler(void)
{
 8008d14:	b580      	push	{r7, lr}
 8008d16:	af00      	add	r7, sp, #0
  /* Check RCC CSSF flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_CSS))
 8008d18:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008d1c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008d20:	68db      	ldr	r3, [r3, #12]
 8008d22:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8008d26:	2b00      	cmp	r3, #0
 8008d28:	d007      	beq.n	8008d3a <HAL_RCC_NMI_IRQHandler+0x26>
  {
    /* RCC Clock Security System interrupt user callback */
    HAL_RCC_CSSCallback();
 8008d2a:	f000 f807 	bl	8008d3c <HAL_RCC_CSSCallback>

    /* Clear RCC CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
 8008d2e:	f643 030e 	movw	r3, #14350	; 0x380e
 8008d32:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008d36:	2280      	movs	r2, #128	; 0x80
 8008d38:	701a      	strb	r2, [r3, #0]
  }
}
 8008d3a:	bd80      	pop	{r7, pc}

08008d3c <HAL_RCC_CSSCallback>:
/**
  * @brief  RCC Clock Security System interrupt callback
  * @retval None
  */
__weak void HAL_RCC_CSSCallback(void)
{
 8008d3c:	b480      	push	{r7}
 8008d3e:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_RCC_CSSCallback could be implemented in the user file
   */ 
}
 8008d40:	46bd      	mov	sp, r7
 8008d42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d46:	4770      	bx	lr

08008d48 <HAL_RCC_DeInit>:
  *            - Peripheral clocks  
  *            - LSI, LSE and RTC clocks 
  * @retval None
  */
void HAL_RCC_DeInit(void)
{
 8008d48:	b480      	push	{r7}
 8008d4a:	af00      	add	r7, sp, #0
  /* Set HSION bit */
  SET_BIT(RCC->CR, RCC_CR_HSION | RCC_CR_HSITRIM_4); 
 8008d4c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008d50:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008d54:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008d58:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008d5c:	6812      	ldr	r2, [r2, #0]
 8008d5e:	f042 0281 	orr.w	r2, r2, #129	; 0x81
 8008d62:	601a      	str	r2, [r3, #0]
  
  /* Reset CFGR register */
  CLEAR_REG(RCC->CFGR);
 8008d64:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008d68:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008d6c:	2200      	movs	r2, #0
 8008d6e:	609a      	str	r2, [r3, #8]
  
  /* Reset HSEON, CSSON, PLLON, PLLI2S */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLLON| RCC_CR_PLLI2SON); 
 8008d70:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008d74:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008d78:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008d7c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008d80:	6812      	ldr	r2, [r2, #0]
 8008d82:	f022 62a1 	bic.w	r2, r2, #84410368	; 0x5080000
 8008d86:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8008d8a:	601a      	str	r2, [r3, #0]
  
  /* Reset PLLCFGR register */
  CLEAR_REG(RCC->PLLCFGR);
 8008d8c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008d90:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008d94:	2200      	movs	r2, #0
 8008d96:	605a      	str	r2, [r3, #4]
  SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM_4 | RCC_PLLCFGR_PLLN_6 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLQ_2); 
 8008d98:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008d9c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008da0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008da4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008da8:	6859      	ldr	r1, [r3, #4]
 8008daa:	f243 0310 	movw	r3, #12304	; 0x3010
 8008dae:	f2c0 4300 	movt	r3, #1024	; 0x400
 8008db2:	430b      	orrs	r3, r1
 8008db4:	6053      	str	r3, [r2, #4]
  
  /* Reset PLLI2SCFGR register */
  CLEAR_REG(RCC->PLLI2SCFGR);
 8008db6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008dba:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008dbe:	2200      	movs	r2, #0
 8008dc0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  SET_BIT(RCC->PLLI2SCFGR,  RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SR_1);
 8008dc4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008dc8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008dcc:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008dd0:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008dd4:	f8d2 2084 	ldr.w	r2, [r2, #132]	; 0x84
 8008dd8:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8008ddc:	f442 5240 	orr.w	r2, r2, #12288	; 0x3000
 8008de0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  
  /* Reset HSEBYP bit */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
 8008de4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008de8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008dec:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008df0:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008df4:	6812      	ldr	r2, [r2, #0]
 8008df6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8008dfa:	601a      	str	r2, [r3, #0]
  
  /* Disable all interrupts */
  CLEAR_REG(RCC->CIR); 
 8008dfc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008e00:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008e04:	2200      	movs	r2, #0
 8008e06:	60da      	str	r2, [r3, #12]
}
 8008e08:	46bd      	mov	sp, r7
 8008e0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008e0e:	4770      	bx	lr

08008e10 <HAL_RCCEx_PeriphCLKConfig>:
  *        domain (RTC and RCC_BDCR register expect BKPSRAM) will be reset
  *              
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8008e10:	b580      	push	{r7, lr}
 8008e12:	b08a      	sub	sp, #40	; 0x28
 8008e14:	af00      	add	r7, sp, #0
 8008e16:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0;
 8008e18:	2300      	movs	r3, #0
 8008e1a:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t tmpreg1 = 0;
 8008e1c:	2300      	movs	r3, #0
 8008e1e:	623b      	str	r3, [r7, #32]
    
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
  
  /*---------------------------- I2S configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8008e20:	687b      	ldr	r3, [r7, #4]
 8008e22:	681b      	ldr	r3, [r3, #0]
 8008e24:	f003 0301 	and.w	r3, r3, #1
 8008e28:	2b00      	cmp	r3, #0
 8008e2a:	d057      	beq.n	8008edc <HAL_RCCEx_PeriphCLKConfig+0xcc>
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));
#if defined(STM32F411xE)    
    assert_param(IS_RCC_PLLI2SM_VALUE(PeriphClkInit->PLLI2S.PLLI2SM));
#endif /* STM32F411xE */
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
 8008e2c:	2368      	movs	r3, #104	; 0x68
 8008e2e:	f2c4 2347 	movt	r3, #16967	; 0x4247
 8008e32:	2200      	movs	r2, #0
 8008e34:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 8008e36:	f7f8 fdc7 	bl	80019c8 <HAL_GetTick>
 8008e3a:	6278      	str	r0, [r7, #36]	; 0x24
    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8008e3c:	e008      	b.n	8008e50 <HAL_RCCEx_PeriphCLKConfig+0x40>
    {
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 8008e3e:	f7f8 fdc3 	bl	80019c8 <HAL_GetTick>
 8008e42:	4602      	mov	r2, r0
 8008e44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008e46:	1ad3      	subs	r3, r2, r3
 8008e48:	2b64      	cmp	r3, #100	; 0x64
 8008e4a:	d901      	bls.n	8008e50 <HAL_RCCEx_PeriphCLKConfig+0x40>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 8008e4c:	2303      	movs	r3, #3
 8008e4e:	e0fd      	b.n	800904c <HAL_RCCEx_PeriphCLKConfig+0x23c>
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
    /* Get tick */
    tickstart = HAL_GetTick();
    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8008e50:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008e54:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008e58:	681b      	ldr	r3, [r3, #0]
 8008e5a:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8008e5e:	2b00      	cmp	r3, #0
 8008e60:	d1ed      	bne.n	8008e3e <HAL_RCCEx_PeriphCLKConfig+0x2e>
    __HAL_RCC_PLLI2S_I2SCLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN, PeriphClkInit->PLLI2S.PLLI2SR);
#else
    /* Configure the PLLI2S division factors */
    /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLM) */
    /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
    __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
 8008e62:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008e66:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008e6a:	687a      	ldr	r2, [r7, #4]
 8008e6c:	6851      	ldr	r1, [r2, #4]
 8008e6e:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 8008e72:	61fa      	str	r2, [r7, #28]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008e74:	69fa      	ldr	r2, [r7, #28]
 8008e76:	fa92 f2a2 	rbit	r2, r2
 8008e7a:	61ba      	str	r2, [r7, #24]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8008e7c:	69ba      	ldr	r2, [r7, #24]
 8008e7e:	fab2 f282 	clz	r2, r2
 8008e82:	4091      	lsls	r1, r2
 8008e84:	687a      	ldr	r2, [r7, #4]
 8008e86:	6890      	ldr	r0, [r2, #8]
 8008e88:	f04f 42e0 	mov.w	r2, #1879048192	; 0x70000000
 8008e8c:	617a      	str	r2, [r7, #20]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008e8e:	697a      	ldr	r2, [r7, #20]
 8008e90:	fa92 f2a2 	rbit	r2, r2
 8008e94:	613a      	str	r2, [r7, #16]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8008e96:	693a      	ldr	r2, [r7, #16]
 8008e98:	fab2 f282 	clz	r2, r2
 8008e9c:	fa00 f202 	lsl.w	r2, r0, r2
 8008ea0:	430a      	orrs	r2, r1
 8008ea2:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
#endif /* STM32F411xE */
    
    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
 8008ea6:	2368      	movs	r3, #104	; 0x68
 8008ea8:	f2c4 2347 	movt	r3, #16967	; 0x4247
 8008eac:	2201      	movs	r2, #1
 8008eae:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 8008eb0:	f7f8 fd8a 	bl	80019c8 <HAL_GetTick>
 8008eb4:	6278      	str	r0, [r7, #36]	; 0x24
    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8008eb6:	e008      	b.n	8008eca <HAL_RCCEx_PeriphCLKConfig+0xba>
    {
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 8008eb8:	f7f8 fd86 	bl	80019c8 <HAL_GetTick>
 8008ebc:	4602      	mov	r2, r0
 8008ebe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008ec0:	1ad3      	subs	r3, r2, r3
 8008ec2:	2b64      	cmp	r3, #100	; 0x64
 8008ec4:	d901      	bls.n	8008eca <HAL_RCCEx_PeriphCLKConfig+0xba>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 8008ec6:	2303      	movs	r3, #3
 8008ec8:	e0c0      	b.n	800904c <HAL_RCCEx_PeriphCLKConfig+0x23c>
    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
    /* Get tick */
    tickstart = HAL_GetTick();
    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8008eca:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008ece:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008ed2:	681b      	ldr	r3, [r3, #0]
 8008ed4:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8008ed8:	2b00      	cmp	r3, #0
 8008eda:	d0ed      	beq.n	8008eb8 <HAL_RCCEx_PeriphCLKConfig+0xa8>
      }
    }
  }
  
  /*---------------------------- RTC configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8008edc:	687b      	ldr	r3, [r7, #4]
 8008ede:	681b      	ldr	r3, [r3, #0]
 8008ee0:	f003 0302 	and.w	r3, r3, #2
 8008ee4:	2b00      	cmp	r3, #0
 8008ee6:	f000 80b0 	beq.w	800904a <HAL_RCCEx_PeriphCLKConfig+0x23a>
  {
	/* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8008eea:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008eee:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008ef2:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008ef6:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008efa:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8008efc:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8008f00:	641a      	str	r2, [r3, #64]	; 0x40
 8008f02:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008f06:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008f0a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008f0c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8008f10:	60fb      	str	r3, [r7, #12]
 8008f12:	68fb      	ldr	r3, [r7, #12]
      
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 8008f14:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8008f18:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8008f1c:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 8008f20:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8008f24:	6812      	ldr	r2, [r2, #0]
 8008f26:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8008f2a:	601a      	str	r2, [r3, #0]
      
    /* Get tick */
    tickstart = HAL_GetTick();
 8008f2c:	f7f8 fd4c 	bl	80019c8 <HAL_GetTick>
 8008f30:	6278      	str	r0, [r7, #36]	; 0x24
      
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8008f32:	e008      	b.n	8008f46 <HAL_RCCEx_PeriphCLKConfig+0x136>
      {
        if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8008f34:	f7f8 fd48 	bl	80019c8 <HAL_GetTick>
 8008f38:	4602      	mov	r2, r0
 8008f3a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008f3c:	1ad3      	subs	r3, r2, r3
 8008f3e:	2b64      	cmp	r3, #100	; 0x64
 8008f40:	d901      	bls.n	8008f46 <HAL_RCCEx_PeriphCLKConfig+0x136>
        {
          return HAL_TIMEOUT;
 8008f42:	2303      	movs	r3, #3
 8008f44:	e082      	b.n	800904c <HAL_RCCEx_PeriphCLKConfig+0x23c>
    PWR->CR |= PWR_CR_DBP;
      
    /* Get tick */
    tickstart = HAL_GetTick();
      
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8008f46:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8008f4a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8008f4e:	681b      	ldr	r3, [r3, #0]
 8008f50:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8008f54:	2b00      	cmp	r3, #0
 8008f56:	d0ed      	beq.n	8008f34 <HAL_RCCEx_PeriphCLKConfig+0x124>
          return HAL_TIMEOUT;
        }
      }
	  
    /* Reset the Backup domain only if the RTC Clock source selection is modified */ 
    if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
 8008f58:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008f5c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008f60:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8008f62:	687b      	ldr	r3, [r7, #4]
 8008f64:	68db      	ldr	r3, [r3, #12]
 8008f66:	4053      	eors	r3, r2
 8008f68:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8008f6c:	2b00      	cmp	r3, #0
 8008f6e:	d06c      	beq.n	800904a <HAL_RCCEx_PeriphCLKConfig+0x23a>
    {      
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8008f70:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008f74:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008f78:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008f7a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8008f7e:	623b      	str	r3, [r7, #32]
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8008f80:	f44f 6364 	mov.w	r3, #3648	; 0xe40
 8008f84:	f2c4 2347 	movt	r3, #16967	; 0x4247
 8008f88:	2201      	movs	r2, #1
 8008f8a:	601a      	str	r2, [r3, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 8008f8c:	f44f 6364 	mov.w	r3, #3648	; 0xe40
 8008f90:	f2c4 2347 	movt	r3, #16967	; 0x4247
 8008f94:	2200      	movs	r2, #0
 8008f96:	601a      	str	r2, [r3, #0]
      /* Restore the Content of BDCR register */
      RCC->BDCR = tmpreg1;
 8008f98:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008f9c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008fa0:	6a3a      	ldr	r2, [r7, #32]
 8008fa2:	671a      	str	r2, [r3, #112]	; 0x70
      
      /* Wait for LSERDY if LSE was enabled */
      if(HAL_IS_BIT_SET(tmpreg1, RCC_BDCR_LSERDY))
 8008fa4:	6a3b      	ldr	r3, [r7, #32]
 8008fa6:	f003 0302 	and.w	r3, r3, #2
 8008faa:	2b00      	cmp	r3, #0
 8008fac:	d017      	beq.n	8008fde <HAL_RCCEx_PeriphCLKConfig+0x1ce>
      {
        /* Get tick */
        tickstart = HAL_GetTick();
 8008fae:	f7f8 fd0b 	bl	80019c8 <HAL_GetTick>
 8008fb2:	6278      	str	r0, [r7, #36]	; 0x24
        
        /* Wait till LSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8008fb4:	e00a      	b.n	8008fcc <HAL_RCCEx_PeriphCLKConfig+0x1bc>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8008fb6:	f7f8 fd07 	bl	80019c8 <HAL_GetTick>
 8008fba:	4602      	mov	r2, r0
 8008fbc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008fbe:	1ad2      	subs	r2, r2, r3
 8008fc0:	f241 3388 	movw	r3, #5000	; 0x1388
 8008fc4:	429a      	cmp	r2, r3
 8008fc6:	d901      	bls.n	8008fcc <HAL_RCCEx_PeriphCLKConfig+0x1bc>
          {
            return HAL_TIMEOUT;
 8008fc8:	2303      	movs	r3, #3
 8008fca:	e03f      	b.n	800904c <HAL_RCCEx_PeriphCLKConfig+0x23c>
      {
        /* Get tick */
        tickstart = HAL_GetTick();
        
        /* Wait till LSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8008fcc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008fd0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008fd4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008fd6:	f003 0302 	and.w	r3, r3, #2
 8008fda:	2b00      	cmp	r3, #0
 8008fdc:	d0eb      	beq.n	8008fb6 <HAL_RCCEx_PeriphCLKConfig+0x1a6>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection); 
 8008fde:	687b      	ldr	r3, [r7, #4]
 8008fe0:	68db      	ldr	r3, [r3, #12]
 8008fe2:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8008fe6:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8008fea:	d113      	bne.n	8009014 <HAL_RCCEx_PeriphCLKConfig+0x204>
 8008fec:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008ff0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008ff4:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008ff8:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008ffc:	6892      	ldr	r2, [r2, #8]
 8008ffe:	f422 11f8 	bic.w	r1, r2, #2031616	; 0x1f0000
 8009002:	687a      	ldr	r2, [r7, #4]
 8009004:	68d2      	ldr	r2, [r2, #12]
 8009006:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 800900a:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 800900e:	430a      	orrs	r2, r1
 8009010:	609a      	str	r2, [r3, #8]
 8009012:	e00b      	b.n	800902c <HAL_RCCEx_PeriphCLKConfig+0x21c>
 8009014:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009018:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800901c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009020:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009024:	6892      	ldr	r2, [r2, #8]
 8009026:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 800902a:	609a      	str	r2, [r3, #8]
 800902c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009030:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009034:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009038:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800903c:	6f11      	ldr	r1, [r2, #112]	; 0x70
 800903e:	687a      	ldr	r2, [r7, #4]
 8009040:	68d2      	ldr	r2, [r2, #12]
 8009042:	f3c2 020b 	ubfx	r2, r2, #0, #12
 8009046:	430a      	orrs	r2, r1
 8009048:	671a      	str	r2, [r3, #112]	; 0x70
    }
  }

  return HAL_OK;
 800904a:	2300      	movs	r3, #0
}
 800904c:	4618      	mov	r0, r3
 800904e:	3728      	adds	r7, #40	; 0x28
 8009050:	46bd      	mov	sp, r7
 8009052:	bd80      	pop	{r7, pc}

08009054 <HAL_RCCEx_GetPeriphCLKConfig>:
  * @param  PeriphClkInit: pointer to an RCC_PeriphCLKInitTypeDef structure that 
  * will be configured.
  * @retval None
  */
void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8009054:	b480      	push	{r7}
 8009056:	b089      	sub	sp, #36	; 0x24
 8009058:	af00      	add	r7, sp, #0
 800905a:	6078      	str	r0, [r7, #4]
  uint32_t tempreg;
  
  /* Set all possible values for the extended clock type parameter------------*/
  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S | RCC_PERIPHCLK_RTC;
 800905c:	687b      	ldr	r3, [r7, #4]
 800905e:	2203      	movs	r2, #3
 8009060:	601a      	str	r2, [r3, #0]
  
  /* Get the PLLI2S Clock configuration --------------------------------------*/
  PeriphClkInit->PLLI2S.PLLI2SN = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SN));
 8009062:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009066:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800906a:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 800906e:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8009072:	4013      	ands	r3, r2
 8009074:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 8009078:	61ba      	str	r2, [r7, #24]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800907a:	69ba      	ldr	r2, [r7, #24]
 800907c:	fa92 f2a2 	rbit	r2, r2
 8009080:	617a      	str	r2, [r7, #20]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8009082:	697a      	ldr	r2, [r7, #20]
 8009084:	fab2 f282 	clz	r2, r2
 8009088:	fa23 f202 	lsr.w	r2, r3, r2
 800908c:	687b      	ldr	r3, [r7, #4]
 800908e:	605a      	str	r2, [r3, #4]
  PeriphClkInit->PLLI2S.PLLI2SR = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SR));
 8009090:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009094:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009098:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800909c:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
 80090a0:	f04f 43e0 	mov.w	r3, #1879048192	; 0x70000000
 80090a4:	613b      	str	r3, [r7, #16]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80090a6:	693b      	ldr	r3, [r7, #16]
 80090a8:	fa93 f3a3 	rbit	r3, r3
 80090ac:	60fb      	str	r3, [r7, #12]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 80090ae:	68fb      	ldr	r3, [r7, #12]
 80090b0:	fab3 f383 	clz	r3, r3
 80090b4:	40da      	lsrs	r2, r3
 80090b6:	687b      	ldr	r3, [r7, #4]
 80090b8:	609a      	str	r2, [r3, #8]
#if defined(STM32F411xE)
  PeriphClkInit->PLLI2S.PLLI2SM = (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM);
#endif /* STM32F411xE */
  /* Get the RTC Clock configuration -----------------------------------------*/
  tempreg = (RCC->CFGR & RCC_CFGR_RTCPRE);
 80090ba:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80090be:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80090c2:	689b      	ldr	r3, [r3, #8]
 80090c4:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
 80090c8:	61fb      	str	r3, [r7, #28]
  PeriphClkInit->RTCClockSelection = (uint32_t)((tempreg) | (RCC->BDCR & RCC_BDCR_RTCSEL));
 80090ca:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80090ce:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80090d2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80090d4:	f403 7240 	and.w	r2, r3, #768	; 0x300
 80090d8:	69fb      	ldr	r3, [r7, #28]
 80090da:	431a      	orrs	r2, r3
 80090dc:	687b      	ldr	r3, [r7, #4]
 80090de:	60da      	str	r2, [r3, #12]
  
}
 80090e0:	3724      	adds	r7, #36	; 0x24
 80090e2:	46bd      	mov	sp, r7
 80090e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80090e8:	4770      	bx	lr
 80090ea:	bf00      	nop

080090ec <HAL_SPI_Init>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 80090ec:	b580      	push	{r7, lr}
 80090ee:	b082      	sub	sp, #8
 80090f0:	af00      	add	r7, sp, #0
 80090f2:	6078      	str	r0, [r7, #4]
  /* Check the SPI handle allocation */
  if(hspi == NULL)
 80090f4:	687b      	ldr	r3, [r7, #4]
 80090f6:	2b00      	cmp	r3, #0
 80090f8:	d101      	bne.n	80090fe <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 80090fa:	2301      	movs	r3, #1
 80090fc:	e057      	b.n	80091ae <HAL_SPI_Init+0xc2>
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
  assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));

  if(hspi->State == HAL_SPI_STATE_RESET)
 80090fe:	687b      	ldr	r3, [r7, #4]
 8009100:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 8009104:	b2db      	uxtb	r3, r3
 8009106:	2b00      	cmp	r3, #0
 8009108:	d106      	bne.n	8009118 <HAL_SPI_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 800910a:	687b      	ldr	r3, [r7, #4]
 800910c:	2200      	movs	r2, #0
 800910e:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 8009112:	6878      	ldr	r0, [r7, #4]
 8009114:	f7f8 f8ee 	bl	80012f4 <HAL_SPI_MspInit>
  }
  
  hspi->State = HAL_SPI_STATE_BUSY;
 8009118:	687b      	ldr	r3, [r7, #4]
 800911a:	2202      	movs	r2, #2
 800911c:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8009120:	687b      	ldr	r3, [r7, #4]
 8009122:	681b      	ldr	r3, [r3, #0]
 8009124:	687a      	ldr	r2, [r7, #4]
 8009126:	6812      	ldr	r2, [r2, #0]
 8009128:	6812      	ldr	r2, [r2, #0]
 800912a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800912e:	601a      	str	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 8009130:	687b      	ldr	r3, [r7, #4]
 8009132:	681b      	ldr	r3, [r3, #0]
 8009134:	687a      	ldr	r2, [r7, #4]
 8009136:	6851      	ldr	r1, [r2, #4]
 8009138:	687a      	ldr	r2, [r7, #4]
 800913a:	6892      	ldr	r2, [r2, #8]
 800913c:	4311      	orrs	r1, r2
 800913e:	687a      	ldr	r2, [r7, #4]
 8009140:	68d2      	ldr	r2, [r2, #12]
 8009142:	4311      	orrs	r1, r2
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
 8009144:	687a      	ldr	r2, [r7, #4]
 8009146:	6912      	ldr	r2, [r2, #16]
  __HAL_SPI_DISABLE(hspi);

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 8009148:	4311      	orrs	r1, r2
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
 800914a:	687a      	ldr	r2, [r7, #4]
 800914c:	6952      	ldr	r2, [r2, #20]
 800914e:	4311      	orrs	r1, r2
 8009150:	687a      	ldr	r2, [r7, #4]
 8009152:	6992      	ldr	r2, [r2, #24]
 8009154:	f402 7200 	and.w	r2, r2, #512	; 0x200
 8009158:	4311      	orrs	r1, r2
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
 800915a:	687a      	ldr	r2, [r7, #4]
 800915c:	69d2      	ldr	r2, [r2, #28]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
 800915e:	4311      	orrs	r1, r2
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
 8009160:	687a      	ldr	r2, [r7, #4]
 8009162:	6a12      	ldr	r2, [r2, #32]
 8009164:	4311      	orrs	r1, r2
 8009166:	687a      	ldr	r2, [r7, #4]
 8009168:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800916a:	430a      	orrs	r2, r1
  __HAL_SPI_DISABLE(hspi);

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 800916c:	601a      	str	r2, [r3, #0]
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);

  /* Configure : NSS management */
  hspi->Instance->CR2 = (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode);
 800916e:	687b      	ldr	r3, [r7, #4]
 8009170:	681b      	ldr	r3, [r3, #0]
 8009172:	687a      	ldr	r2, [r7, #4]
 8009174:	6992      	ldr	r2, [r2, #24]
 8009176:	0c12      	lsrs	r2, r2, #16
 8009178:	f002 0104 	and.w	r1, r2, #4
 800917c:	687a      	ldr	r2, [r7, #4]
 800917e:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8009180:	430a      	orrs	r2, r1
 8009182:	605a      	str	r2, [r3, #4]

  /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
  /* Configure : CRC Polynomial */
  hspi->Instance->CRCPR = hspi->Init.CRCPolynomial;
 8009184:	687b      	ldr	r3, [r7, #4]
 8009186:	681b      	ldr	r3, [r3, #0]
 8009188:	687a      	ldr	r2, [r7, #4]
 800918a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800918c:	611a      	str	r2, [r3, #16]

  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  hspi->Instance->I2SCFGR &= (uint32_t)(~SPI_I2SCFGR_I2SMOD);
 800918e:	687b      	ldr	r3, [r7, #4]
 8009190:	681b      	ldr	r3, [r3, #0]
 8009192:	687a      	ldr	r2, [r7, #4]
 8009194:	6812      	ldr	r2, [r2, #0]
 8009196:	69d2      	ldr	r2, [r2, #28]
 8009198:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 800919c:	61da      	str	r2, [r3, #28]

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 800919e:	687b      	ldr	r3, [r7, #4]
 80091a0:	2200      	movs	r2, #0
 80091a2:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->State = HAL_SPI_STATE_READY;
 80091a4:	687b      	ldr	r3, [r7, #4]
 80091a6:	2201      	movs	r2, #1
 80091a8:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
  
  return HAL_OK;
 80091ac:	2300      	movs	r3, #0
}
 80091ae:	4618      	mov	r0, r3
 80091b0:	3708      	adds	r7, #8
 80091b2:	46bd      	mov	sp, r7
 80091b4:	bd80      	pop	{r7, pc}
 80091b6:	bf00      	nop

080091b8 <HAL_SPI_DeInit>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
{
 80091b8:	b580      	push	{r7, lr}
 80091ba:	b082      	sub	sp, #8
 80091bc:	af00      	add	r7, sp, #0
 80091be:	6078      	str	r0, [r7, #4]
  /* Check the SPI handle allocation */
  if(hspi == NULL)
 80091c0:	687b      	ldr	r3, [r7, #4]
 80091c2:	2b00      	cmp	r3, #0
 80091c4:	d101      	bne.n	80091ca <HAL_SPI_DeInit+0x12>
  {
    return HAL_ERROR;
 80091c6:	2301      	movs	r3, #1
 80091c8:	e016      	b.n	80091f8 <HAL_SPI_DeInit+0x40>
  }

  /* Disable the SPI Peripheral Clock */
  __HAL_SPI_DISABLE(hspi);
 80091ca:	687b      	ldr	r3, [r7, #4]
 80091cc:	681b      	ldr	r3, [r3, #0]
 80091ce:	687a      	ldr	r2, [r7, #4]
 80091d0:	6812      	ldr	r2, [r2, #0]
 80091d2:	6812      	ldr	r2, [r2, #0]
 80091d4:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80091d8:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
  HAL_SPI_MspDeInit(hspi);
 80091da:	6878      	ldr	r0, [r7, #4]
 80091dc:	f7f8 f8c2 	bl	8001364 <HAL_SPI_MspDeInit>

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80091e0:	687b      	ldr	r3, [r7, #4]
 80091e2:	2200      	movs	r2, #0
 80091e4:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->State = HAL_SPI_STATE_RESET;
 80091e6:	687b      	ldr	r3, [r7, #4]
 80091e8:	2200      	movs	r2, #0
 80091ea:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

  /* Release Lock */
  __HAL_UNLOCK(hspi);
 80091ee:	687b      	ldr	r3, [r7, #4]
 80091f0:	2200      	movs	r2, #0
 80091f2:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  return HAL_OK;
 80091f6:	2300      	movs	r3, #0
}
 80091f8:	4618      	mov	r0, r3
 80091fa:	3708      	adds	r7, #8
 80091fc:	46bd      	mov	sp, r7
 80091fe:	bd80      	pop	{r7, pc}
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval None
  */
 __weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
 {
 8009200:	b480      	push	{r7}
 8009202:	b083      	sub	sp, #12
 8009204:	af00      	add	r7, sp, #0
 8009206:	6078      	str	r0, [r7, #4]
   /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SPI_MspInit could be implemented in the user file
   */
}
 8009208:	370c      	adds	r7, #12
 800920a:	46bd      	mov	sp, r7
 800920c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009210:	4770      	bx	lr
 8009212:	bf00      	nop
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval None
  */
 __weak void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
{
 8009214:	b480      	push	{r7}
 8009216:	b083      	sub	sp, #12
 8009218:	af00      	add	r7, sp, #0
 800921a:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SPI_MspDeInit could be implemented in the user file
   */
}
 800921c:	370c      	adds	r7, #12
 800921e:	46bd      	mov	sp, r7
 8009220:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009224:	4770      	bx	lr
 8009226:	bf00      	nop

08009228 <HAL_SPI_Transmit>:
  * @param  Size: amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8009228:	b580      	push	{r7, lr}
 800922a:	b086      	sub	sp, #24
 800922c:	af00      	add	r7, sp, #0
 800922e:	60f8      	str	r0, [r7, #12]
 8009230:	60b9      	str	r1, [r7, #8]
 8009232:	603b      	str	r3, [r7, #0]
 8009234:	4613      	mov	r3, r2
 8009236:	80fb      	strh	r3, [r7, #6]

  if(hspi->State == HAL_SPI_STATE_READY)
 8009238:	68fb      	ldr	r3, [r7, #12]
 800923a:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 800923e:	b2db      	uxtb	r3, r3
 8009240:	2b01      	cmp	r3, #1
 8009242:	f040 812a 	bne.w	800949a <HAL_SPI_Transmit+0x272>
  {
    if((pData == NULL ) || (Size == 0)) 
 8009246:	68bb      	ldr	r3, [r7, #8]
 8009248:	2b00      	cmp	r3, #0
 800924a:	d002      	beq.n	8009252 <HAL_SPI_Transmit+0x2a>
 800924c:	88fb      	ldrh	r3, [r7, #6]
 800924e:	2b00      	cmp	r3, #0
 8009250:	d101      	bne.n	8009256 <HAL_SPI_Transmit+0x2e>
    {
      return  HAL_ERROR;
 8009252:	2301      	movs	r3, #1
 8009254:	e122      	b.n	800949c <HAL_SPI_Transmit+0x274>

    /* Check the parameters */
    assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

    /* Process Locked */
    __HAL_LOCK(hspi);
 8009256:	68fb      	ldr	r3, [r7, #12]
 8009258:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800925c:	2b01      	cmp	r3, #1
 800925e:	d101      	bne.n	8009264 <HAL_SPI_Transmit+0x3c>
 8009260:	2302      	movs	r3, #2
 8009262:	e11b      	b.n	800949c <HAL_SPI_Transmit+0x274>
 8009264:	68fb      	ldr	r3, [r7, #12]
 8009266:	2201      	movs	r2, #1
 8009268:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    /* Configure communication */
    hspi->State = HAL_SPI_STATE_BUSY_TX;
 800926c:	68fb      	ldr	r3, [r7, #12]
 800926e:	2212      	movs	r2, #18
 8009270:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
    hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8009274:	68fb      	ldr	r3, [r7, #12]
 8009276:	2200      	movs	r2, #0
 8009278:	655a      	str	r2, [r3, #84]	; 0x54

    hspi->pTxBuffPtr = pData;
 800927a:	68fb      	ldr	r3, [r7, #12]
 800927c:	68ba      	ldr	r2, [r7, #8]
 800927e:	631a      	str	r2, [r3, #48]	; 0x30
    hspi->TxXferSize = Size;
 8009280:	68fb      	ldr	r3, [r7, #12]
 8009282:	88fa      	ldrh	r2, [r7, #6]
 8009284:	869a      	strh	r2, [r3, #52]	; 0x34
    hspi->TxXferCount = Size;
 8009286:	68fb      	ldr	r3, [r7, #12]
 8009288:	88fa      	ldrh	r2, [r7, #6]
 800928a:	86da      	strh	r2, [r3, #54]	; 0x36

    /*Init field not used in handle to zero */
    hspi->TxISR = 0;
 800928c:	68fb      	ldr	r3, [r7, #12]
 800928e:	2200      	movs	r2, #0
 8009290:	64da      	str	r2, [r3, #76]	; 0x4c
    hspi->RxISR = 0;
 8009292:	68fb      	ldr	r3, [r7, #12]
 8009294:	2200      	movs	r2, #0
 8009296:	649a      	str	r2, [r3, #72]	; 0x48
    hspi->RxXferSize   = 0;
 8009298:	68fb      	ldr	r3, [r7, #12]
 800929a:	2200      	movs	r2, #0
 800929c:	879a      	strh	r2, [r3, #60]	; 0x3c
    hspi->RxXferCount  = 0;
 800929e:	68fb      	ldr	r3, [r7, #12]
 80092a0:	2200      	movs	r2, #0
 80092a2:	87da      	strh	r2, [r3, #62]	; 0x3e

    /* Reset CRC Calculation */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80092a4:	68fb      	ldr	r3, [r7, #12]
 80092a6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80092a8:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80092ac:	d10f      	bne.n	80092ce <HAL_SPI_Transmit+0xa6>
    {
      SPI_RESET_CRC(hspi);
 80092ae:	68fb      	ldr	r3, [r7, #12]
 80092b0:	681b      	ldr	r3, [r3, #0]
 80092b2:	68fa      	ldr	r2, [r7, #12]
 80092b4:	6812      	ldr	r2, [r2, #0]
 80092b6:	6812      	ldr	r2, [r2, #0]
 80092b8:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80092bc:	601a      	str	r2, [r3, #0]
 80092be:	68fb      	ldr	r3, [r7, #12]
 80092c0:	681b      	ldr	r3, [r3, #0]
 80092c2:	68fa      	ldr	r2, [r7, #12]
 80092c4:	6812      	ldr	r2, [r2, #0]
 80092c6:	6812      	ldr	r2, [r2, #0]
 80092c8:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80092cc:	601a      	str	r2, [r3, #0]
    }

    if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80092ce:	68fb      	ldr	r3, [r7, #12]
 80092d0:	689b      	ldr	r3, [r3, #8]
 80092d2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80092d6:	d107      	bne.n	80092e8 <HAL_SPI_Transmit+0xc0>
    {
      /* Configure communication direction : 1Line */
      SPI_1LINE_TX(hspi);
 80092d8:	68fb      	ldr	r3, [r7, #12]
 80092da:	681b      	ldr	r3, [r3, #0]
 80092dc:	68fa      	ldr	r2, [r7, #12]
 80092de:	6812      	ldr	r2, [r2, #0]
 80092e0:	6812      	ldr	r2, [r2, #0]
 80092e2:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80092e6:	601a      	str	r2, [r3, #0]
    }

    /* Check if the SPI is already enabled */ 
    if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 80092e8:	68fb      	ldr	r3, [r7, #12]
 80092ea:	681b      	ldr	r3, [r3, #0]
 80092ec:	681b      	ldr	r3, [r3, #0]
 80092ee:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80092f2:	2b00      	cmp	r3, #0
 80092f4:	d107      	bne.n	8009306 <HAL_SPI_Transmit+0xde>
    {
      /* Enable SPI peripheral */
      __HAL_SPI_ENABLE(hspi);
 80092f6:	68fb      	ldr	r3, [r7, #12]
 80092f8:	681b      	ldr	r3, [r3, #0]
 80092fa:	68fa      	ldr	r2, [r7, #12]
 80092fc:	6812      	ldr	r2, [r2, #0]
 80092fe:	6812      	ldr	r2, [r2, #0]
 8009300:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8009304:	601a      	str	r2, [r3, #0]
    }

    /* Transmit data in 8 Bit mode */
    if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
 8009306:	68fb      	ldr	r3, [r7, #12]
 8009308:	68db      	ldr	r3, [r3, #12]
 800930a:	2b00      	cmp	r3, #0
 800930c:	d144      	bne.n	8009398 <HAL_SPI_Transmit+0x170>
    {
      if((hspi->Init.Mode == SPI_MODE_SLAVE)|| (hspi->TxXferCount == 0x01))
 800930e:	68fb      	ldr	r3, [r7, #12]
 8009310:	685b      	ldr	r3, [r3, #4]
 8009312:	2b00      	cmp	r3, #0
 8009314:	d003      	beq.n	800931e <HAL_SPI_Transmit+0xf6>
 8009316:	68fb      	ldr	r3, [r7, #12]
 8009318:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800931a:	2b01      	cmp	r3, #1
 800931c:	d10f      	bne.n	800933e <HAL_SPI_Transmit+0x116>
      {
        hspi->Instance->DR = (*hspi->pTxBuffPtr++);
 800931e:	68fb      	ldr	r3, [r7, #12]
 8009320:	681a      	ldr	r2, [r3, #0]
 8009322:	68fb      	ldr	r3, [r7, #12]
 8009324:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009326:	1c58      	adds	r0, r3, #1
 8009328:	68f9      	ldr	r1, [r7, #12]
 800932a:	6308      	str	r0, [r1, #48]	; 0x30
 800932c:	781b      	ldrb	r3, [r3, #0]
 800932e:	60d3      	str	r3, [r2, #12]
        hspi->TxXferCount--;
 8009330:	68fb      	ldr	r3, [r7, #12]
 8009332:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8009334:	3b01      	subs	r3, #1
 8009336:	b29a      	uxth	r2, r3
 8009338:	68fb      	ldr	r3, [r7, #12]
 800933a:	86da      	strh	r2, [r3, #54]	; 0x36
      }
      while(hspi->TxXferCount > 0)
 800933c:	e01a      	b.n	8009374 <HAL_SPI_Transmit+0x14c>
 800933e:	e019      	b.n	8009374 <HAL_SPI_Transmit+0x14c>
      {
        /* Wait until TXE flag is set to send data */
        if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
 8009340:	68f8      	ldr	r0, [r7, #12]
 8009342:	2102      	movs	r1, #2
 8009344:	2200      	movs	r2, #0
 8009346:	683b      	ldr	r3, [r7, #0]
 8009348:	f001 fdc6 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 800934c:	4603      	mov	r3, r0
 800934e:	2b00      	cmp	r3, #0
 8009350:	d001      	beq.n	8009356 <HAL_SPI_Transmit+0x12e>
        { 
          return HAL_TIMEOUT;
 8009352:	2303      	movs	r3, #3
 8009354:	e0a2      	b.n	800949c <HAL_SPI_Transmit+0x274>
        }
        hspi->Instance->DR = (*hspi->pTxBuffPtr++);
 8009356:	68fb      	ldr	r3, [r7, #12]
 8009358:	681a      	ldr	r2, [r3, #0]
 800935a:	68fb      	ldr	r3, [r7, #12]
 800935c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800935e:	1c58      	adds	r0, r3, #1
 8009360:	68f9      	ldr	r1, [r7, #12]
 8009362:	6308      	str	r0, [r1, #48]	; 0x30
 8009364:	781b      	ldrb	r3, [r3, #0]
 8009366:	60d3      	str	r3, [r2, #12]
        hspi->TxXferCount--;
 8009368:	68fb      	ldr	r3, [r7, #12]
 800936a:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800936c:	3b01      	subs	r3, #1
 800936e:	b29a      	uxth	r2, r3
 8009370:	68fb      	ldr	r3, [r7, #12]
 8009372:	86da      	strh	r2, [r3, #54]	; 0x36
      if((hspi->Init.Mode == SPI_MODE_SLAVE)|| (hspi->TxXferCount == 0x01))
      {
        hspi->Instance->DR = (*hspi->pTxBuffPtr++);
        hspi->TxXferCount--;
      }
      while(hspi->TxXferCount > 0)
 8009374:	68fb      	ldr	r3, [r7, #12]
 8009376:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8009378:	2b00      	cmp	r3, #0
 800937a:	d1e1      	bne.n	8009340 <HAL_SPI_Transmit+0x118>
        }
        hspi->Instance->DR = (*hspi->pTxBuffPtr++);
        hspi->TxXferCount--;
      }
      /* Enable CRC Transmission */
      if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) 
 800937c:	68fb      	ldr	r3, [r7, #12]
 800937e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009380:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009384:	d150      	bne.n	8009428 <HAL_SPI_Transmit+0x200>
      {
        hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 8009386:	68fb      	ldr	r3, [r7, #12]
 8009388:	681b      	ldr	r3, [r3, #0]
 800938a:	68fa      	ldr	r2, [r7, #12]
 800938c:	6812      	ldr	r2, [r2, #0]
 800938e:	6812      	ldr	r2, [r2, #0]
 8009390:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8009394:	601a      	str	r2, [r3, #0]
 8009396:	e047      	b.n	8009428 <HAL_SPI_Transmit+0x200>
      }
    }
    /* Transmit data in 16 Bit mode */
    else
    {
      if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01))
 8009398:	68fb      	ldr	r3, [r7, #12]
 800939a:	685b      	ldr	r3, [r3, #4]
 800939c:	2b00      	cmp	r3, #0
 800939e:	d003      	beq.n	80093a8 <HAL_SPI_Transmit+0x180>
 80093a0:	68fb      	ldr	r3, [r7, #12]
 80093a2:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 80093a4:	2b01      	cmp	r3, #1
 80093a6:	d111      	bne.n	80093cc <HAL_SPI_Transmit+0x1a4>
      {
        hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
 80093a8:	68fb      	ldr	r3, [r7, #12]
 80093aa:	681b      	ldr	r3, [r3, #0]
 80093ac:	68fa      	ldr	r2, [r7, #12]
 80093ae:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80093b0:	8812      	ldrh	r2, [r2, #0]
 80093b2:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr+=2;
 80093b4:	68fb      	ldr	r3, [r7, #12]
 80093b6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80093b8:	1c9a      	adds	r2, r3, #2
 80093ba:	68fb      	ldr	r3, [r7, #12]
 80093bc:	631a      	str	r2, [r3, #48]	; 0x30
        hspi->TxXferCount--;
 80093be:	68fb      	ldr	r3, [r7, #12]
 80093c0:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 80093c2:	3b01      	subs	r3, #1
 80093c4:	b29a      	uxth	r2, r3
 80093c6:	68fb      	ldr	r3, [r7, #12]
 80093c8:	86da      	strh	r2, [r3, #54]	; 0x36
      }
      while(hspi->TxXferCount > 0)
 80093ca:	e01c      	b.n	8009406 <HAL_SPI_Transmit+0x1de>
 80093cc:	e01b      	b.n	8009406 <HAL_SPI_Transmit+0x1de>
      {
        /* Wait until TXE flag is set to send data */
        if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
 80093ce:	68f8      	ldr	r0, [r7, #12]
 80093d0:	2102      	movs	r1, #2
 80093d2:	2200      	movs	r2, #0
 80093d4:	683b      	ldr	r3, [r7, #0]
 80093d6:	f001 fd7f 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 80093da:	4603      	mov	r3, r0
 80093dc:	2b00      	cmp	r3, #0
 80093de:	d001      	beq.n	80093e4 <HAL_SPI_Transmit+0x1bc>
        { 
          return HAL_TIMEOUT;
 80093e0:	2303      	movs	r3, #3
 80093e2:	e05b      	b.n	800949c <HAL_SPI_Transmit+0x274>
        }
        hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
 80093e4:	68fb      	ldr	r3, [r7, #12]
 80093e6:	681b      	ldr	r3, [r3, #0]
 80093e8:	68fa      	ldr	r2, [r7, #12]
 80093ea:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80093ec:	8812      	ldrh	r2, [r2, #0]
 80093ee:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr+=2;
 80093f0:	68fb      	ldr	r3, [r7, #12]
 80093f2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80093f4:	1c9a      	adds	r2, r3, #2
 80093f6:	68fb      	ldr	r3, [r7, #12]
 80093f8:	631a      	str	r2, [r3, #48]	; 0x30
        hspi->TxXferCount--;
 80093fa:	68fb      	ldr	r3, [r7, #12]
 80093fc:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 80093fe:	3b01      	subs	r3, #1
 8009400:	b29a      	uxth	r2, r3
 8009402:	68fb      	ldr	r3, [r7, #12]
 8009404:	86da      	strh	r2, [r3, #54]	; 0x36
      {
        hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
        hspi->pTxBuffPtr+=2;
        hspi->TxXferCount--;
      }
      while(hspi->TxXferCount > 0)
 8009406:	68fb      	ldr	r3, [r7, #12]
 8009408:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800940a:	2b00      	cmp	r3, #0
 800940c:	d1df      	bne.n	80093ce <HAL_SPI_Transmit+0x1a6>
        hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
        hspi->pTxBuffPtr+=2;
        hspi->TxXferCount--;
      }
      /* Enable CRC Transmission */
      if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) 
 800940e:	68fb      	ldr	r3, [r7, #12]
 8009410:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009412:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009416:	d107      	bne.n	8009428 <HAL_SPI_Transmit+0x200>
      {
        hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 8009418:	68fb      	ldr	r3, [r7, #12]
 800941a:	681b      	ldr	r3, [r3, #0]
 800941c:	68fa      	ldr	r2, [r7, #12]
 800941e:	6812      	ldr	r2, [r2, #0]
 8009420:	6812      	ldr	r2, [r2, #0]
 8009422:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8009426:	601a      	str	r2, [r3, #0]
      }
    }

    /* Wait until TXE flag is set to send data */
    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
 8009428:	68f8      	ldr	r0, [r7, #12]
 800942a:	2102      	movs	r1, #2
 800942c:	2200      	movs	r2, #0
 800942e:	683b      	ldr	r3, [r7, #0]
 8009430:	f001 fd52 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 8009434:	4603      	mov	r3, r0
 8009436:	2b00      	cmp	r3, #0
 8009438:	d007      	beq.n	800944a <HAL_SPI_Transmit+0x222>
    {
      hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 800943a:	68fb      	ldr	r3, [r7, #12]
 800943c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800943e:	f043 0220 	orr.w	r2, r3, #32
 8009442:	68fb      	ldr	r3, [r7, #12]
 8009444:	655a      	str	r2, [r3, #84]	; 0x54
      return HAL_TIMEOUT;
 8009446:	2303      	movs	r3, #3
 8009448:	e028      	b.n	800949c <HAL_SPI_Transmit+0x274>
    }

    /* Wait until Busy flag is reset before disabling SPI */
    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, Timeout) != HAL_OK)
 800944a:	68f8      	ldr	r0, [r7, #12]
 800944c:	2180      	movs	r1, #128	; 0x80
 800944e:	2201      	movs	r2, #1
 8009450:	683b      	ldr	r3, [r7, #0]
 8009452:	f001 fd41 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 8009456:	4603      	mov	r3, r0
 8009458:	2b00      	cmp	r3, #0
 800945a:	d007      	beq.n	800946c <HAL_SPI_Transmit+0x244>
    { 
      hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 800945c:	68fb      	ldr	r3, [r7, #12]
 800945e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009460:	f043 0220 	orr.w	r2, r3, #32
 8009464:	68fb      	ldr	r3, [r7, #12]
 8009466:	655a      	str	r2, [r3, #84]	; 0x54
      return HAL_TIMEOUT;
 8009468:	2303      	movs	r3, #3
 800946a:	e017      	b.n	800949c <HAL_SPI_Transmit+0x274>
    }
 
    /* Clear OVERRUN flag in 2 Lines communication mode because received is not read */
    if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
 800946c:	68fb      	ldr	r3, [r7, #12]
 800946e:	689b      	ldr	r3, [r3, #8]
 8009470:	2b00      	cmp	r3, #0
 8009472:	d108      	bne.n	8009486 <HAL_SPI_Transmit+0x25e>
    {
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8009474:	68fb      	ldr	r3, [r7, #12]
 8009476:	681b      	ldr	r3, [r3, #0]
 8009478:	68db      	ldr	r3, [r3, #12]
 800947a:	617b      	str	r3, [r7, #20]
 800947c:	68fb      	ldr	r3, [r7, #12]
 800947e:	681b      	ldr	r3, [r3, #0]
 8009480:	689b      	ldr	r3, [r3, #8]
 8009482:	617b      	str	r3, [r7, #20]
 8009484:	697b      	ldr	r3, [r7, #20]
    }

    hspi->State = HAL_SPI_STATE_READY; 
 8009486:	68fb      	ldr	r3, [r7, #12]
 8009488:	2201      	movs	r2, #1
 800948a:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

    /* Process Unlocked */
    __HAL_UNLOCK(hspi);
 800948e:	68fb      	ldr	r3, [r7, #12]
 8009490:	2200      	movs	r2, #0
 8009492:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    return HAL_OK;
 8009496:	2300      	movs	r3, #0
 8009498:	e000      	b.n	800949c <HAL_SPI_Transmit+0x274>
  }
  else
  {
    return HAL_BUSY;
 800949a:	2302      	movs	r3, #2
  }
}
 800949c:	4618      	mov	r0, r3
 800949e:	3718      	adds	r7, #24
 80094a0:	46bd      	mov	sp, r7
 80094a2:	bd80      	pop	{r7, pc}

080094a4 <HAL_SPI_Receive>:
  * @param  Size: amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80094a4:	b580      	push	{r7, lr}
 80094a6:	b088      	sub	sp, #32
 80094a8:	af02      	add	r7, sp, #8
 80094aa:	60f8      	str	r0, [r7, #12]
 80094ac:	60b9      	str	r1, [r7, #8]
 80094ae:	603b      	str	r3, [r7, #0]
 80094b0:	4613      	mov	r3, r2
 80094b2:	80fb      	strh	r3, [r7, #6]
  __IO uint16_t tmpreg;
  uint32_t tmp = 0;
 80094b4:	2300      	movs	r3, #0
 80094b6:	617b      	str	r3, [r7, #20]

  if(hspi->State == HAL_SPI_STATE_READY)
 80094b8:	68fb      	ldr	r3, [r7, #12]
 80094ba:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 80094be:	b2db      	uxtb	r3, r3
 80094c0:	2b01      	cmp	r3, #1
 80094c2:	f040 8170 	bne.w	80097a6 <HAL_SPI_Receive+0x302>
  {
    if((pData == NULL ) || (Size == 0)) 
 80094c6:	68bb      	ldr	r3, [r7, #8]
 80094c8:	2b00      	cmp	r3, #0
 80094ca:	d002      	beq.n	80094d2 <HAL_SPI_Receive+0x2e>
 80094cc:	88fb      	ldrh	r3, [r7, #6]
 80094ce:	2b00      	cmp	r3, #0
 80094d0:	d101      	bne.n	80094d6 <HAL_SPI_Receive+0x32>
    {
      return  HAL_ERROR;
 80094d2:	2301      	movs	r3, #1
 80094d4:	e168      	b.n	80097a8 <HAL_SPI_Receive+0x304>
    }

    /* Process Locked */
    __HAL_LOCK(hspi);
 80094d6:	68fb      	ldr	r3, [r7, #12]
 80094d8:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 80094dc:	2b01      	cmp	r3, #1
 80094de:	d101      	bne.n	80094e4 <HAL_SPI_Receive+0x40>
 80094e0:	2302      	movs	r3, #2
 80094e2:	e161      	b.n	80097a8 <HAL_SPI_Receive+0x304>
 80094e4:	68fb      	ldr	r3, [r7, #12]
 80094e6:	2201      	movs	r2, #1
 80094e8:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    /* Configure communication */
    hspi->State       = HAL_SPI_STATE_BUSY_RX;
 80094ec:	68fb      	ldr	r3, [r7, #12]
 80094ee:	2222      	movs	r2, #34	; 0x22
 80094f0:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
    hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80094f4:	68fb      	ldr	r3, [r7, #12]
 80094f6:	2200      	movs	r2, #0
 80094f8:	655a      	str	r2, [r3, #84]	; 0x54

    hspi->pRxBuffPtr  = pData;
 80094fa:	68fb      	ldr	r3, [r7, #12]
 80094fc:	68ba      	ldr	r2, [r7, #8]
 80094fe:	639a      	str	r2, [r3, #56]	; 0x38
    hspi->RxXferSize  = Size;
 8009500:	68fb      	ldr	r3, [r7, #12]
 8009502:	88fa      	ldrh	r2, [r7, #6]
 8009504:	879a      	strh	r2, [r3, #60]	; 0x3c
    hspi->RxXferCount = Size;
 8009506:	68fb      	ldr	r3, [r7, #12]
 8009508:	88fa      	ldrh	r2, [r7, #6]
 800950a:	87da      	strh	r2, [r3, #62]	; 0x3e

    /*Init field not used in handle to zero */
    hspi->RxISR = 0;
 800950c:	68fb      	ldr	r3, [r7, #12]
 800950e:	2200      	movs	r2, #0
 8009510:	649a      	str	r2, [r3, #72]	; 0x48
    hspi->TxISR = 0;
 8009512:	68fb      	ldr	r3, [r7, #12]
 8009514:	2200      	movs	r2, #0
 8009516:	64da      	str	r2, [r3, #76]	; 0x4c
    hspi->TxXferSize   = 0;
 8009518:	68fb      	ldr	r3, [r7, #12]
 800951a:	2200      	movs	r2, #0
 800951c:	869a      	strh	r2, [r3, #52]	; 0x34
    hspi->TxXferCount  = 0;
 800951e:	68fb      	ldr	r3, [r7, #12]
 8009520:	2200      	movs	r2, #0
 8009522:	86da      	strh	r2, [r3, #54]	; 0x36

    /* Configure communication direction : 1Line */
    if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8009524:	68fb      	ldr	r3, [r7, #12]
 8009526:	689b      	ldr	r3, [r3, #8]
 8009528:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800952c:	d107      	bne.n	800953e <HAL_SPI_Receive+0x9a>
    {
      SPI_1LINE_RX(hspi);
 800952e:	68fb      	ldr	r3, [r7, #12]
 8009530:	681b      	ldr	r3, [r3, #0]
 8009532:	68fa      	ldr	r2, [r7, #12]
 8009534:	6812      	ldr	r2, [r2, #0]
 8009536:	6812      	ldr	r2, [r2, #0]
 8009538:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800953c:	601a      	str	r2, [r3, #0]
    }

    /* Reset CRC Calculation */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800953e:	68fb      	ldr	r3, [r7, #12]
 8009540:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009542:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009546:	d10f      	bne.n	8009568 <HAL_SPI_Receive+0xc4>
    {
      SPI_RESET_CRC(hspi);
 8009548:	68fb      	ldr	r3, [r7, #12]
 800954a:	681b      	ldr	r3, [r3, #0]
 800954c:	68fa      	ldr	r2, [r7, #12]
 800954e:	6812      	ldr	r2, [r2, #0]
 8009550:	6812      	ldr	r2, [r2, #0]
 8009552:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8009556:	601a      	str	r2, [r3, #0]
 8009558:	68fb      	ldr	r3, [r7, #12]
 800955a:	681b      	ldr	r3, [r3, #0]
 800955c:	68fa      	ldr	r2, [r7, #12]
 800955e:	6812      	ldr	r2, [r2, #0]
 8009560:	6812      	ldr	r2, [r2, #0]
 8009562:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8009566:	601a      	str	r2, [r3, #0]
    }
    
    if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 8009568:	68fb      	ldr	r3, [r7, #12]
 800956a:	685b      	ldr	r3, [r3, #4]
 800956c:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8009570:	d111      	bne.n	8009596 <HAL_SPI_Receive+0xf2>
 8009572:	68fb      	ldr	r3, [r7, #12]
 8009574:	689b      	ldr	r3, [r3, #8]
 8009576:	2b00      	cmp	r3, #0
 8009578:	d10d      	bne.n	8009596 <HAL_SPI_Receive+0xf2>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hspi);
 800957a:	68fb      	ldr	r3, [r7, #12]
 800957c:	2200      	movs	r2, #0
 800957e:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

      /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
      return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
 8009582:	88fb      	ldrh	r3, [r7, #6]
 8009584:	683a      	ldr	r2, [r7, #0]
 8009586:	9200      	str	r2, [sp, #0]
 8009588:	68f8      	ldr	r0, [r7, #12]
 800958a:	68b9      	ldr	r1, [r7, #8]
 800958c:	68ba      	ldr	r2, [r7, #8]
 800958e:	f000 f90f 	bl	80097b0 <HAL_SPI_TransmitReceive>
 8009592:	4603      	mov	r3, r0
 8009594:	e108      	b.n	80097a8 <HAL_SPI_Receive+0x304>
    }

    /* Check if the SPI is already enabled */ 
    if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 8009596:	68fb      	ldr	r3, [r7, #12]
 8009598:	681b      	ldr	r3, [r3, #0]
 800959a:	681b      	ldr	r3, [r3, #0]
 800959c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80095a0:	2b00      	cmp	r3, #0
 80095a2:	d107      	bne.n	80095b4 <HAL_SPI_Receive+0x110>
    {
      /* Enable SPI peripheral */
      __HAL_SPI_ENABLE(hspi);
 80095a4:	68fb      	ldr	r3, [r7, #12]
 80095a6:	681b      	ldr	r3, [r3, #0]
 80095a8:	68fa      	ldr	r2, [r7, #12]
 80095aa:	6812      	ldr	r2, [r2, #0]
 80095ac:	6812      	ldr	r2, [r2, #0]
 80095ae:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80095b2:	601a      	str	r2, [r3, #0]
    }

    /* Receive data in 8 Bit mode */
    if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
 80095b4:	68fb      	ldr	r3, [r7, #12]
 80095b6:	68db      	ldr	r3, [r3, #12]
 80095b8:	2b00      	cmp	r3, #0
 80095ba:	d12d      	bne.n	8009618 <HAL_SPI_Receive+0x174>
    {
      while(hspi->RxXferCount > 1)
 80095bc:	e01a      	b.n	80095f4 <HAL_SPI_Receive+0x150>
      {
        /* Wait until RXNE flag is set */
        if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 80095be:	68f8      	ldr	r0, [r7, #12]
 80095c0:	2101      	movs	r1, #1
 80095c2:	2200      	movs	r2, #0
 80095c4:	683b      	ldr	r3, [r7, #0]
 80095c6:	f001 fc87 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 80095ca:	4603      	mov	r3, r0
 80095cc:	2b00      	cmp	r3, #0
 80095ce:	d001      	beq.n	80095d4 <HAL_SPI_Receive+0x130>
        { 
          return HAL_TIMEOUT;
 80095d0:	2303      	movs	r3, #3
 80095d2:	e0e9      	b.n	80097a8 <HAL_SPI_Receive+0x304>
        }

        (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
 80095d4:	68fb      	ldr	r3, [r7, #12]
 80095d6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80095d8:	1c59      	adds	r1, r3, #1
 80095da:	68fa      	ldr	r2, [r7, #12]
 80095dc:	6391      	str	r1, [r2, #56]	; 0x38
 80095de:	68fa      	ldr	r2, [r7, #12]
 80095e0:	6812      	ldr	r2, [r2, #0]
 80095e2:	68d2      	ldr	r2, [r2, #12]
 80095e4:	b2d2      	uxtb	r2, r2
 80095e6:	701a      	strb	r2, [r3, #0]
        hspi->RxXferCount--;
 80095e8:	68fb      	ldr	r3, [r7, #12]
 80095ea:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 80095ec:	3b01      	subs	r3, #1
 80095ee:	b29a      	uxth	r2, r3
 80095f0:	68fb      	ldr	r3, [r7, #12]
 80095f2:	87da      	strh	r2, [r3, #62]	; 0x3e
    }

    /* Receive data in 8 Bit mode */
    if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
    {
      while(hspi->RxXferCount > 1)
 80095f4:	68fb      	ldr	r3, [r7, #12]
 80095f6:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 80095f8:	2b01      	cmp	r3, #1
 80095fa:	d8e0      	bhi.n	80095be <HAL_SPI_Receive+0x11a>

        (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
        hspi->RxXferCount--;
      }
      /* Enable CRC Transmission */
      if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) 
 80095fc:	68fb      	ldr	r3, [r7, #12]
 80095fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009600:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009604:	d137      	bne.n	8009676 <HAL_SPI_Receive+0x1d2>
      {
        hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 8009606:	68fb      	ldr	r3, [r7, #12]
 8009608:	681b      	ldr	r3, [r3, #0]
 800960a:	68fa      	ldr	r2, [r7, #12]
 800960c:	6812      	ldr	r2, [r2, #0]
 800960e:	6812      	ldr	r2, [r2, #0]
 8009610:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8009614:	601a      	str	r2, [r3, #0]
 8009616:	e02e      	b.n	8009676 <HAL_SPI_Receive+0x1d2>
      }
    }
    /* Receive data in 16 Bit mode */
    else
    {
      while(hspi->RxXferCount > 1)
 8009618:	e01c      	b.n	8009654 <HAL_SPI_Receive+0x1b0>
      {
        /* Wait until RXNE flag is set to read data */
        if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 800961a:	68f8      	ldr	r0, [r7, #12]
 800961c:	2101      	movs	r1, #1
 800961e:	2200      	movs	r2, #0
 8009620:	683b      	ldr	r3, [r7, #0]
 8009622:	f001 fc59 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 8009626:	4603      	mov	r3, r0
 8009628:	2b00      	cmp	r3, #0
 800962a:	d001      	beq.n	8009630 <HAL_SPI_Receive+0x18c>
        { 
          return HAL_TIMEOUT;
 800962c:	2303      	movs	r3, #3
 800962e:	e0bb      	b.n	80097a8 <HAL_SPI_Receive+0x304>
        }

        *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 8009630:	68fb      	ldr	r3, [r7, #12]
 8009632:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009634:	68fa      	ldr	r2, [r7, #12]
 8009636:	6812      	ldr	r2, [r2, #0]
 8009638:	68d2      	ldr	r2, [r2, #12]
 800963a:	b292      	uxth	r2, r2
 800963c:	801a      	strh	r2, [r3, #0]
        hspi->pRxBuffPtr+=2;
 800963e:	68fb      	ldr	r3, [r7, #12]
 8009640:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009642:	1c9a      	adds	r2, r3, #2
 8009644:	68fb      	ldr	r3, [r7, #12]
 8009646:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->RxXferCount--;
 8009648:	68fb      	ldr	r3, [r7, #12]
 800964a:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800964c:	3b01      	subs	r3, #1
 800964e:	b29a      	uxth	r2, r3
 8009650:	68fb      	ldr	r3, [r7, #12]
 8009652:	87da      	strh	r2, [r3, #62]	; 0x3e
      }
    }
    /* Receive data in 16 Bit mode */
    else
    {
      while(hspi->RxXferCount > 1)
 8009654:	68fb      	ldr	r3, [r7, #12]
 8009656:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8009658:	2b01      	cmp	r3, #1
 800965a:	d8de      	bhi.n	800961a <HAL_SPI_Receive+0x176>
        *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
        hspi->pRxBuffPtr+=2;
        hspi->RxXferCount--;
      }
      /* Enable CRC Transmission */
      if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) 
 800965c:	68fb      	ldr	r3, [r7, #12]
 800965e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009660:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009664:	d107      	bne.n	8009676 <HAL_SPI_Receive+0x1d2>
      {
        hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 8009666:	68fb      	ldr	r3, [r7, #12]
 8009668:	681b      	ldr	r3, [r3, #0]
 800966a:	68fa      	ldr	r2, [r7, #12]
 800966c:	6812      	ldr	r2, [r2, #0]
 800966e:	6812      	ldr	r2, [r2, #0]
 8009670:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8009674:	601a      	str	r2, [r3, #0]
      }
    }

    /* Wait until RXNE flag is set */
    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8009676:	68f8      	ldr	r0, [r7, #12]
 8009678:	2101      	movs	r1, #1
 800967a:	2200      	movs	r2, #0
 800967c:	683b      	ldr	r3, [r7, #0]
 800967e:	f001 fc2b 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 8009682:	4603      	mov	r3, r0
 8009684:	2b00      	cmp	r3, #0
 8009686:	d001      	beq.n	800968c <HAL_SPI_Receive+0x1e8>
    { 
      return HAL_TIMEOUT;
 8009688:	2303      	movs	r3, #3
 800968a:	e08d      	b.n	80097a8 <HAL_SPI_Receive+0x304>
    }

    /* Receive last data in 8 Bit mode */
    if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
 800968c:	68fb      	ldr	r3, [r7, #12]
 800968e:	68db      	ldr	r3, [r3, #12]
 8009690:	2b00      	cmp	r3, #0
 8009692:	d10a      	bne.n	80096aa <HAL_SPI_Receive+0x206>
    {
      (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
 8009694:	68fb      	ldr	r3, [r7, #12]
 8009696:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009698:	1c59      	adds	r1, r3, #1
 800969a:	68fa      	ldr	r2, [r7, #12]
 800969c:	6391      	str	r1, [r2, #56]	; 0x38
 800969e:	68fa      	ldr	r2, [r7, #12]
 80096a0:	6812      	ldr	r2, [r2, #0]
 80096a2:	68d2      	ldr	r2, [r2, #12]
 80096a4:	b2d2      	uxtb	r2, r2
 80096a6:	701a      	strb	r2, [r3, #0]
 80096a8:	e00b      	b.n	80096c2 <HAL_SPI_Receive+0x21e>
    }
    /* Receive last data in 16 Bit mode */
    else
    {
      *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 80096aa:	68fb      	ldr	r3, [r7, #12]
 80096ac:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80096ae:	68fa      	ldr	r2, [r7, #12]
 80096b0:	6812      	ldr	r2, [r2, #0]
 80096b2:	68d2      	ldr	r2, [r2, #12]
 80096b4:	b292      	uxth	r2, r2
 80096b6:	801a      	strh	r2, [r3, #0]
      hspi->pRxBuffPtr+=2;
 80096b8:	68fb      	ldr	r3, [r7, #12]
 80096ba:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80096bc:	1c9a      	adds	r2, r3, #2
 80096be:	68fb      	ldr	r3, [r7, #12]
 80096c0:	639a      	str	r2, [r3, #56]	; 0x38
    }
    hspi->RxXferCount--;
 80096c2:	68fb      	ldr	r3, [r7, #12]
 80096c4:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 80096c6:	3b01      	subs	r3, #1
 80096c8:	b29a      	uxth	r2, r3
 80096ca:	68fb      	ldr	r3, [r7, #12]
 80096cc:	87da      	strh	r2, [r3, #62]	; 0x3e

    /* Wait until RXNE flag is set: CRC Received */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80096ce:	68fb      	ldr	r3, [r7, #12]
 80096d0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80096d2:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80096d6:	d116      	bne.n	8009706 <HAL_SPI_Receive+0x262>
    {
      if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 80096d8:	68f8      	ldr	r0, [r7, #12]
 80096da:	2101      	movs	r1, #1
 80096dc:	2200      	movs	r2, #0
 80096de:	683b      	ldr	r3, [r7, #0]
 80096e0:	f001 fbfa 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 80096e4:	4603      	mov	r3, r0
 80096e6:	2b00      	cmp	r3, #0
 80096e8:	d007      	beq.n	80096fa <HAL_SPI_Receive+0x256>
      {
        hspi->ErrorCode |= HAL_SPI_ERROR_CRC;
 80096ea:	68fb      	ldr	r3, [r7, #12]
 80096ec:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80096ee:	f043 0202 	orr.w	r2, r3, #2
 80096f2:	68fb      	ldr	r3, [r7, #12]
 80096f4:	655a      	str	r2, [r3, #84]	; 0x54
        return HAL_TIMEOUT;
 80096f6:	2303      	movs	r3, #3
 80096f8:	e056      	b.n	80097a8 <HAL_SPI_Receive+0x304>
      }

      /* Read CRC to Flush RXNE flag */
      tmpreg = hspi->Instance->DR;
 80096fa:	68fb      	ldr	r3, [r7, #12]
 80096fc:	681b      	ldr	r3, [r3, #0]
 80096fe:	68db      	ldr	r3, [r3, #12]
 8009700:	b29b      	uxth	r3, r3
 8009702:	827b      	strh	r3, [r7, #18]
      UNUSED(tmpreg);
 8009704:	8a7b      	ldrh	r3, [r7, #18]
    }
    
    if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8009706:	68fb      	ldr	r3, [r7, #12]
 8009708:	685b      	ldr	r3, [r3, #4]
 800970a:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 800970e:	d111      	bne.n	8009734 <HAL_SPI_Receive+0x290>
 8009710:	68fb      	ldr	r3, [r7, #12]
 8009712:	689b      	ldr	r3, [r3, #8]
 8009714:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8009718:	d004      	beq.n	8009724 <HAL_SPI_Receive+0x280>
 800971a:	68fb      	ldr	r3, [r7, #12]
 800971c:	689b      	ldr	r3, [r3, #8]
 800971e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8009722:	d107      	bne.n	8009734 <HAL_SPI_Receive+0x290>
    {
      /* Disable SPI peripheral */
      __HAL_SPI_DISABLE(hspi);
 8009724:	68fb      	ldr	r3, [r7, #12]
 8009726:	681b      	ldr	r3, [r3, #0]
 8009728:	68fa      	ldr	r2, [r7, #12]
 800972a:	6812      	ldr	r2, [r2, #0]
 800972c:	6812      	ldr	r2, [r2, #0]
 800972e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8009732:	601a      	str	r2, [r3, #0]
    }

    hspi->State = HAL_SPI_STATE_READY;
 8009734:	68fb      	ldr	r3, [r7, #12]
 8009736:	2201      	movs	r2, #1
 8009738:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

    tmp = __HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR);
 800973c:	68fb      	ldr	r3, [r7, #12]
 800973e:	681b      	ldr	r3, [r3, #0]
 8009740:	689b      	ldr	r3, [r3, #8]
 8009742:	f003 0310 	and.w	r3, r3, #16
 8009746:	2b00      	cmp	r3, #0
 8009748:	bf0c      	ite	eq
 800974a:	2300      	moveq	r3, #0
 800974c:	2301      	movne	r3, #1
 800974e:	b2db      	uxtb	r3, r3
 8009750:	617b      	str	r3, [r7, #20]
    /* Check if CRC error occurred */
    if((hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) && (tmp != RESET))
 8009752:	68fb      	ldr	r3, [r7, #12]
 8009754:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009756:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800975a:	d11e      	bne.n	800979a <HAL_SPI_Receive+0x2f6>
 800975c:	697b      	ldr	r3, [r7, #20]
 800975e:	2b00      	cmp	r3, #0
 8009760:	d01b      	beq.n	800979a <HAL_SPI_Receive+0x2f6>
    {  
      hspi->ErrorCode |= HAL_SPI_ERROR_CRC;
 8009762:	68fb      	ldr	r3, [r7, #12]
 8009764:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009766:	f043 0202 	orr.w	r2, r3, #2
 800976a:	68fb      	ldr	r3, [r7, #12]
 800976c:	655a      	str	r2, [r3, #84]	; 0x54

      /* Reset CRC Calculation */
      SPI_RESET_CRC(hspi);
 800976e:	68fb      	ldr	r3, [r7, #12]
 8009770:	681b      	ldr	r3, [r3, #0]
 8009772:	68fa      	ldr	r2, [r7, #12]
 8009774:	6812      	ldr	r2, [r2, #0]
 8009776:	6812      	ldr	r2, [r2, #0]
 8009778:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800977c:	601a      	str	r2, [r3, #0]
 800977e:	68fb      	ldr	r3, [r7, #12]
 8009780:	681b      	ldr	r3, [r3, #0]
 8009782:	68fa      	ldr	r2, [r7, #12]
 8009784:	6812      	ldr	r2, [r2, #0]
 8009786:	6812      	ldr	r2, [r2, #0]
 8009788:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800978c:	601a      	str	r2, [r3, #0]

      /* Process Unlocked */
      __HAL_UNLOCK(hspi);
 800978e:	68fb      	ldr	r3, [r7, #12]
 8009790:	2200      	movs	r2, #0
 8009792:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

      return HAL_ERROR; 
 8009796:	2301      	movs	r3, #1
 8009798:	e006      	b.n	80097a8 <HAL_SPI_Receive+0x304>
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hspi);
 800979a:	68fb      	ldr	r3, [r7, #12]
 800979c:	2200      	movs	r2, #0
 800979e:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    return HAL_OK;
 80097a2:	2300      	movs	r3, #0
 80097a4:	e000      	b.n	80097a8 <HAL_SPI_Receive+0x304>
  }
  else
  {
    return HAL_BUSY;
 80097a6:	2302      	movs	r3, #2
  }
}
 80097a8:	4618      	mov	r0, r3
 80097aa:	3718      	adds	r7, #24
 80097ac:	46bd      	mov	sp, r7
 80097ae:	bd80      	pop	{r7, pc}

080097b0 <HAL_SPI_TransmitReceive>:
  * @param  Size: amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
{
 80097b0:	b580      	push	{r7, lr}
 80097b2:	b088      	sub	sp, #32
 80097b4:	af00      	add	r7, sp, #0
 80097b6:	60f8      	str	r0, [r7, #12]
 80097b8:	60b9      	str	r1, [r7, #8]
 80097ba:	607a      	str	r2, [r7, #4]
 80097bc:	807b      	strh	r3, [r7, #2]
  __IO uint16_t tmpreg;
  uint32_t tmpstate = 0, tmp = 0;
 80097be:	2300      	movs	r3, #0
 80097c0:	61fb      	str	r3, [r7, #28]
 80097c2:	2300      	movs	r3, #0
 80097c4:	61bb      	str	r3, [r7, #24]
  
  tmpstate = hspi->State; 
 80097c6:	68fb      	ldr	r3, [r7, #12]
 80097c8:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 80097cc:	b2db      	uxtb	r3, r3
 80097ce:	61fb      	str	r3, [r7, #28]
  if((tmpstate == HAL_SPI_STATE_READY) || (tmpstate == HAL_SPI_STATE_BUSY_RX))
 80097d0:	69fb      	ldr	r3, [r7, #28]
 80097d2:	2b01      	cmp	r3, #1
 80097d4:	d003      	beq.n	80097de <HAL_SPI_TransmitReceive+0x2e>
 80097d6:	69fb      	ldr	r3, [r7, #28]
 80097d8:	2b22      	cmp	r3, #34	; 0x22
 80097da:	f040 823f 	bne.w	8009c5c <HAL_SPI_TransmitReceive+0x4ac>
  {
    if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0))
 80097de:	68bb      	ldr	r3, [r7, #8]
 80097e0:	2b00      	cmp	r3, #0
 80097e2:	d005      	beq.n	80097f0 <HAL_SPI_TransmitReceive+0x40>
 80097e4:	687b      	ldr	r3, [r7, #4]
 80097e6:	2b00      	cmp	r3, #0
 80097e8:	d002      	beq.n	80097f0 <HAL_SPI_TransmitReceive+0x40>
 80097ea:	887b      	ldrh	r3, [r7, #2]
 80097ec:	2b00      	cmp	r3, #0
 80097ee:	d101      	bne.n	80097f4 <HAL_SPI_TransmitReceive+0x44>
    {
      return  HAL_ERROR;
 80097f0:	2301      	movs	r3, #1
 80097f2:	e234      	b.n	8009c5e <HAL_SPI_TransmitReceive+0x4ae>

    /* Check the parameters */
    assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

    /* Process Locked */
    __HAL_LOCK(hspi);
 80097f4:	68fb      	ldr	r3, [r7, #12]
 80097f6:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 80097fa:	2b01      	cmp	r3, #1
 80097fc:	d101      	bne.n	8009802 <HAL_SPI_TransmitReceive+0x52>
 80097fe:	2302      	movs	r3, #2
 8009800:	e22d      	b.n	8009c5e <HAL_SPI_TransmitReceive+0x4ae>
 8009802:	68fb      	ldr	r3, [r7, #12]
 8009804:	2201      	movs	r2, #1
 8009806:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
 
    /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
    if(hspi->State == HAL_SPI_STATE_READY)
 800980a:	68fb      	ldr	r3, [r7, #12]
 800980c:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 8009810:	b2db      	uxtb	r3, r3
 8009812:	2b01      	cmp	r3, #1
 8009814:	d103      	bne.n	800981e <HAL_SPI_TransmitReceive+0x6e>
    {
      hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 8009816:	68fb      	ldr	r3, [r7, #12]
 8009818:	2232      	movs	r2, #50	; 0x32
 800981a:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
    }

     /* Configure communication */   
    hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800981e:	68fb      	ldr	r3, [r7, #12]
 8009820:	2200      	movs	r2, #0
 8009822:	655a      	str	r2, [r3, #84]	; 0x54

    hspi->pRxBuffPtr  = pRxData;
 8009824:	68fb      	ldr	r3, [r7, #12]
 8009826:	687a      	ldr	r2, [r7, #4]
 8009828:	639a      	str	r2, [r3, #56]	; 0x38
    hspi->RxXferSize  = Size;
 800982a:	68fb      	ldr	r3, [r7, #12]
 800982c:	887a      	ldrh	r2, [r7, #2]
 800982e:	879a      	strh	r2, [r3, #60]	; 0x3c
    hspi->RxXferCount = Size;  
 8009830:	68fb      	ldr	r3, [r7, #12]
 8009832:	887a      	ldrh	r2, [r7, #2]
 8009834:	87da      	strh	r2, [r3, #62]	; 0x3e
    
    hspi->pTxBuffPtr  = pTxData;
 8009836:	68fb      	ldr	r3, [r7, #12]
 8009838:	68ba      	ldr	r2, [r7, #8]
 800983a:	631a      	str	r2, [r3, #48]	; 0x30
    hspi->TxXferSize  = Size; 
 800983c:	68fb      	ldr	r3, [r7, #12]
 800983e:	887a      	ldrh	r2, [r7, #2]
 8009840:	869a      	strh	r2, [r3, #52]	; 0x34
    hspi->TxXferCount = Size;
 8009842:	68fb      	ldr	r3, [r7, #12]
 8009844:	887a      	ldrh	r2, [r7, #2]
 8009846:	86da      	strh	r2, [r3, #54]	; 0x36

    /*Init field not used in handle to zero */
    hspi->RxISR = 0;
 8009848:	68fb      	ldr	r3, [r7, #12]
 800984a:	2200      	movs	r2, #0
 800984c:	649a      	str	r2, [r3, #72]	; 0x48
    hspi->TxISR = 0;
 800984e:	68fb      	ldr	r3, [r7, #12]
 8009850:	2200      	movs	r2, #0
 8009852:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Reset CRC Calculation */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8009854:	68fb      	ldr	r3, [r7, #12]
 8009856:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009858:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800985c:	d10f      	bne.n	800987e <HAL_SPI_TransmitReceive+0xce>
    {
      SPI_RESET_CRC(hspi);
 800985e:	68fb      	ldr	r3, [r7, #12]
 8009860:	681b      	ldr	r3, [r3, #0]
 8009862:	68fa      	ldr	r2, [r7, #12]
 8009864:	6812      	ldr	r2, [r2, #0]
 8009866:	6812      	ldr	r2, [r2, #0]
 8009868:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800986c:	601a      	str	r2, [r3, #0]
 800986e:	68fb      	ldr	r3, [r7, #12]
 8009870:	681b      	ldr	r3, [r3, #0]
 8009872:	68fa      	ldr	r2, [r7, #12]
 8009874:	6812      	ldr	r2, [r2, #0]
 8009876:	6812      	ldr	r2, [r2, #0]
 8009878:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800987c:	601a      	str	r2, [r3, #0]
    }

    /* Check if the SPI is already enabled */ 
    if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 800987e:	68fb      	ldr	r3, [r7, #12]
 8009880:	681b      	ldr	r3, [r3, #0]
 8009882:	681b      	ldr	r3, [r3, #0]
 8009884:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009888:	2b00      	cmp	r3, #0
 800988a:	d107      	bne.n	800989c <HAL_SPI_TransmitReceive+0xec>
    {
      /* Enable SPI peripheral */
      __HAL_SPI_ENABLE(hspi);
 800988c:	68fb      	ldr	r3, [r7, #12]
 800988e:	681b      	ldr	r3, [r3, #0]
 8009890:	68fa      	ldr	r2, [r7, #12]
 8009892:	6812      	ldr	r2, [r2, #0]
 8009894:	6812      	ldr	r2, [r2, #0]
 8009896:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800989a:	601a      	str	r2, [r3, #0]
    }

    /* Transmit and Receive data in 16 Bit mode */
    if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 800989c:	68fb      	ldr	r3, [r7, #12]
 800989e:	68db      	ldr	r3, [r3, #12]
 80098a0:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80098a4:	f040 80bf 	bne.w	8009a26 <HAL_SPI_TransmitReceive+0x276>
    {
      if((hspi->Init.Mode == SPI_MODE_SLAVE) || ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->TxXferCount == 0x01)))
 80098a8:	68fb      	ldr	r3, [r7, #12]
 80098aa:	685b      	ldr	r3, [r3, #4]
 80098ac:	2b00      	cmp	r3, #0
 80098ae:	d008      	beq.n	80098c2 <HAL_SPI_TransmitReceive+0x112>
 80098b0:	68fb      	ldr	r3, [r7, #12]
 80098b2:	685b      	ldr	r3, [r3, #4]
 80098b4:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 80098b8:	d114      	bne.n	80098e4 <HAL_SPI_TransmitReceive+0x134>
 80098ba:	68fb      	ldr	r3, [r7, #12]
 80098bc:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 80098be:	2b01      	cmp	r3, #1
 80098c0:	d110      	bne.n	80098e4 <HAL_SPI_TransmitReceive+0x134>
      {
        hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
 80098c2:	68fb      	ldr	r3, [r7, #12]
 80098c4:	681b      	ldr	r3, [r3, #0]
 80098c6:	68fa      	ldr	r2, [r7, #12]
 80098c8:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80098ca:	8812      	ldrh	r2, [r2, #0]
 80098cc:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr+=2;
 80098ce:	68fb      	ldr	r3, [r7, #12]
 80098d0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80098d2:	1c9a      	adds	r2, r3, #2
 80098d4:	68fb      	ldr	r3, [r7, #12]
 80098d6:	631a      	str	r2, [r3, #48]	; 0x30
        hspi->TxXferCount--;
 80098d8:	68fb      	ldr	r3, [r7, #12]
 80098da:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 80098dc:	3b01      	subs	r3, #1
 80098de:	b29a      	uxth	r2, r3
 80098e0:	68fb      	ldr	r3, [r7, #12]
 80098e2:	86da      	strh	r2, [r3, #54]	; 0x36
      }
      if(hspi->TxXferCount == 0)
 80098e4:	68fb      	ldr	r3, [r7, #12]
 80098e6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 80098e8:	2b00      	cmp	r3, #0
 80098ea:	d12a      	bne.n	8009942 <HAL_SPI_TransmitReceive+0x192>
      {
        /* Enable CRC Transmission */
        if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80098ec:	68fb      	ldr	r3, [r7, #12]
 80098ee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80098f0:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80098f4:	d107      	bne.n	8009906 <HAL_SPI_TransmitReceive+0x156>
        {
          hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 80098f6:	68fb      	ldr	r3, [r7, #12]
 80098f8:	681b      	ldr	r3, [r3, #0]
 80098fa:	68fa      	ldr	r2, [r7, #12]
 80098fc:	6812      	ldr	r2, [r2, #0]
 80098fe:	6812      	ldr	r2, [r2, #0]
 8009900:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8009904:	601a      	str	r2, [r3, #0]
        }

        /* Wait until RXNE flag is set */
        if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8009906:	68f8      	ldr	r0, [r7, #12]
 8009908:	2101      	movs	r1, #1
 800990a:	2200      	movs	r2, #0
 800990c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800990e:	f001 fae3 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 8009912:	4603      	mov	r3, r0
 8009914:	2b00      	cmp	r3, #0
 8009916:	d001      	beq.n	800991c <HAL_SPI_TransmitReceive+0x16c>
        { 
          return HAL_TIMEOUT;
 8009918:	2303      	movs	r3, #3
 800991a:	e1a0      	b.n	8009c5e <HAL_SPI_TransmitReceive+0x4ae>
        }

        *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 800991c:	68fb      	ldr	r3, [r7, #12]
 800991e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009920:	68fa      	ldr	r2, [r7, #12]
 8009922:	6812      	ldr	r2, [r2, #0]
 8009924:	68d2      	ldr	r2, [r2, #12]
 8009926:	b292      	uxth	r2, r2
 8009928:	801a      	strh	r2, [r3, #0]
        hspi->pRxBuffPtr+=2;
 800992a:	68fb      	ldr	r3, [r7, #12]
 800992c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800992e:	1c9a      	adds	r2, r3, #2
 8009930:	68fb      	ldr	r3, [r7, #12]
 8009932:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->RxXferCount--;
 8009934:	68fb      	ldr	r3, [r7, #12]
 8009936:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8009938:	3b01      	subs	r3, #1
 800993a:	b29a      	uxth	r2, r3
 800993c:	68fb      	ldr	r3, [r7, #12]
 800993e:	87da      	strh	r2, [r3, #62]	; 0x3e
 8009940:	e121      	b.n	8009b86 <HAL_SPI_TransmitReceive+0x3d6>
      }
      else
      {
        while(hspi->TxXferCount > 0)
 8009942:	e049      	b.n	80099d8 <HAL_SPI_TransmitReceive+0x228>
        {
          /* Wait until TXE flag is set to send data */
          if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
 8009944:	68f8      	ldr	r0, [r7, #12]
 8009946:	2102      	movs	r1, #2
 8009948:	2200      	movs	r2, #0
 800994a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800994c:	f001 fac4 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 8009950:	4603      	mov	r3, r0
 8009952:	2b00      	cmp	r3, #0
 8009954:	d001      	beq.n	800995a <HAL_SPI_TransmitReceive+0x1aa>
          { 
            return HAL_TIMEOUT;
 8009956:	2303      	movs	r3, #3
 8009958:	e181      	b.n	8009c5e <HAL_SPI_TransmitReceive+0x4ae>
          }

          hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
 800995a:	68fb      	ldr	r3, [r7, #12]
 800995c:	681b      	ldr	r3, [r3, #0]
 800995e:	68fa      	ldr	r2, [r7, #12]
 8009960:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8009962:	8812      	ldrh	r2, [r2, #0]
 8009964:	60da      	str	r2, [r3, #12]
          hspi->pTxBuffPtr+=2;
 8009966:	68fb      	ldr	r3, [r7, #12]
 8009968:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800996a:	1c9a      	adds	r2, r3, #2
 800996c:	68fb      	ldr	r3, [r7, #12]
 800996e:	631a      	str	r2, [r3, #48]	; 0x30
          hspi->TxXferCount--;
 8009970:	68fb      	ldr	r3, [r7, #12]
 8009972:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8009974:	3b01      	subs	r3, #1
 8009976:	b29a      	uxth	r2, r3
 8009978:	68fb      	ldr	r3, [r7, #12]
 800997a:	86da      	strh	r2, [r3, #54]	; 0x36

          /* Enable CRC Transmission */
          if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 800997c:	68fb      	ldr	r3, [r7, #12]
 800997e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8009980:	2b00      	cmp	r3, #0
 8009982:	d10c      	bne.n	800999e <HAL_SPI_TransmitReceive+0x1ee>
 8009984:	68fb      	ldr	r3, [r7, #12]
 8009986:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009988:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800998c:	d107      	bne.n	800999e <HAL_SPI_TransmitReceive+0x1ee>
          {
            hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 800998e:	68fb      	ldr	r3, [r7, #12]
 8009990:	681b      	ldr	r3, [r3, #0]
 8009992:	68fa      	ldr	r2, [r7, #12]
 8009994:	6812      	ldr	r2, [r2, #0]
 8009996:	6812      	ldr	r2, [r2, #0]
 8009998:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800999c:	601a      	str	r2, [r3, #0]
          }

          /* Wait until RXNE flag is set */
          if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 800999e:	68f8      	ldr	r0, [r7, #12]
 80099a0:	2101      	movs	r1, #1
 80099a2:	2200      	movs	r2, #0
 80099a4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80099a6:	f001 fa97 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 80099aa:	4603      	mov	r3, r0
 80099ac:	2b00      	cmp	r3, #0
 80099ae:	d001      	beq.n	80099b4 <HAL_SPI_TransmitReceive+0x204>
          { 
            return HAL_TIMEOUT;
 80099b0:	2303      	movs	r3, #3
 80099b2:	e154      	b.n	8009c5e <HAL_SPI_TransmitReceive+0x4ae>
          }
          
          *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 80099b4:	68fb      	ldr	r3, [r7, #12]
 80099b6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80099b8:	68fa      	ldr	r2, [r7, #12]
 80099ba:	6812      	ldr	r2, [r2, #0]
 80099bc:	68d2      	ldr	r2, [r2, #12]
 80099be:	b292      	uxth	r2, r2
 80099c0:	801a      	strh	r2, [r3, #0]
          hspi->pRxBuffPtr+=2;
 80099c2:	68fb      	ldr	r3, [r7, #12]
 80099c4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80099c6:	1c9a      	adds	r2, r3, #2
 80099c8:	68fb      	ldr	r3, [r7, #12]
 80099ca:	639a      	str	r2, [r3, #56]	; 0x38
          hspi->RxXferCount--;
 80099cc:	68fb      	ldr	r3, [r7, #12]
 80099ce:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 80099d0:	3b01      	subs	r3, #1
 80099d2:	b29a      	uxth	r2, r3
 80099d4:	68fb      	ldr	r3, [r7, #12]
 80099d6:	87da      	strh	r2, [r3, #62]	; 0x3e
        hspi->pRxBuffPtr+=2;
        hspi->RxXferCount--;
      }
      else
      {
        while(hspi->TxXferCount > 0)
 80099d8:	68fb      	ldr	r3, [r7, #12]
 80099da:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 80099dc:	2b00      	cmp	r3, #0
 80099de:	d1b1      	bne.n	8009944 <HAL_SPI_TransmitReceive+0x194>
          *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
          hspi->pRxBuffPtr+=2;
          hspi->RxXferCount--;
        }
        /* Receive the last byte */
        if(hspi->Init.Mode == SPI_MODE_SLAVE)
 80099e0:	68fb      	ldr	r3, [r7, #12]
 80099e2:	685b      	ldr	r3, [r3, #4]
 80099e4:	2b00      	cmp	r3, #0
 80099e6:	f040 80ce 	bne.w	8009b86 <HAL_SPI_TransmitReceive+0x3d6>
        {
          /* Wait until RXNE flag is set */
          if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 80099ea:	68f8      	ldr	r0, [r7, #12]
 80099ec:	2101      	movs	r1, #1
 80099ee:	2200      	movs	r2, #0
 80099f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80099f2:	f001 fa71 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 80099f6:	4603      	mov	r3, r0
 80099f8:	2b00      	cmp	r3, #0
 80099fa:	d001      	beq.n	8009a00 <HAL_SPI_TransmitReceive+0x250>
          {
            return HAL_TIMEOUT;
 80099fc:	2303      	movs	r3, #3
 80099fe:	e12e      	b.n	8009c5e <HAL_SPI_TransmitReceive+0x4ae>
          }
          
          *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 8009a00:	68fb      	ldr	r3, [r7, #12]
 8009a02:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009a04:	68fa      	ldr	r2, [r7, #12]
 8009a06:	6812      	ldr	r2, [r2, #0]
 8009a08:	68d2      	ldr	r2, [r2, #12]
 8009a0a:	b292      	uxth	r2, r2
 8009a0c:	801a      	strh	r2, [r3, #0]
          hspi->pRxBuffPtr+=2;
 8009a0e:	68fb      	ldr	r3, [r7, #12]
 8009a10:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009a12:	1c9a      	adds	r2, r3, #2
 8009a14:	68fb      	ldr	r3, [r7, #12]
 8009a16:	639a      	str	r2, [r3, #56]	; 0x38
          hspi->RxXferCount--;
 8009a18:	68fb      	ldr	r3, [r7, #12]
 8009a1a:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8009a1c:	3b01      	subs	r3, #1
 8009a1e:	b29a      	uxth	r2, r3
 8009a20:	68fb      	ldr	r3, [r7, #12]
 8009a22:	87da      	strh	r2, [r3, #62]	; 0x3e
 8009a24:	e0af      	b.n	8009b86 <HAL_SPI_TransmitReceive+0x3d6>
      }
    }
    /* Transmit and Receive data in 8 Bit mode */
    else
    {
      if((hspi->Init.Mode == SPI_MODE_SLAVE) || ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->TxXferCount == 0x01)))
 8009a26:	68fb      	ldr	r3, [r7, #12]
 8009a28:	685b      	ldr	r3, [r3, #4]
 8009a2a:	2b00      	cmp	r3, #0
 8009a2c:	d008      	beq.n	8009a40 <HAL_SPI_TransmitReceive+0x290>
 8009a2e:	68fb      	ldr	r3, [r7, #12]
 8009a30:	685b      	ldr	r3, [r3, #4]
 8009a32:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8009a36:	d112      	bne.n	8009a5e <HAL_SPI_TransmitReceive+0x2ae>
 8009a38:	68fb      	ldr	r3, [r7, #12]
 8009a3a:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8009a3c:	2b01      	cmp	r3, #1
 8009a3e:	d10e      	bne.n	8009a5e <HAL_SPI_TransmitReceive+0x2ae>
      {
        hspi->Instance->DR = (*hspi->pTxBuffPtr++);
 8009a40:	68fb      	ldr	r3, [r7, #12]
 8009a42:	681a      	ldr	r2, [r3, #0]
 8009a44:	68fb      	ldr	r3, [r7, #12]
 8009a46:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009a48:	1c58      	adds	r0, r3, #1
 8009a4a:	68f9      	ldr	r1, [r7, #12]
 8009a4c:	6308      	str	r0, [r1, #48]	; 0x30
 8009a4e:	781b      	ldrb	r3, [r3, #0]
 8009a50:	60d3      	str	r3, [r2, #12]
        hspi->TxXferCount--;
 8009a52:	68fb      	ldr	r3, [r7, #12]
 8009a54:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8009a56:	3b01      	subs	r3, #1
 8009a58:	b29a      	uxth	r2, r3
 8009a5a:	68fb      	ldr	r3, [r7, #12]
 8009a5c:	86da      	strh	r2, [r3, #54]	; 0x36
      }
      if(hspi->TxXferCount == 0)
 8009a5e:	68fb      	ldr	r3, [r7, #12]
 8009a60:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8009a62:	2b00      	cmp	r3, #0
 8009a64:	d125      	bne.n	8009ab2 <HAL_SPI_TransmitReceive+0x302>
      {
        /* Enable CRC Transmission */
        if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8009a66:	68fb      	ldr	r3, [r7, #12]
 8009a68:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009a6a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009a6e:	d107      	bne.n	8009a80 <HAL_SPI_TransmitReceive+0x2d0>
        {
          hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 8009a70:	68fb      	ldr	r3, [r7, #12]
 8009a72:	681b      	ldr	r3, [r3, #0]
 8009a74:	68fa      	ldr	r2, [r7, #12]
 8009a76:	6812      	ldr	r2, [r2, #0]
 8009a78:	6812      	ldr	r2, [r2, #0]
 8009a7a:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8009a7e:	601a      	str	r2, [r3, #0]
        }

        /* Wait until RXNE flag is set */
        if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8009a80:	68f8      	ldr	r0, [r7, #12]
 8009a82:	2101      	movs	r1, #1
 8009a84:	2200      	movs	r2, #0
 8009a86:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009a88:	f001 fa26 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 8009a8c:	4603      	mov	r3, r0
 8009a8e:	2b00      	cmp	r3, #0
 8009a90:	d001      	beq.n	8009a96 <HAL_SPI_TransmitReceive+0x2e6>
        {
          return HAL_TIMEOUT;
 8009a92:	2303      	movs	r3, #3
 8009a94:	e0e3      	b.n	8009c5e <HAL_SPI_TransmitReceive+0x4ae>
        }

        (*hspi->pRxBuffPtr) = hspi->Instance->DR;
 8009a96:	68fb      	ldr	r3, [r7, #12]
 8009a98:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009a9a:	68fa      	ldr	r2, [r7, #12]
 8009a9c:	6812      	ldr	r2, [r2, #0]
 8009a9e:	68d2      	ldr	r2, [r2, #12]
 8009aa0:	b2d2      	uxtb	r2, r2
 8009aa2:	701a      	strb	r2, [r3, #0]
        hspi->RxXferCount--;
 8009aa4:	68fb      	ldr	r3, [r7, #12]
 8009aa6:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8009aa8:	3b01      	subs	r3, #1
 8009aaa:	b29a      	uxth	r2, r3
 8009aac:	68fb      	ldr	r3, [r7, #12]
 8009aae:	87da      	strh	r2, [r3, #62]	; 0x3e
 8009ab0:	e069      	b.n	8009b86 <HAL_SPI_TransmitReceive+0x3d6>
      }
      else
      {
        while(hspi->TxXferCount > 0)
 8009ab2:	e045      	b.n	8009b40 <HAL_SPI_TransmitReceive+0x390>
        {
          /* Wait until TXE flag is set to send data */
          if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
 8009ab4:	68f8      	ldr	r0, [r7, #12]
 8009ab6:	2102      	movs	r1, #2
 8009ab8:	2200      	movs	r2, #0
 8009aba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009abc:	f001 fa0c 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 8009ac0:	4603      	mov	r3, r0
 8009ac2:	2b00      	cmp	r3, #0
 8009ac4:	d001      	beq.n	8009aca <HAL_SPI_TransmitReceive+0x31a>
          {
            return HAL_TIMEOUT;
 8009ac6:	2303      	movs	r3, #3
 8009ac8:	e0c9      	b.n	8009c5e <HAL_SPI_TransmitReceive+0x4ae>
          }

          hspi->Instance->DR = (*hspi->pTxBuffPtr++);
 8009aca:	68fb      	ldr	r3, [r7, #12]
 8009acc:	681a      	ldr	r2, [r3, #0]
 8009ace:	68fb      	ldr	r3, [r7, #12]
 8009ad0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009ad2:	1c58      	adds	r0, r3, #1
 8009ad4:	68f9      	ldr	r1, [r7, #12]
 8009ad6:	6308      	str	r0, [r1, #48]	; 0x30
 8009ad8:	781b      	ldrb	r3, [r3, #0]
 8009ada:	60d3      	str	r3, [r2, #12]
          hspi->TxXferCount--;
 8009adc:	68fb      	ldr	r3, [r7, #12]
 8009ade:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8009ae0:	3b01      	subs	r3, #1
 8009ae2:	b29a      	uxth	r2, r3
 8009ae4:	68fb      	ldr	r3, [r7, #12]
 8009ae6:	86da      	strh	r2, [r3, #54]	; 0x36

          /* Enable CRC Transmission */
          if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 8009ae8:	68fb      	ldr	r3, [r7, #12]
 8009aea:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8009aec:	2b00      	cmp	r3, #0
 8009aee:	d10c      	bne.n	8009b0a <HAL_SPI_TransmitReceive+0x35a>
 8009af0:	68fb      	ldr	r3, [r7, #12]
 8009af2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009af4:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009af8:	d107      	bne.n	8009b0a <HAL_SPI_TransmitReceive+0x35a>
          {
            hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 8009afa:	68fb      	ldr	r3, [r7, #12]
 8009afc:	681b      	ldr	r3, [r3, #0]
 8009afe:	68fa      	ldr	r2, [r7, #12]
 8009b00:	6812      	ldr	r2, [r2, #0]
 8009b02:	6812      	ldr	r2, [r2, #0]
 8009b04:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8009b08:	601a      	str	r2, [r3, #0]
          }

            /* Wait until RXNE flag is set */
            if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8009b0a:	68f8      	ldr	r0, [r7, #12]
 8009b0c:	2101      	movs	r1, #1
 8009b0e:	2200      	movs	r2, #0
 8009b10:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009b12:	f001 f9e1 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 8009b16:	4603      	mov	r3, r0
 8009b18:	2b00      	cmp	r3, #0
 8009b1a:	d001      	beq.n	8009b20 <HAL_SPI_TransmitReceive+0x370>
            {
              return HAL_TIMEOUT;
 8009b1c:	2303      	movs	r3, #3
 8009b1e:	e09e      	b.n	8009c5e <HAL_SPI_TransmitReceive+0x4ae>
            }
            
            (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
 8009b20:	68fb      	ldr	r3, [r7, #12]
 8009b22:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009b24:	1c59      	adds	r1, r3, #1
 8009b26:	68fa      	ldr	r2, [r7, #12]
 8009b28:	6391      	str	r1, [r2, #56]	; 0x38
 8009b2a:	68fa      	ldr	r2, [r7, #12]
 8009b2c:	6812      	ldr	r2, [r2, #0]
 8009b2e:	68d2      	ldr	r2, [r2, #12]
 8009b30:	b2d2      	uxtb	r2, r2
 8009b32:	701a      	strb	r2, [r3, #0]
            hspi->RxXferCount--;
 8009b34:	68fb      	ldr	r3, [r7, #12]
 8009b36:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8009b38:	3b01      	subs	r3, #1
 8009b3a:	b29a      	uxth	r2, r3
 8009b3c:	68fb      	ldr	r3, [r7, #12]
 8009b3e:	87da      	strh	r2, [r3, #62]	; 0x3e
        (*hspi->pRxBuffPtr) = hspi->Instance->DR;
        hspi->RxXferCount--;
      }
      else
      {
        while(hspi->TxXferCount > 0)
 8009b40:	68fb      	ldr	r3, [r7, #12]
 8009b42:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8009b44:	2b00      	cmp	r3, #0
 8009b46:	d1b5      	bne.n	8009ab4 <HAL_SPI_TransmitReceive+0x304>
            }
            
            (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
            hspi->RxXferCount--;
        }
        if(hspi->Init.Mode == SPI_MODE_SLAVE)
 8009b48:	68fb      	ldr	r3, [r7, #12]
 8009b4a:	685b      	ldr	r3, [r3, #4]
 8009b4c:	2b00      	cmp	r3, #0
 8009b4e:	d11a      	bne.n	8009b86 <HAL_SPI_TransmitReceive+0x3d6>
        {
          /* Wait until RXNE flag is set */
          if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8009b50:	68f8      	ldr	r0, [r7, #12]
 8009b52:	2101      	movs	r1, #1
 8009b54:	2200      	movs	r2, #0
 8009b56:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009b58:	f001 f9be 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 8009b5c:	4603      	mov	r3, r0
 8009b5e:	2b00      	cmp	r3, #0
 8009b60:	d001      	beq.n	8009b66 <HAL_SPI_TransmitReceive+0x3b6>
          {
            return HAL_TIMEOUT;
 8009b62:	2303      	movs	r3, #3
 8009b64:	e07b      	b.n	8009c5e <HAL_SPI_TransmitReceive+0x4ae>
          }
          
          (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
 8009b66:	68fb      	ldr	r3, [r7, #12]
 8009b68:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009b6a:	1c59      	adds	r1, r3, #1
 8009b6c:	68fa      	ldr	r2, [r7, #12]
 8009b6e:	6391      	str	r1, [r2, #56]	; 0x38
 8009b70:	68fa      	ldr	r2, [r7, #12]
 8009b72:	6812      	ldr	r2, [r2, #0]
 8009b74:	68d2      	ldr	r2, [r2, #12]
 8009b76:	b2d2      	uxtb	r2, r2
 8009b78:	701a      	strb	r2, [r3, #0]
          hspi->RxXferCount--;
 8009b7a:	68fb      	ldr	r3, [r7, #12]
 8009b7c:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8009b7e:	3b01      	subs	r3, #1
 8009b80:	b29a      	uxth	r2, r3
 8009b82:	68fb      	ldr	r3, [r7, #12]
 8009b84:	87da      	strh	r2, [r3, #62]	; 0x3e
        }
      }
    }

    /* Read CRC from DR to close CRC calculation process */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8009b86:	68fb      	ldr	r3, [r7, #12]
 8009b88:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009b8a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009b8e:	d116      	bne.n	8009bbe <HAL_SPI_TransmitReceive+0x40e>
    {
      /* Wait until RXNE flag is set */
      if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8009b90:	68f8      	ldr	r0, [r7, #12]
 8009b92:	2101      	movs	r1, #1
 8009b94:	2200      	movs	r2, #0
 8009b96:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009b98:	f001 f99e 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 8009b9c:	4603      	mov	r3, r0
 8009b9e:	2b00      	cmp	r3, #0
 8009ba0:	d007      	beq.n	8009bb2 <HAL_SPI_TransmitReceive+0x402>
      {
        hspi->ErrorCode |= HAL_SPI_ERROR_CRC;
 8009ba2:	68fb      	ldr	r3, [r7, #12]
 8009ba4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009ba6:	f043 0202 	orr.w	r2, r3, #2
 8009baa:	68fb      	ldr	r3, [r7, #12]
 8009bac:	655a      	str	r2, [r3, #84]	; 0x54
        return HAL_TIMEOUT;
 8009bae:	2303      	movs	r3, #3
 8009bb0:	e055      	b.n	8009c5e <HAL_SPI_TransmitReceive+0x4ae>
      }
      /* Read CRC */
      tmpreg = hspi->Instance->DR;
 8009bb2:	68fb      	ldr	r3, [r7, #12]
 8009bb4:	681b      	ldr	r3, [r3, #0]
 8009bb6:	68db      	ldr	r3, [r3, #12]
 8009bb8:	b29b      	uxth	r3, r3
 8009bba:	82fb      	strh	r3, [r7, #22]
      UNUSED(tmpreg);
 8009bbc:	8afb      	ldrh	r3, [r7, #22]
    }

    /* Wait until Busy flag is reset before disabling SPI */
    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, Timeout) != HAL_OK)
 8009bbe:	68f8      	ldr	r0, [r7, #12]
 8009bc0:	2180      	movs	r1, #128	; 0x80
 8009bc2:	2201      	movs	r2, #1
 8009bc4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009bc6:	f001 f987 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 8009bca:	4603      	mov	r3, r0
 8009bcc:	2b00      	cmp	r3, #0
 8009bce:	d007      	beq.n	8009be0 <HAL_SPI_TransmitReceive+0x430>
    {
      hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 8009bd0:	68fb      	ldr	r3, [r7, #12]
 8009bd2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009bd4:	f043 0220 	orr.w	r2, r3, #32
 8009bd8:	68fb      	ldr	r3, [r7, #12]
 8009bda:	655a      	str	r2, [r3, #84]	; 0x54
      return HAL_TIMEOUT;
 8009bdc:	2303      	movs	r3, #3
 8009bde:	e03e      	b.n	8009c5e <HAL_SPI_TransmitReceive+0x4ae>
    }
    
    hspi->State = HAL_SPI_STATE_READY;
 8009be0:	68fb      	ldr	r3, [r7, #12]
 8009be2:	2201      	movs	r2, #1
 8009be4:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

    tmp = __HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR);
 8009be8:	68fb      	ldr	r3, [r7, #12]
 8009bea:	681b      	ldr	r3, [r3, #0]
 8009bec:	689b      	ldr	r3, [r3, #8]
 8009bee:	f003 0310 	and.w	r3, r3, #16
 8009bf2:	2b00      	cmp	r3, #0
 8009bf4:	bf0c      	ite	eq
 8009bf6:	2300      	moveq	r3, #0
 8009bf8:	2301      	movne	r3, #1
 8009bfa:	b2db      	uxtb	r3, r3
 8009bfc:	61bb      	str	r3, [r7, #24]
    /* Check if CRC error occurred */
    if((hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) && (tmp != RESET))
 8009bfe:	68fb      	ldr	r3, [r7, #12]
 8009c00:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009c02:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009c06:	d123      	bne.n	8009c50 <HAL_SPI_TransmitReceive+0x4a0>
 8009c08:	69bb      	ldr	r3, [r7, #24]
 8009c0a:	2b00      	cmp	r3, #0
 8009c0c:	d020      	beq.n	8009c50 <HAL_SPI_TransmitReceive+0x4a0>
    {
      hspi->ErrorCode |= HAL_SPI_ERROR_CRC;
 8009c0e:	68fb      	ldr	r3, [r7, #12]
 8009c10:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009c12:	f043 0202 	orr.w	r2, r3, #2
 8009c16:	68fb      	ldr	r3, [r7, #12]
 8009c18:	655a      	str	r2, [r3, #84]	; 0x54

      /* Reset CRC Calculation */
      if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8009c1a:	68fb      	ldr	r3, [r7, #12]
 8009c1c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009c1e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009c22:	d10f      	bne.n	8009c44 <HAL_SPI_TransmitReceive+0x494>
      {
        SPI_RESET_CRC(hspi);
 8009c24:	68fb      	ldr	r3, [r7, #12]
 8009c26:	681b      	ldr	r3, [r3, #0]
 8009c28:	68fa      	ldr	r2, [r7, #12]
 8009c2a:	6812      	ldr	r2, [r2, #0]
 8009c2c:	6812      	ldr	r2, [r2, #0]
 8009c2e:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8009c32:	601a      	str	r2, [r3, #0]
 8009c34:	68fb      	ldr	r3, [r7, #12]
 8009c36:	681b      	ldr	r3, [r3, #0]
 8009c38:	68fa      	ldr	r2, [r7, #12]
 8009c3a:	6812      	ldr	r2, [r2, #0]
 8009c3c:	6812      	ldr	r2, [r2, #0]
 8009c3e:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8009c42:	601a      	str	r2, [r3, #0]
      }

      /* Process Unlocked */
      __HAL_UNLOCK(hspi);
 8009c44:	68fb      	ldr	r3, [r7, #12]
 8009c46:	2200      	movs	r2, #0
 8009c48:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      
      return HAL_ERROR; 
 8009c4c:	2301      	movs	r3, #1
 8009c4e:	e006      	b.n	8009c5e <HAL_SPI_TransmitReceive+0x4ae>
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hspi);
 8009c50:	68fb      	ldr	r3, [r7, #12]
 8009c52:	2200      	movs	r2, #0
 8009c54:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    return HAL_OK;
 8009c58:	2300      	movs	r3, #0
 8009c5a:	e000      	b.n	8009c5e <HAL_SPI_TransmitReceive+0x4ae>
  }
  else
  {
    return HAL_BUSY;
 8009c5c:	2302      	movs	r3, #2
  }
}
 8009c5e:	4618      	mov	r0, r3
 8009c60:	3720      	adds	r7, #32
 8009c62:	46bd      	mov	sp, r7
 8009c64:	bd80      	pop	{r7, pc}
 8009c66:	bf00      	nop

08009c68 <HAL_SPI_Transmit_IT>:
  * @param  pData: pointer to data buffer
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
 8009c68:	b480      	push	{r7}
 8009c6a:	b085      	sub	sp, #20
 8009c6c:	af00      	add	r7, sp, #0
 8009c6e:	60f8      	str	r0, [r7, #12]
 8009c70:	60b9      	str	r1, [r7, #8]
 8009c72:	4613      	mov	r3, r2
 8009c74:	80fb      	strh	r3, [r7, #6]
  if(hspi->State == HAL_SPI_STATE_READY)
 8009c76:	68fb      	ldr	r3, [r7, #12]
 8009c78:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 8009c7c:	b2db      	uxtb	r3, r3
 8009c7e:	2b01      	cmp	r3, #1
 8009c80:	d17d      	bne.n	8009d7e <HAL_SPI_Transmit_IT+0x116>
  {
    if((pData == NULL) || (Size == 0))
 8009c82:	68bb      	ldr	r3, [r7, #8]
 8009c84:	2b00      	cmp	r3, #0
 8009c86:	d002      	beq.n	8009c8e <HAL_SPI_Transmit_IT+0x26>
 8009c88:	88fb      	ldrh	r3, [r7, #6]
 8009c8a:	2b00      	cmp	r3, #0
 8009c8c:	d101      	bne.n	8009c92 <HAL_SPI_Transmit_IT+0x2a>
    {
      return  HAL_ERROR;
 8009c8e:	2301      	movs	r3, #1
 8009c90:	e076      	b.n	8009d80 <HAL_SPI_Transmit_IT+0x118>

    /* Check the parameters */
    assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

    /* Process Locked */
    __HAL_LOCK(hspi);
 8009c92:	68fb      	ldr	r3, [r7, #12]
 8009c94:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 8009c98:	2b01      	cmp	r3, #1
 8009c9a:	d101      	bne.n	8009ca0 <HAL_SPI_Transmit_IT+0x38>
 8009c9c:	2302      	movs	r3, #2
 8009c9e:	e06f      	b.n	8009d80 <HAL_SPI_Transmit_IT+0x118>
 8009ca0:	68fb      	ldr	r3, [r7, #12]
 8009ca2:	2201      	movs	r2, #1
 8009ca4:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    /* Configure communication */
    hspi->State        = HAL_SPI_STATE_BUSY_TX;
 8009ca8:	68fb      	ldr	r3, [r7, #12]
 8009caa:	2212      	movs	r2, #18
 8009cac:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
    hspi->ErrorCode    = HAL_SPI_ERROR_NONE;
 8009cb0:	68fb      	ldr	r3, [r7, #12]
 8009cb2:	2200      	movs	r2, #0
 8009cb4:	655a      	str	r2, [r3, #84]	; 0x54

    hspi->TxISR = &SPI_TxISR;
 8009cb6:	68fa      	ldr	r2, [r7, #12]
 8009cb8:	f64a 03c5 	movw	r3, #43205	; 0xa8c5
 8009cbc:	f6c0 0300 	movt	r3, #2048	; 0x800
 8009cc0:	64d3      	str	r3, [r2, #76]	; 0x4c
    hspi->pTxBuffPtr   = pData;
 8009cc2:	68fb      	ldr	r3, [r7, #12]
 8009cc4:	68ba      	ldr	r2, [r7, #8]
 8009cc6:	631a      	str	r2, [r3, #48]	; 0x30
    hspi->TxXferSize   = Size;
 8009cc8:	68fb      	ldr	r3, [r7, #12]
 8009cca:	88fa      	ldrh	r2, [r7, #6]
 8009ccc:	869a      	strh	r2, [r3, #52]	; 0x34
    hspi->TxXferCount  = Size;
 8009cce:	68fb      	ldr	r3, [r7, #12]
 8009cd0:	88fa      	ldrh	r2, [r7, #6]
 8009cd2:	86da      	strh	r2, [r3, #54]	; 0x36

    /*Init field not used in handle to zero */
    hspi->RxISR = 0;
 8009cd4:	68fb      	ldr	r3, [r7, #12]
 8009cd6:	2200      	movs	r2, #0
 8009cd8:	649a      	str	r2, [r3, #72]	; 0x48
    hspi->RxXferSize   = 0;
 8009cda:	68fb      	ldr	r3, [r7, #12]
 8009cdc:	2200      	movs	r2, #0
 8009cde:	879a      	strh	r2, [r3, #60]	; 0x3c
    hspi->RxXferCount  = 0;
 8009ce0:	68fb      	ldr	r3, [r7, #12]
 8009ce2:	2200      	movs	r2, #0
 8009ce4:	87da      	strh	r2, [r3, #62]	; 0x3e

    /* Configure communication direction : 1Line */
    if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8009ce6:	68fb      	ldr	r3, [r7, #12]
 8009ce8:	689b      	ldr	r3, [r3, #8]
 8009cea:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8009cee:	d107      	bne.n	8009d00 <HAL_SPI_Transmit_IT+0x98>
    {
      SPI_1LINE_TX(hspi);
 8009cf0:	68fb      	ldr	r3, [r7, #12]
 8009cf2:	681b      	ldr	r3, [r3, #0]
 8009cf4:	68fa      	ldr	r2, [r7, #12]
 8009cf6:	6812      	ldr	r2, [r2, #0]
 8009cf8:	6812      	ldr	r2, [r2, #0]
 8009cfa:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8009cfe:	601a      	str	r2, [r3, #0]
    }

    /* Reset CRC Calculation */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8009d00:	68fb      	ldr	r3, [r7, #12]
 8009d02:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009d04:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009d08:	d10f      	bne.n	8009d2a <HAL_SPI_Transmit_IT+0xc2>
    {
      SPI_RESET_CRC(hspi);
 8009d0a:	68fb      	ldr	r3, [r7, #12]
 8009d0c:	681b      	ldr	r3, [r3, #0]
 8009d0e:	68fa      	ldr	r2, [r7, #12]
 8009d10:	6812      	ldr	r2, [r2, #0]
 8009d12:	6812      	ldr	r2, [r2, #0]
 8009d14:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8009d18:	601a      	str	r2, [r3, #0]
 8009d1a:	68fb      	ldr	r3, [r7, #12]
 8009d1c:	681b      	ldr	r3, [r3, #0]
 8009d1e:	68fa      	ldr	r2, [r7, #12]
 8009d20:	6812      	ldr	r2, [r2, #0]
 8009d22:	6812      	ldr	r2, [r2, #0]
 8009d24:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8009d28:	601a      	str	r2, [r3, #0]
    }

    if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8009d2a:	68fb      	ldr	r3, [r7, #12]
 8009d2c:	689b      	ldr	r3, [r3, #8]
 8009d2e:	2b00      	cmp	r3, #0
 8009d30:	d108      	bne.n	8009d44 <HAL_SPI_Transmit_IT+0xdc>
    {
      __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE));
 8009d32:	68fb      	ldr	r3, [r7, #12]
 8009d34:	681b      	ldr	r3, [r3, #0]
 8009d36:	68fa      	ldr	r2, [r7, #12]
 8009d38:	6812      	ldr	r2, [r2, #0]
 8009d3a:	6852      	ldr	r2, [r2, #4]
 8009d3c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8009d40:	605a      	str	r2, [r3, #4]
 8009d42:	e007      	b.n	8009d54 <HAL_SPI_Transmit_IT+0xec>
    }else
    {
      /* Enable TXE and ERR interrupt */
      __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
 8009d44:	68fb      	ldr	r3, [r7, #12]
 8009d46:	681b      	ldr	r3, [r3, #0]
 8009d48:	68fa      	ldr	r2, [r7, #12]
 8009d4a:	6812      	ldr	r2, [r2, #0]
 8009d4c:	6852      	ldr	r2, [r2, #4]
 8009d4e:	f042 02a0 	orr.w	r2, r2, #160	; 0xa0
 8009d52:	605a      	str	r2, [r3, #4]
    }
    /* Process Unlocked */
    __HAL_UNLOCK(hspi);
 8009d54:	68fb      	ldr	r3, [r7, #12]
 8009d56:	2200      	movs	r2, #0
 8009d58:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    /* Check if the SPI is already enabled */ 
    if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 8009d5c:	68fb      	ldr	r3, [r7, #12]
 8009d5e:	681b      	ldr	r3, [r3, #0]
 8009d60:	681b      	ldr	r3, [r3, #0]
 8009d62:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009d66:	2b00      	cmp	r3, #0
 8009d68:	d107      	bne.n	8009d7a <HAL_SPI_Transmit_IT+0x112>
    {
      /* Enable SPI peripheral */
      __HAL_SPI_ENABLE(hspi);
 8009d6a:	68fb      	ldr	r3, [r7, #12]
 8009d6c:	681b      	ldr	r3, [r3, #0]
 8009d6e:	68fa      	ldr	r2, [r7, #12]
 8009d70:	6812      	ldr	r2, [r2, #0]
 8009d72:	6812      	ldr	r2, [r2, #0]
 8009d74:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8009d78:	601a      	str	r2, [r3, #0]
    }

    return HAL_OK;
 8009d7a:	2300      	movs	r3, #0
 8009d7c:	e000      	b.n	8009d80 <HAL_SPI_Transmit_IT+0x118>
  }
  else
  {
    return HAL_BUSY;
 8009d7e:	2302      	movs	r3, #2
  }
}
 8009d80:	4618      	mov	r0, r3
 8009d82:	3714      	adds	r7, #20
 8009d84:	46bd      	mov	sp, r7
 8009d86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d8a:	4770      	bx	lr

08009d8c <HAL_SPI_Receive_IT>:
  * @param  pData: pointer to data buffer
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
 8009d8c:	b580      	push	{r7, lr}
 8009d8e:	b084      	sub	sp, #16
 8009d90:	af00      	add	r7, sp, #0
 8009d92:	60f8      	str	r0, [r7, #12]
 8009d94:	60b9      	str	r1, [r7, #8]
 8009d96:	4613      	mov	r3, r2
 8009d98:	80fb      	strh	r3, [r7, #6]
  if(hspi->State == HAL_SPI_STATE_READY)
 8009d9a:	68fb      	ldr	r3, [r7, #12]
 8009d9c:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 8009da0:	b2db      	uxtb	r3, r3
 8009da2:	2b01      	cmp	r3, #1
 8009da4:	f040 8087 	bne.w	8009eb6 <HAL_SPI_Receive_IT+0x12a>
  {
    if((pData == NULL) || (Size == 0)) 
 8009da8:	68bb      	ldr	r3, [r7, #8]
 8009daa:	2b00      	cmp	r3, #0
 8009dac:	d002      	beq.n	8009db4 <HAL_SPI_Receive_IT+0x28>
 8009dae:	88fb      	ldrh	r3, [r7, #6]
 8009db0:	2b00      	cmp	r3, #0
 8009db2:	d101      	bne.n	8009db8 <HAL_SPI_Receive_IT+0x2c>
    {
      return  HAL_ERROR;
 8009db4:	2301      	movs	r3, #1
 8009db6:	e07f      	b.n	8009eb8 <HAL_SPI_Receive_IT+0x12c>
    }

    /* Process Locked */
    __HAL_LOCK(hspi);
 8009db8:	68fb      	ldr	r3, [r7, #12]
 8009dba:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 8009dbe:	2b01      	cmp	r3, #1
 8009dc0:	d101      	bne.n	8009dc6 <HAL_SPI_Receive_IT+0x3a>
 8009dc2:	2302      	movs	r3, #2
 8009dc4:	e078      	b.n	8009eb8 <HAL_SPI_Receive_IT+0x12c>
 8009dc6:	68fb      	ldr	r3, [r7, #12]
 8009dc8:	2201      	movs	r2, #1
 8009dca:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    /* Configure communication */
    hspi->State        = HAL_SPI_STATE_BUSY_RX;
 8009dce:	68fb      	ldr	r3, [r7, #12]
 8009dd0:	2222      	movs	r2, #34	; 0x22
 8009dd2:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
    hspi->ErrorCode    = HAL_SPI_ERROR_NONE;
 8009dd6:	68fb      	ldr	r3, [r7, #12]
 8009dd8:	2200      	movs	r2, #0
 8009dda:	655a      	str	r2, [r3, #84]	; 0x54

    hspi->RxISR = &SPI_RxISR;
 8009ddc:	68fa      	ldr	r2, [r7, #12]
 8009dde:	f64a 23d1 	movw	r3, #43729	; 0xaad1
 8009de2:	f6c0 0300 	movt	r3, #2048	; 0x800
 8009de6:	6493      	str	r3, [r2, #72]	; 0x48
    hspi->pRxBuffPtr   = pData;
 8009de8:	68fb      	ldr	r3, [r7, #12]
 8009dea:	68ba      	ldr	r2, [r7, #8]
 8009dec:	639a      	str	r2, [r3, #56]	; 0x38
    hspi->RxXferSize   = Size;
 8009dee:	68fb      	ldr	r3, [r7, #12]
 8009df0:	88fa      	ldrh	r2, [r7, #6]
 8009df2:	879a      	strh	r2, [r3, #60]	; 0x3c
    hspi->RxXferCount  = Size ; 
 8009df4:	68fb      	ldr	r3, [r7, #12]
 8009df6:	88fa      	ldrh	r2, [r7, #6]
 8009df8:	87da      	strh	r2, [r3, #62]	; 0x3e

   /*Init field not used in handle to zero */
    hspi->TxISR = 0;
 8009dfa:	68fb      	ldr	r3, [r7, #12]
 8009dfc:	2200      	movs	r2, #0
 8009dfe:	64da      	str	r2, [r3, #76]	; 0x4c
    hspi->TxXferSize   = 0;
 8009e00:	68fb      	ldr	r3, [r7, #12]
 8009e02:	2200      	movs	r2, #0
 8009e04:	869a      	strh	r2, [r3, #52]	; 0x34
    hspi->TxXferCount  = 0;
 8009e06:	68fb      	ldr	r3, [r7, #12]
 8009e08:	2200      	movs	r2, #0
 8009e0a:	86da      	strh	r2, [r3, #54]	; 0x36

    /* Configure communication direction : 1Line */
    if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8009e0c:	68fb      	ldr	r3, [r7, #12]
 8009e0e:	689b      	ldr	r3, [r3, #8]
 8009e10:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8009e14:	d108      	bne.n	8009e28 <HAL_SPI_Receive_IT+0x9c>
    {
       SPI_1LINE_RX(hspi);
 8009e16:	68fb      	ldr	r3, [r7, #12]
 8009e18:	681b      	ldr	r3, [r3, #0]
 8009e1a:	68fa      	ldr	r2, [r7, #12]
 8009e1c:	6812      	ldr	r2, [r2, #0]
 8009e1e:	6812      	ldr	r2, [r2, #0]
 8009e20:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8009e24:	601a      	str	r2, [r3, #0]
 8009e26:	e014      	b.n	8009e52 <HAL_SPI_Receive_IT+0xc6>
    }
    else if((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
 8009e28:	68fb      	ldr	r3, [r7, #12]
 8009e2a:	689b      	ldr	r3, [r3, #8]
 8009e2c:	2b00      	cmp	r3, #0
 8009e2e:	d110      	bne.n	8009e52 <HAL_SPI_Receive_IT+0xc6>
 8009e30:	68fb      	ldr	r3, [r7, #12]
 8009e32:	685b      	ldr	r3, [r3, #4]
 8009e34:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8009e38:	d10b      	bne.n	8009e52 <HAL_SPI_Receive_IT+0xc6>
    {
       /* Process Unlocked */
       __HAL_UNLOCK(hspi);
 8009e3a:	68fb      	ldr	r3, [r7, #12]
 8009e3c:	2200      	movs	r2, #0
 8009e3e:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

       /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
       return HAL_SPI_TransmitReceive_IT(hspi, pData, pData, Size);
 8009e42:	88fb      	ldrh	r3, [r7, #6]
 8009e44:	68f8      	ldr	r0, [r7, #12]
 8009e46:	68b9      	ldr	r1, [r7, #8]
 8009e48:	68ba      	ldr	r2, [r7, #8]
 8009e4a:	f000 f839 	bl	8009ec0 <HAL_SPI_TransmitReceive_IT>
 8009e4e:	4603      	mov	r3, r0
 8009e50:	e032      	b.n	8009eb8 <HAL_SPI_Receive_IT+0x12c>
    }

    /* Reset CRC Calculation */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8009e52:	68fb      	ldr	r3, [r7, #12]
 8009e54:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009e56:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009e5a:	d10f      	bne.n	8009e7c <HAL_SPI_Receive_IT+0xf0>
    {
      SPI_RESET_CRC(hspi);
 8009e5c:	68fb      	ldr	r3, [r7, #12]
 8009e5e:	681b      	ldr	r3, [r3, #0]
 8009e60:	68fa      	ldr	r2, [r7, #12]
 8009e62:	6812      	ldr	r2, [r2, #0]
 8009e64:	6812      	ldr	r2, [r2, #0]
 8009e66:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8009e6a:	601a      	str	r2, [r3, #0]
 8009e6c:	68fb      	ldr	r3, [r7, #12]
 8009e6e:	681b      	ldr	r3, [r3, #0]
 8009e70:	68fa      	ldr	r2, [r7, #12]
 8009e72:	6812      	ldr	r2, [r2, #0]
 8009e74:	6812      	ldr	r2, [r2, #0]
 8009e76:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8009e7a:	601a      	str	r2, [r3, #0]
    }

    /* Enable TXE and ERR interrupt */
    __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
 8009e7c:	68fb      	ldr	r3, [r7, #12]
 8009e7e:	681b      	ldr	r3, [r3, #0]
 8009e80:	68fa      	ldr	r2, [r7, #12]
 8009e82:	6812      	ldr	r2, [r2, #0]
 8009e84:	6852      	ldr	r2, [r2, #4]
 8009e86:	f042 0260 	orr.w	r2, r2, #96	; 0x60
 8009e8a:	605a      	str	r2, [r3, #4]

    /* Process Unlocked */
    __HAL_UNLOCK(hspi);
 8009e8c:	68fb      	ldr	r3, [r7, #12]
 8009e8e:	2200      	movs	r2, #0
 8009e90:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
    /* Note : The SPI must be enabled after unlocking current process 
              to avoid the risk of SPI interrupt handle execution before current
              process unlock */

        /* Check if the SPI is already enabled */ 
    if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 8009e94:	68fb      	ldr	r3, [r7, #12]
 8009e96:	681b      	ldr	r3, [r3, #0]
 8009e98:	681b      	ldr	r3, [r3, #0]
 8009e9a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009e9e:	2b00      	cmp	r3, #0
 8009ea0:	d107      	bne.n	8009eb2 <HAL_SPI_Receive_IT+0x126>
    {
      /* Enable SPI peripheral */
      __HAL_SPI_ENABLE(hspi);
 8009ea2:	68fb      	ldr	r3, [r7, #12]
 8009ea4:	681b      	ldr	r3, [r3, #0]
 8009ea6:	68fa      	ldr	r2, [r7, #12]
 8009ea8:	6812      	ldr	r2, [r2, #0]
 8009eaa:	6812      	ldr	r2, [r2, #0]
 8009eac:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8009eb0:	601a      	str	r2, [r3, #0]
    }

    return HAL_OK;
 8009eb2:	2300      	movs	r3, #0
 8009eb4:	e000      	b.n	8009eb8 <HAL_SPI_Receive_IT+0x12c>
  }
  else
  {
    return HAL_BUSY; 
 8009eb6:	2302      	movs	r3, #2
  }
}
 8009eb8:	4618      	mov	r0, r3
 8009eba:	3710      	adds	r7, #16
 8009ebc:	46bd      	mov	sp, r7
 8009ebe:	bd80      	pop	{r7, pc}

08009ec0 <HAL_SPI_TransmitReceive_IT>:
  * @param  pRxData: pointer to reception data buffer to be
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
{
 8009ec0:	b480      	push	{r7}
 8009ec2:	b087      	sub	sp, #28
 8009ec4:	af00      	add	r7, sp, #0
 8009ec6:	60f8      	str	r0, [r7, #12]
 8009ec8:	60b9      	str	r1, [r7, #8]
 8009eca:	607a      	str	r2, [r7, #4]
 8009ecc:	807b      	strh	r3, [r7, #2]
 uint32_t tmpstate = 0;
 8009ece:	2300      	movs	r3, #0
 8009ed0:	617b      	str	r3, [r7, #20]

 tmpstate = hspi->State;
 8009ed2:	68fb      	ldr	r3, [r7, #12]
 8009ed4:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 8009ed8:	b2db      	uxtb	r3, r3
 8009eda:	617b      	str	r3, [r7, #20]
  if((tmpstate == HAL_SPI_STATE_READY) || \
 8009edc:	697b      	ldr	r3, [r7, #20]
 8009ede:	2b01      	cmp	r3, #1
 8009ee0:	d00b      	beq.n	8009efa <HAL_SPI_TransmitReceive_IT+0x3a>
     ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmpstate == HAL_SPI_STATE_BUSY_RX)))
 8009ee2:	68fb      	ldr	r3, [r7, #12]
 8009ee4:	685b      	ldr	r3, [r3, #4]
HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
{
 uint32_t tmpstate = 0;

 tmpstate = hspi->State;
  if((tmpstate == HAL_SPI_STATE_READY) || \
 8009ee6:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8009eea:	d179      	bne.n	8009fe0 <HAL_SPI_TransmitReceive_IT+0x120>
     ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmpstate == HAL_SPI_STATE_BUSY_RX)))
 8009eec:	68fb      	ldr	r3, [r7, #12]
 8009eee:	689b      	ldr	r3, [r3, #8]
 8009ef0:	2b00      	cmp	r3, #0
 8009ef2:	d175      	bne.n	8009fe0 <HAL_SPI_TransmitReceive_IT+0x120>
 8009ef4:	697b      	ldr	r3, [r7, #20]
 8009ef6:	2b22      	cmp	r3, #34	; 0x22
 8009ef8:	d172      	bne.n	8009fe0 <HAL_SPI_TransmitReceive_IT+0x120>
  {
    if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0)) 
 8009efa:	68bb      	ldr	r3, [r7, #8]
 8009efc:	2b00      	cmp	r3, #0
 8009efe:	d005      	beq.n	8009f0c <HAL_SPI_TransmitReceive_IT+0x4c>
 8009f00:	687b      	ldr	r3, [r7, #4]
 8009f02:	2b00      	cmp	r3, #0
 8009f04:	d002      	beq.n	8009f0c <HAL_SPI_TransmitReceive_IT+0x4c>
 8009f06:	887b      	ldrh	r3, [r7, #2]
 8009f08:	2b00      	cmp	r3, #0
 8009f0a:	d101      	bne.n	8009f10 <HAL_SPI_TransmitReceive_IT+0x50>
    {
      return  HAL_ERROR;
 8009f0c:	2301      	movs	r3, #1
 8009f0e:	e068      	b.n	8009fe2 <HAL_SPI_TransmitReceive_IT+0x122>

    /* Check the parameters */
    assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

    /* Process locked */
    __HAL_LOCK(hspi);
 8009f10:	68fb      	ldr	r3, [r7, #12]
 8009f12:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 8009f16:	2b01      	cmp	r3, #1
 8009f18:	d101      	bne.n	8009f1e <HAL_SPI_TransmitReceive_IT+0x5e>
 8009f1a:	2302      	movs	r3, #2
 8009f1c:	e061      	b.n	8009fe2 <HAL_SPI_TransmitReceive_IT+0x122>
 8009f1e:	68fb      	ldr	r3, [r7, #12]
 8009f20:	2201      	movs	r2, #1
 8009f22:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
    if(hspi->State != HAL_SPI_STATE_BUSY_RX)
 8009f26:	68fb      	ldr	r3, [r7, #12]
 8009f28:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 8009f2c:	b2db      	uxtb	r3, r3
 8009f2e:	2b22      	cmp	r3, #34	; 0x22
 8009f30:	d003      	beq.n	8009f3a <HAL_SPI_TransmitReceive_IT+0x7a>
    {
      hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 8009f32:	68fb      	ldr	r3, [r7, #12]
 8009f34:	2232      	movs	r2, #50	; 0x32
 8009f36:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
    }

    /* Configure communication */
    hspi->ErrorCode    = HAL_SPI_ERROR_NONE;
 8009f3a:	68fb      	ldr	r3, [r7, #12]
 8009f3c:	2200      	movs	r2, #0
 8009f3e:	655a      	str	r2, [r3, #84]	; 0x54

    hspi->TxISR = &SPI_TxISR;
 8009f40:	68fa      	ldr	r2, [r7, #12]
 8009f42:	f64a 03c5 	movw	r3, #43205	; 0xa8c5
 8009f46:	f6c0 0300 	movt	r3, #2048	; 0x800
 8009f4a:	64d3      	str	r3, [r2, #76]	; 0x4c
    hspi->pTxBuffPtr   = pTxData;
 8009f4c:	68fb      	ldr	r3, [r7, #12]
 8009f4e:	68ba      	ldr	r2, [r7, #8]
 8009f50:	631a      	str	r2, [r3, #48]	; 0x30
    hspi->TxXferSize   = Size;
 8009f52:	68fb      	ldr	r3, [r7, #12]
 8009f54:	887a      	ldrh	r2, [r7, #2]
 8009f56:	869a      	strh	r2, [r3, #52]	; 0x34
    hspi->TxXferCount  = Size;
 8009f58:	68fb      	ldr	r3, [r7, #12]
 8009f5a:	887a      	ldrh	r2, [r7, #2]
 8009f5c:	86da      	strh	r2, [r3, #54]	; 0x36

    hspi->RxISR = &SPI_2LinesRxISR;
 8009f5e:	68fa      	ldr	r2, [r7, #12]
 8009f60:	f64a 2371 	movw	r3, #43633	; 0xaa71
 8009f64:	f6c0 0300 	movt	r3, #2048	; 0x800
 8009f68:	6493      	str	r3, [r2, #72]	; 0x48
    hspi->pRxBuffPtr   = pRxData;
 8009f6a:	68fb      	ldr	r3, [r7, #12]
 8009f6c:	687a      	ldr	r2, [r7, #4]
 8009f6e:	639a      	str	r2, [r3, #56]	; 0x38
    hspi->RxXferSize   = Size;
 8009f70:	68fb      	ldr	r3, [r7, #12]
 8009f72:	887a      	ldrh	r2, [r7, #2]
 8009f74:	879a      	strh	r2, [r3, #60]	; 0x3c
    hspi->RxXferCount  = Size;
 8009f76:	68fb      	ldr	r3, [r7, #12]
 8009f78:	887a      	ldrh	r2, [r7, #2]
 8009f7a:	87da      	strh	r2, [r3, #62]	; 0x3e

    /* Reset CRC Calculation */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8009f7c:	68fb      	ldr	r3, [r7, #12]
 8009f7e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009f80:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009f84:	d10f      	bne.n	8009fa6 <HAL_SPI_TransmitReceive_IT+0xe6>
    {
      SPI_RESET_CRC(hspi);
 8009f86:	68fb      	ldr	r3, [r7, #12]
 8009f88:	681b      	ldr	r3, [r3, #0]
 8009f8a:	68fa      	ldr	r2, [r7, #12]
 8009f8c:	6812      	ldr	r2, [r2, #0]
 8009f8e:	6812      	ldr	r2, [r2, #0]
 8009f90:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8009f94:	601a      	str	r2, [r3, #0]
 8009f96:	68fb      	ldr	r3, [r7, #12]
 8009f98:	681b      	ldr	r3, [r3, #0]
 8009f9a:	68fa      	ldr	r2, [r7, #12]
 8009f9c:	6812      	ldr	r2, [r2, #0]
 8009f9e:	6812      	ldr	r2, [r2, #0]
 8009fa0:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8009fa4:	601a      	str	r2, [r3, #0]
    }

    /* Enable TXE, RXNE and ERR interrupt */
    __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8009fa6:	68fb      	ldr	r3, [r7, #12]
 8009fa8:	681b      	ldr	r3, [r3, #0]
 8009faa:	68fa      	ldr	r2, [r7, #12]
 8009fac:	6812      	ldr	r2, [r2, #0]
 8009fae:	6852      	ldr	r2, [r2, #4]
 8009fb0:	f042 02e0 	orr.w	r2, r2, #224	; 0xe0
 8009fb4:	605a      	str	r2, [r3, #4]

    /* Process Unlocked */
    __HAL_UNLOCK(hspi);
 8009fb6:	68fb      	ldr	r3, [r7, #12]
 8009fb8:	2200      	movs	r2, #0
 8009fba:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    /* Check if the SPI is already enabled */ 
    if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 8009fbe:	68fb      	ldr	r3, [r7, #12]
 8009fc0:	681b      	ldr	r3, [r3, #0]
 8009fc2:	681b      	ldr	r3, [r3, #0]
 8009fc4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009fc8:	2b00      	cmp	r3, #0
 8009fca:	d107      	bne.n	8009fdc <HAL_SPI_TransmitReceive_IT+0x11c>
    {
      /* Enable SPI peripheral */
      __HAL_SPI_ENABLE(hspi);
 8009fcc:	68fb      	ldr	r3, [r7, #12]
 8009fce:	681b      	ldr	r3, [r3, #0]
 8009fd0:	68fa      	ldr	r2, [r7, #12]
 8009fd2:	6812      	ldr	r2, [r2, #0]
 8009fd4:	6812      	ldr	r2, [r2, #0]
 8009fd6:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8009fda:	601a      	str	r2, [r3, #0]
    }

    return HAL_OK;
 8009fdc:	2300      	movs	r3, #0
 8009fde:	e000      	b.n	8009fe2 <HAL_SPI_TransmitReceive_IT+0x122>
  }
  else
  {
    return HAL_BUSY; 
 8009fe0:	2302      	movs	r3, #2
  }
}
 8009fe2:	4618      	mov	r0, r3
 8009fe4:	371c      	adds	r7, #28
 8009fe6:	46bd      	mov	sp, r7
 8009fe8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009fec:	4770      	bx	lr
 8009fee:	bf00      	nop

08009ff0 <HAL_SPI_Transmit_DMA>:
  * @param  pData: pointer to data buffer
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
 8009ff0:	b580      	push	{r7, lr}
 8009ff2:	b084      	sub	sp, #16
 8009ff4:	af00      	add	r7, sp, #0
 8009ff6:	60f8      	str	r0, [r7, #12]
 8009ff8:	60b9      	str	r1, [r7, #8]
 8009ffa:	4613      	mov	r3, r2
 8009ffc:	80fb      	strh	r3, [r7, #6]
  if(hspi->State == HAL_SPI_STATE_READY)
 8009ffe:	68fb      	ldr	r3, [r7, #12]
 800a000:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 800a004:	b2db      	uxtb	r3, r3
 800a006:	2b01      	cmp	r3, #1
 800a008:	f040 8090 	bne.w	800a12c <HAL_SPI_Transmit_DMA+0x13c>
  {
    if((pData == NULL) || (Size == 0))
 800a00c:	68bb      	ldr	r3, [r7, #8]
 800a00e:	2b00      	cmp	r3, #0
 800a010:	d002      	beq.n	800a018 <HAL_SPI_Transmit_DMA+0x28>
 800a012:	88fb      	ldrh	r3, [r7, #6]
 800a014:	2b00      	cmp	r3, #0
 800a016:	d101      	bne.n	800a01c <HAL_SPI_Transmit_DMA+0x2c>
    {
      return  HAL_ERROR;
 800a018:	2301      	movs	r3, #1
 800a01a:	e088      	b.n	800a12e <HAL_SPI_Transmit_DMA+0x13e>

    /* Check the parameters */
    assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

    /* Process Locked */
    __HAL_LOCK(hspi);
 800a01c:	68fb      	ldr	r3, [r7, #12]
 800a01e:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800a022:	2b01      	cmp	r3, #1
 800a024:	d101      	bne.n	800a02a <HAL_SPI_Transmit_DMA+0x3a>
 800a026:	2302      	movs	r3, #2
 800a028:	e081      	b.n	800a12e <HAL_SPI_Transmit_DMA+0x13e>
 800a02a:	68fb      	ldr	r3, [r7, #12]
 800a02c:	2201      	movs	r2, #1
 800a02e:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    /* Configure communication */
    hspi->State       = HAL_SPI_STATE_BUSY_TX;
 800a032:	68fb      	ldr	r3, [r7, #12]
 800a034:	2212      	movs	r2, #18
 800a036:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
    hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800a03a:	68fb      	ldr	r3, [r7, #12]
 800a03c:	2200      	movs	r2, #0
 800a03e:	655a      	str	r2, [r3, #84]	; 0x54

    hspi->pTxBuffPtr  = pData;
 800a040:	68fb      	ldr	r3, [r7, #12]
 800a042:	68ba      	ldr	r2, [r7, #8]
 800a044:	631a      	str	r2, [r3, #48]	; 0x30
    hspi->TxXferSize  = Size;
 800a046:	68fb      	ldr	r3, [r7, #12]
 800a048:	88fa      	ldrh	r2, [r7, #6]
 800a04a:	869a      	strh	r2, [r3, #52]	; 0x34
    hspi->TxXferCount = Size;
 800a04c:	68fb      	ldr	r3, [r7, #12]
 800a04e:	88fa      	ldrh	r2, [r7, #6]
 800a050:	86da      	strh	r2, [r3, #54]	; 0x36

    /*Init field not used in handle to zero */
    hspi->TxISR = 0;
 800a052:	68fb      	ldr	r3, [r7, #12]
 800a054:	2200      	movs	r2, #0
 800a056:	64da      	str	r2, [r3, #76]	; 0x4c
    hspi->RxISR = 0;
 800a058:	68fb      	ldr	r3, [r7, #12]
 800a05a:	2200      	movs	r2, #0
 800a05c:	649a      	str	r2, [r3, #72]	; 0x48
    hspi->RxXferSize   = 0;
 800a05e:	68fb      	ldr	r3, [r7, #12]
 800a060:	2200      	movs	r2, #0
 800a062:	879a      	strh	r2, [r3, #60]	; 0x3c
    hspi->RxXferCount  = 0;
 800a064:	68fb      	ldr	r3, [r7, #12]
 800a066:	2200      	movs	r2, #0
 800a068:	87da      	strh	r2, [r3, #62]	; 0x3e

    /* Configure communication direction : 1Line */
    if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800a06a:	68fb      	ldr	r3, [r7, #12]
 800a06c:	689b      	ldr	r3, [r3, #8]
 800a06e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800a072:	d107      	bne.n	800a084 <HAL_SPI_Transmit_DMA+0x94>
    {
      SPI_1LINE_TX(hspi);
 800a074:	68fb      	ldr	r3, [r7, #12]
 800a076:	681b      	ldr	r3, [r3, #0]
 800a078:	68fa      	ldr	r2, [r7, #12]
 800a07a:	6812      	ldr	r2, [r2, #0]
 800a07c:	6812      	ldr	r2, [r2, #0]
 800a07e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800a082:	601a      	str	r2, [r3, #0]
    }

    /* Reset CRC Calculation */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800a084:	68fb      	ldr	r3, [r7, #12]
 800a086:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a088:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a08c:	d10f      	bne.n	800a0ae <HAL_SPI_Transmit_DMA+0xbe>
    {
      SPI_RESET_CRC(hspi);
 800a08e:	68fb      	ldr	r3, [r7, #12]
 800a090:	681b      	ldr	r3, [r3, #0]
 800a092:	68fa      	ldr	r2, [r7, #12]
 800a094:	6812      	ldr	r2, [r2, #0]
 800a096:	6812      	ldr	r2, [r2, #0]
 800a098:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800a09c:	601a      	str	r2, [r3, #0]
 800a09e:	68fb      	ldr	r3, [r7, #12]
 800a0a0:	681b      	ldr	r3, [r3, #0]
 800a0a2:	68fa      	ldr	r2, [r7, #12]
 800a0a4:	6812      	ldr	r2, [r2, #0]
 800a0a6:	6812      	ldr	r2, [r2, #0]
 800a0a8:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800a0ac:	601a      	str	r2, [r3, #0]
    }

    /* Set the SPI TxDMA Half transfer complete callback */
    hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
 800a0ae:	68fb      	ldr	r3, [r7, #12]
 800a0b0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800a0b2:	f64a 6349 	movw	r3, #44617	; 0xae49
 800a0b6:	f6c0 0300 	movt	r3, #2048	; 0x800
 800a0ba:	6413      	str	r3, [r2, #64]	; 0x40
    
    /* Set the SPI TxDMA transfer complete callback */
    hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
 800a0bc:	68fb      	ldr	r3, [r7, #12]
 800a0be:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800a0c0:	f64a 3351 	movw	r3, #43857	; 0xab51
 800a0c4:	f6c0 0300 	movt	r3, #2048	; 0x800
 800a0c8:	63d3      	str	r3, [r2, #60]	; 0x3c

    /* Set the DMA error callback */
    hspi->hdmatx->XferErrorCallback = SPI_DMAError;
 800a0ca:	68fb      	ldr	r3, [r7, #12]
 800a0cc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800a0ce:	f64a 639d 	movw	r3, #44701	; 0xae9d
 800a0d2:	f6c0 0300 	movt	r3, #2048	; 0x800
 800a0d6:	6493      	str	r3, [r2, #72]	; 0x48

    /* Enable the Tx DMA Stream */
    HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
 800a0d8:	68fb      	ldr	r3, [r7, #12]
 800a0da:	6c18      	ldr	r0, [r3, #64]	; 0x40
 800a0dc:	68fb      	ldr	r3, [r7, #12]
 800a0de:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a0e0:	4619      	mov	r1, r3
 800a0e2:	68fb      	ldr	r3, [r7, #12]
 800a0e4:	681b      	ldr	r3, [r3, #0]
 800a0e6:	330c      	adds	r3, #12
 800a0e8:	461a      	mov	r2, r3
 800a0ea:	68fb      	ldr	r3, [r7, #12]
 800a0ec:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800a0ee:	f7fa fa5b 	bl	80045a8 <HAL_DMA_Start_IT>

    /* Process Unlocked */
    __HAL_UNLOCK(hspi);
 800a0f2:	68fb      	ldr	r3, [r7, #12]
 800a0f4:	2200      	movs	r2, #0
 800a0f6:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    /* Check if the SPI is already enabled */ 
    if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 800a0fa:	68fb      	ldr	r3, [r7, #12]
 800a0fc:	681b      	ldr	r3, [r3, #0]
 800a0fe:	681b      	ldr	r3, [r3, #0]
 800a100:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800a104:	2b00      	cmp	r3, #0
 800a106:	d107      	bne.n	800a118 <HAL_SPI_Transmit_DMA+0x128>
    {
      /* Enable SPI peripheral */
      __HAL_SPI_ENABLE(hspi);
 800a108:	68fb      	ldr	r3, [r7, #12]
 800a10a:	681b      	ldr	r3, [r3, #0]
 800a10c:	68fa      	ldr	r2, [r7, #12]
 800a10e:	6812      	ldr	r2, [r2, #0]
 800a110:	6812      	ldr	r2, [r2, #0]
 800a112:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800a116:	601a      	str	r2, [r3, #0]
    }

    /* Enable Tx DMA Request */
    hspi->Instance->CR2 |= SPI_CR2_TXDMAEN;
 800a118:	68fb      	ldr	r3, [r7, #12]
 800a11a:	681b      	ldr	r3, [r3, #0]
 800a11c:	68fa      	ldr	r2, [r7, #12]
 800a11e:	6812      	ldr	r2, [r2, #0]
 800a120:	6852      	ldr	r2, [r2, #4]
 800a122:	f042 0202 	orr.w	r2, r2, #2
 800a126:	605a      	str	r2, [r3, #4]

    return HAL_OK;
 800a128:	2300      	movs	r3, #0
 800a12a:	e000      	b.n	800a12e <HAL_SPI_Transmit_DMA+0x13e>
  }
  else
  {
    return HAL_BUSY;
 800a12c:	2302      	movs	r3, #2
  }
}
 800a12e:	4618      	mov	r0, r3
 800a130:	3710      	adds	r7, #16
 800a132:	46bd      	mov	sp, r7
 800a134:	bd80      	pop	{r7, pc}
 800a136:	bf00      	nop

0800a138 <HAL_SPI_Receive_DMA>:
  * @note  When the CRC feature is enabled the pData Length must be Size + 1. 
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
 800a138:	b580      	push	{r7, lr}
 800a13a:	b084      	sub	sp, #16
 800a13c:	af00      	add	r7, sp, #0
 800a13e:	60f8      	str	r0, [r7, #12]
 800a140:	60b9      	str	r1, [r7, #8]
 800a142:	4613      	mov	r3, r2
 800a144:	80fb      	strh	r3, [r7, #6]
  if(hspi->State == HAL_SPI_STATE_READY)
 800a146:	68fb      	ldr	r3, [r7, #12]
 800a148:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 800a14c:	b2db      	uxtb	r3, r3
 800a14e:	2b01      	cmp	r3, #1
 800a150:	f040 80a6 	bne.w	800a2a0 <HAL_SPI_Receive_DMA+0x168>
  {
    if((pData == NULL) || (Size == 0))
 800a154:	68bb      	ldr	r3, [r7, #8]
 800a156:	2b00      	cmp	r3, #0
 800a158:	d002      	beq.n	800a160 <HAL_SPI_Receive_DMA+0x28>
 800a15a:	88fb      	ldrh	r3, [r7, #6]
 800a15c:	2b00      	cmp	r3, #0
 800a15e:	d101      	bne.n	800a164 <HAL_SPI_Receive_DMA+0x2c>
    {
      return  HAL_ERROR;
 800a160:	2301      	movs	r3, #1
 800a162:	e09e      	b.n	800a2a2 <HAL_SPI_Receive_DMA+0x16a>
    }

    /* Process Locked */
    __HAL_LOCK(hspi);
 800a164:	68fb      	ldr	r3, [r7, #12]
 800a166:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800a16a:	2b01      	cmp	r3, #1
 800a16c:	d101      	bne.n	800a172 <HAL_SPI_Receive_DMA+0x3a>
 800a16e:	2302      	movs	r3, #2
 800a170:	e097      	b.n	800a2a2 <HAL_SPI_Receive_DMA+0x16a>
 800a172:	68fb      	ldr	r3, [r7, #12]
 800a174:	2201      	movs	r2, #1
 800a176:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    /* Configure communication */
    hspi->State       = HAL_SPI_STATE_BUSY_RX;
 800a17a:	68fb      	ldr	r3, [r7, #12]
 800a17c:	2222      	movs	r2, #34	; 0x22
 800a17e:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
    hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800a182:	68fb      	ldr	r3, [r7, #12]
 800a184:	2200      	movs	r2, #0
 800a186:	655a      	str	r2, [r3, #84]	; 0x54

    hspi->pRxBuffPtr  = pData;
 800a188:	68fb      	ldr	r3, [r7, #12]
 800a18a:	68ba      	ldr	r2, [r7, #8]
 800a18c:	639a      	str	r2, [r3, #56]	; 0x38
    hspi->RxXferSize  = Size;
 800a18e:	68fb      	ldr	r3, [r7, #12]
 800a190:	88fa      	ldrh	r2, [r7, #6]
 800a192:	879a      	strh	r2, [r3, #60]	; 0x3c
    hspi->RxXferCount = Size;
 800a194:	68fb      	ldr	r3, [r7, #12]
 800a196:	88fa      	ldrh	r2, [r7, #6]
 800a198:	87da      	strh	r2, [r3, #62]	; 0x3e

    /*Init field not used in handle to zero */
    hspi->RxISR = 0;
 800a19a:	68fb      	ldr	r3, [r7, #12]
 800a19c:	2200      	movs	r2, #0
 800a19e:	649a      	str	r2, [r3, #72]	; 0x48
    hspi->TxISR = 0;
 800a1a0:	68fb      	ldr	r3, [r7, #12]
 800a1a2:	2200      	movs	r2, #0
 800a1a4:	64da      	str	r2, [r3, #76]	; 0x4c
    hspi->TxXferSize   = 0;
 800a1a6:	68fb      	ldr	r3, [r7, #12]
 800a1a8:	2200      	movs	r2, #0
 800a1aa:	869a      	strh	r2, [r3, #52]	; 0x34
    hspi->TxXferCount  = 0;
 800a1ac:	68fb      	ldr	r3, [r7, #12]
 800a1ae:	2200      	movs	r2, #0
 800a1b0:	86da      	strh	r2, [r3, #54]	; 0x36

    /* Configure communication direction : 1Line */
    if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800a1b2:	68fb      	ldr	r3, [r7, #12]
 800a1b4:	689b      	ldr	r3, [r3, #8]
 800a1b6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800a1ba:	d108      	bne.n	800a1ce <HAL_SPI_Receive_DMA+0x96>
    {
       SPI_1LINE_RX(hspi);
 800a1bc:	68fb      	ldr	r3, [r7, #12]
 800a1be:	681b      	ldr	r3, [r3, #0]
 800a1c0:	68fa      	ldr	r2, [r7, #12]
 800a1c2:	6812      	ldr	r2, [r2, #0]
 800a1c4:	6812      	ldr	r2, [r2, #0]
 800a1c6:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800a1ca:	601a      	str	r2, [r3, #0]
 800a1cc:	e014      	b.n	800a1f8 <HAL_SPI_Receive_DMA+0xc0>
    }
    else if((hspi->Init.Direction == SPI_DIRECTION_2LINES)&&(hspi->Init.Mode == SPI_MODE_MASTER))
 800a1ce:	68fb      	ldr	r3, [r7, #12]
 800a1d0:	689b      	ldr	r3, [r3, #8]
 800a1d2:	2b00      	cmp	r3, #0
 800a1d4:	d110      	bne.n	800a1f8 <HAL_SPI_Receive_DMA+0xc0>
 800a1d6:	68fb      	ldr	r3, [r7, #12]
 800a1d8:	685b      	ldr	r3, [r3, #4]
 800a1da:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 800a1de:	d10b      	bne.n	800a1f8 <HAL_SPI_Receive_DMA+0xc0>
    {
       /* Process Unlocked */
       __HAL_UNLOCK(hspi);
 800a1e0:	68fb      	ldr	r3, [r7, #12]
 800a1e2:	2200      	movs	r2, #0
 800a1e4:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

       /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
       return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
 800a1e8:	88fb      	ldrh	r3, [r7, #6]
 800a1ea:	68f8      	ldr	r0, [r7, #12]
 800a1ec:	68b9      	ldr	r1, [r7, #8]
 800a1ee:	68ba      	ldr	r2, [r7, #8]
 800a1f0:	f000 f85c 	bl	800a2ac <HAL_SPI_TransmitReceive_DMA>
 800a1f4:	4603      	mov	r3, r0
 800a1f6:	e054      	b.n	800a2a2 <HAL_SPI_Receive_DMA+0x16a>
    }

    /* Reset CRC Calculation */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800a1f8:	68fb      	ldr	r3, [r7, #12]
 800a1fa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a1fc:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a200:	d10f      	bne.n	800a222 <HAL_SPI_Receive_DMA+0xea>
    {
      SPI_RESET_CRC(hspi);
 800a202:	68fb      	ldr	r3, [r7, #12]
 800a204:	681b      	ldr	r3, [r3, #0]
 800a206:	68fa      	ldr	r2, [r7, #12]
 800a208:	6812      	ldr	r2, [r2, #0]
 800a20a:	6812      	ldr	r2, [r2, #0]
 800a20c:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800a210:	601a      	str	r2, [r3, #0]
 800a212:	68fb      	ldr	r3, [r7, #12]
 800a214:	681b      	ldr	r3, [r3, #0]
 800a216:	68fa      	ldr	r2, [r7, #12]
 800a218:	6812      	ldr	r2, [r2, #0]
 800a21a:	6812      	ldr	r2, [r2, #0]
 800a21c:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800a220:	601a      	str	r2, [r3, #0]
    }

    /* Set the SPI RxDMA Half transfer complete callback */
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 800a222:	68fb      	ldr	r3, [r7, #12]
 800a224:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800a226:	f64a 6365 	movw	r3, #44645	; 0xae65
 800a22a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800a22e:	6413      	str	r3, [r2, #64]	; 0x40
    
    /* Set the SPI Rx DMA transfer complete callback */
    hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
 800a230:	68fb      	ldr	r3, [r7, #12]
 800a232:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800a234:	f64a 33fd 	movw	r3, #44029	; 0xabfd
 800a238:	f6c0 0300 	movt	r3, #2048	; 0x800
 800a23c:	63d3      	str	r3, [r2, #60]	; 0x3c

    /* Set the DMA error callback */
    hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 800a23e:	68fb      	ldr	r3, [r7, #12]
 800a240:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800a242:	f64a 639d 	movw	r3, #44701	; 0xae9d
 800a246:	f6c0 0300 	movt	r3, #2048	; 0x800
 800a24a:	6493      	str	r3, [r2, #72]	; 0x48

    /* Enable the Rx DMA Stream */
    HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 800a24c:	68fb      	ldr	r3, [r7, #12]
 800a24e:	6c58      	ldr	r0, [r3, #68]	; 0x44
 800a250:	68fb      	ldr	r3, [r7, #12]
 800a252:	681b      	ldr	r3, [r3, #0]
 800a254:	330c      	adds	r3, #12
 800a256:	4619      	mov	r1, r3
 800a258:	68fb      	ldr	r3, [r7, #12]
 800a25a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800a25c:	461a      	mov	r2, r3
 800a25e:	68fb      	ldr	r3, [r7, #12]
 800a260:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800a262:	f7fa f9a1 	bl	80045a8 <HAL_DMA_Start_IT>

    /* Process Unlocked */
    __HAL_UNLOCK(hspi);
 800a266:	68fb      	ldr	r3, [r7, #12]
 800a268:	2200      	movs	r2, #0
 800a26a:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    /* Check if the SPI is already enabled */ 
    if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 800a26e:	68fb      	ldr	r3, [r7, #12]
 800a270:	681b      	ldr	r3, [r3, #0]
 800a272:	681b      	ldr	r3, [r3, #0]
 800a274:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800a278:	2b00      	cmp	r3, #0
 800a27a:	d107      	bne.n	800a28c <HAL_SPI_Receive_DMA+0x154>
    {
      /* Enable SPI peripheral */
      __HAL_SPI_ENABLE(hspi);
 800a27c:	68fb      	ldr	r3, [r7, #12]
 800a27e:	681b      	ldr	r3, [r3, #0]
 800a280:	68fa      	ldr	r2, [r7, #12]
 800a282:	6812      	ldr	r2, [r2, #0]
 800a284:	6812      	ldr	r2, [r2, #0]
 800a286:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800a28a:	601a      	str	r2, [r3, #0]
    }

    /* Enable Rx DMA Request */  
    hspi->Instance->CR2 |= SPI_CR2_RXDMAEN;
 800a28c:	68fb      	ldr	r3, [r7, #12]
 800a28e:	681b      	ldr	r3, [r3, #0]
 800a290:	68fa      	ldr	r2, [r7, #12]
 800a292:	6812      	ldr	r2, [r2, #0]
 800a294:	6852      	ldr	r2, [r2, #4]
 800a296:	f042 0201 	orr.w	r2, r2, #1
 800a29a:	605a      	str	r2, [r3, #4]

    return HAL_OK;
 800a29c:	2300      	movs	r3, #0
 800a29e:	e000      	b.n	800a2a2 <HAL_SPI_Receive_DMA+0x16a>
  }
  else
  {
    return HAL_BUSY;
 800a2a0:	2302      	movs	r3, #2
  }
}
 800a2a2:	4618      	mov	r0, r3
 800a2a4:	3710      	adds	r7, #16
 800a2a6:	46bd      	mov	sp, r7
 800a2a8:	bd80      	pop	{r7, pc}
 800a2aa:	bf00      	nop

0800a2ac <HAL_SPI_TransmitReceive_DMA>:
  * @note  When the CRC feature is enabled the pRxData Length must be Size + 1 
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
{
 800a2ac:	b580      	push	{r7, lr}
 800a2ae:	b086      	sub	sp, #24
 800a2b0:	af00      	add	r7, sp, #0
 800a2b2:	60f8      	str	r0, [r7, #12]
 800a2b4:	60b9      	str	r1, [r7, #8]
 800a2b6:	607a      	str	r2, [r7, #4]
 800a2b8:	807b      	strh	r3, [r7, #2]
  uint32_t tmpstate = 0;
 800a2ba:	2300      	movs	r3, #0
 800a2bc:	617b      	str	r3, [r7, #20]
  tmpstate = hspi->State;
 800a2be:	68fb      	ldr	r3, [r7, #12]
 800a2c0:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 800a2c4:	b2db      	uxtb	r3, r3
 800a2c6:	617b      	str	r3, [r7, #20]
  if((tmpstate == HAL_SPI_STATE_READY) || ((hspi->Init.Mode == SPI_MODE_MASTER) && \
 800a2c8:	697b      	ldr	r3, [r7, #20]
 800a2ca:	2b01      	cmp	r3, #1
 800a2cc:	d00e      	beq.n	800a2ec <HAL_SPI_TransmitReceive_DMA+0x40>
 800a2ce:	68fb      	ldr	r3, [r7, #12]
 800a2d0:	685b      	ldr	r3, [r3, #4]
 800a2d2:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 800a2d6:	f040 80d8 	bne.w	800a48a <HAL_SPI_TransmitReceive_DMA+0x1de>
     (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmpstate == HAL_SPI_STATE_BUSY_RX)))
 800a2da:	68fb      	ldr	r3, [r7, #12]
 800a2dc:	689b      	ldr	r3, [r3, #8]
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
{
  uint32_t tmpstate = 0;
  tmpstate = hspi->State;
  if((tmpstate == HAL_SPI_STATE_READY) || ((hspi->Init.Mode == SPI_MODE_MASTER) && \
 800a2de:	2b00      	cmp	r3, #0
 800a2e0:	f040 80d3 	bne.w	800a48a <HAL_SPI_TransmitReceive_DMA+0x1de>
     (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmpstate == HAL_SPI_STATE_BUSY_RX)))
 800a2e4:	697b      	ldr	r3, [r7, #20]
 800a2e6:	2b22      	cmp	r3, #34	; 0x22
 800a2e8:	f040 80cf 	bne.w	800a48a <HAL_SPI_TransmitReceive_DMA+0x1de>
  {
    if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0))
 800a2ec:	68bb      	ldr	r3, [r7, #8]
 800a2ee:	2b00      	cmp	r3, #0
 800a2f0:	d005      	beq.n	800a2fe <HAL_SPI_TransmitReceive_DMA+0x52>
 800a2f2:	687b      	ldr	r3, [r7, #4]
 800a2f4:	2b00      	cmp	r3, #0
 800a2f6:	d002      	beq.n	800a2fe <HAL_SPI_TransmitReceive_DMA+0x52>
 800a2f8:	887b      	ldrh	r3, [r7, #2]
 800a2fa:	2b00      	cmp	r3, #0
 800a2fc:	d101      	bne.n	800a302 <HAL_SPI_TransmitReceive_DMA+0x56>
    {
      return  HAL_ERROR;
 800a2fe:	2301      	movs	r3, #1
 800a300:	e0c4      	b.n	800a48c <HAL_SPI_TransmitReceive_DMA+0x1e0>

    /* Check the parameters */
    assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
    
    /* Process locked */
    __HAL_LOCK(hspi);
 800a302:	68fb      	ldr	r3, [r7, #12]
 800a304:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800a308:	2b01      	cmp	r3, #1
 800a30a:	d101      	bne.n	800a310 <HAL_SPI_TransmitReceive_DMA+0x64>
 800a30c:	2302      	movs	r3, #2
 800a30e:	e0bd      	b.n	800a48c <HAL_SPI_TransmitReceive_DMA+0x1e0>
 800a310:	68fb      	ldr	r3, [r7, #12]
 800a312:	2201      	movs	r2, #1
 800a314:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
    if(hspi->State != HAL_SPI_STATE_BUSY_RX)
 800a318:	68fb      	ldr	r3, [r7, #12]
 800a31a:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 800a31e:	b2db      	uxtb	r3, r3
 800a320:	2b22      	cmp	r3, #34	; 0x22
 800a322:	d003      	beq.n	800a32c <HAL_SPI_TransmitReceive_DMA+0x80>
    {
      hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 800a324:	68fb      	ldr	r3, [r7, #12]
 800a326:	2232      	movs	r2, #50	; 0x32
 800a328:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
    }

    /* Configure communication */
    hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800a32c:	68fb      	ldr	r3, [r7, #12]
 800a32e:	2200      	movs	r2, #0
 800a330:	655a      	str	r2, [r3, #84]	; 0x54

    hspi->pTxBuffPtr  = (uint8_t*)pTxData;
 800a332:	68fb      	ldr	r3, [r7, #12]
 800a334:	68ba      	ldr	r2, [r7, #8]
 800a336:	631a      	str	r2, [r3, #48]	; 0x30
    hspi->TxXferSize  = Size;
 800a338:	68fb      	ldr	r3, [r7, #12]
 800a33a:	887a      	ldrh	r2, [r7, #2]
 800a33c:	869a      	strh	r2, [r3, #52]	; 0x34
    hspi->TxXferCount = Size;
 800a33e:	68fb      	ldr	r3, [r7, #12]
 800a340:	887a      	ldrh	r2, [r7, #2]
 800a342:	86da      	strh	r2, [r3, #54]	; 0x36

    hspi->pRxBuffPtr  = (uint8_t*)pRxData;
 800a344:	68fb      	ldr	r3, [r7, #12]
 800a346:	687a      	ldr	r2, [r7, #4]
 800a348:	639a      	str	r2, [r3, #56]	; 0x38
    hspi->RxXferSize  = Size;
 800a34a:	68fb      	ldr	r3, [r7, #12]
 800a34c:	887a      	ldrh	r2, [r7, #2]
 800a34e:	879a      	strh	r2, [r3, #60]	; 0x3c
    hspi->RxXferCount = Size;
 800a350:	68fb      	ldr	r3, [r7, #12]
 800a352:	887a      	ldrh	r2, [r7, #2]
 800a354:	87da      	strh	r2, [r3, #62]	; 0x3e

    /*Init field not used in handle to zero */
    hspi->RxISR = 0;
 800a356:	68fb      	ldr	r3, [r7, #12]
 800a358:	2200      	movs	r2, #0
 800a35a:	649a      	str	r2, [r3, #72]	; 0x48
    hspi->TxISR = 0;
 800a35c:	68fb      	ldr	r3, [r7, #12]
 800a35e:	2200      	movs	r2, #0
 800a360:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Reset CRC Calculation */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800a362:	68fb      	ldr	r3, [r7, #12]
 800a364:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a366:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a36a:	d10f      	bne.n	800a38c <HAL_SPI_TransmitReceive_DMA+0xe0>
    {
      SPI_RESET_CRC(hspi);
 800a36c:	68fb      	ldr	r3, [r7, #12]
 800a36e:	681b      	ldr	r3, [r3, #0]
 800a370:	68fa      	ldr	r2, [r7, #12]
 800a372:	6812      	ldr	r2, [r2, #0]
 800a374:	6812      	ldr	r2, [r2, #0]
 800a376:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800a37a:	601a      	str	r2, [r3, #0]
 800a37c:	68fb      	ldr	r3, [r7, #12]
 800a37e:	681b      	ldr	r3, [r3, #0]
 800a380:	68fa      	ldr	r2, [r7, #12]
 800a382:	6812      	ldr	r2, [r2, #0]
 800a384:	6812      	ldr	r2, [r2, #0]
 800a386:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800a38a:	601a      	str	r2, [r3, #0]
    }

    /* Check if we are in Rx only or in Rx/Tx Mode and configure the DMA transfer complete callback */
    if(hspi->State == HAL_SPI_STATE_BUSY_RX)
 800a38c:	68fb      	ldr	r3, [r7, #12]
 800a38e:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 800a392:	b2db      	uxtb	r3, r3
 800a394:	2b22      	cmp	r3, #34	; 0x22
 800a396:	d10e      	bne.n	800a3b6 <HAL_SPI_TransmitReceive_DMA+0x10a>
    {
      /* Set the SPI Rx DMA Half transfer complete callback */
      hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 800a398:	68fb      	ldr	r3, [r7, #12]
 800a39a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800a39c:	f64a 6365 	movw	r3, #44645	; 0xae65
 800a3a0:	f6c0 0300 	movt	r3, #2048	; 0x800
 800a3a4:	6413      	str	r3, [r2, #64]	; 0x40
      
      hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
 800a3a6:	68fb      	ldr	r3, [r7, #12]
 800a3a8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800a3aa:	f64a 33fd 	movw	r3, #44029	; 0xabfd
 800a3ae:	f6c0 0300 	movt	r3, #2048	; 0x800
 800a3b2:	63d3      	str	r3, [r2, #60]	; 0x3c
 800a3b4:	e00d      	b.n	800a3d2 <HAL_SPI_TransmitReceive_DMA+0x126>
    }
    else
    {
      /* Set the SPI Tx/Rx DMA Half transfer complete callback */
      hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
 800a3b6:	68fb      	ldr	r3, [r7, #12]
 800a3b8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800a3ba:	f64a 6381 	movw	r3, #44673	; 0xae81
 800a3be:	f6c0 0300 	movt	r3, #2048	; 0x800
 800a3c2:	6413      	str	r3, [r2, #64]	; 0x40
  
      hspi->hdmarx->XferCpltCallback = SPI_DMATransmitReceiveCplt;
 800a3c4:	68fb      	ldr	r3, [r7, #12]
 800a3c6:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800a3c8:	f64a 53f9 	movw	r3, #44537	; 0xadf9
 800a3cc:	f6c0 0300 	movt	r3, #2048	; 0x800
 800a3d0:	63d3      	str	r3, [r2, #60]	; 0x3c
    }

    /* Set the DMA error callback */
    hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 800a3d2:	68fb      	ldr	r3, [r7, #12]
 800a3d4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800a3d6:	f64a 639d 	movw	r3, #44701	; 0xae9d
 800a3da:	f6c0 0300 	movt	r3, #2048	; 0x800
 800a3de:	6493      	str	r3, [r2, #72]	; 0x48

    /* Enable the Rx DMA Stream */
    HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 800a3e0:	68fb      	ldr	r3, [r7, #12]
 800a3e2:	6c58      	ldr	r0, [r3, #68]	; 0x44
 800a3e4:	68fb      	ldr	r3, [r7, #12]
 800a3e6:	681b      	ldr	r3, [r3, #0]
 800a3e8:	330c      	adds	r3, #12
 800a3ea:	4619      	mov	r1, r3
 800a3ec:	68fb      	ldr	r3, [r7, #12]
 800a3ee:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800a3f0:	461a      	mov	r2, r3
 800a3f2:	68fb      	ldr	r3, [r7, #12]
 800a3f4:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800a3f6:	f7fa f8d7 	bl	80045a8 <HAL_DMA_Start_IT>

    /* Enable Rx DMA Request */  
    hspi->Instance->CR2 |= SPI_CR2_RXDMAEN;
 800a3fa:	68fb      	ldr	r3, [r7, #12]
 800a3fc:	681b      	ldr	r3, [r3, #0]
 800a3fe:	68fa      	ldr	r2, [r7, #12]
 800a400:	6812      	ldr	r2, [r2, #0]
 800a402:	6852      	ldr	r2, [r2, #4]
 800a404:	f042 0201 	orr.w	r2, r2, #1
 800a408:	605a      	str	r2, [r3, #4]

    /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
    is performed in DMA reception complete callback  */
    hspi->hdmatx->XferCpltCallback = NULL;
 800a40a:	68fb      	ldr	r3, [r7, #12]
 800a40c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800a40e:	2200      	movs	r2, #0
 800a410:	63da      	str	r2, [r3, #60]	; 0x3c
    
    if(hspi->State == HAL_SPI_STATE_BUSY_TX_RX)
 800a412:	68fb      	ldr	r3, [r7, #12]
 800a414:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 800a418:	b2db      	uxtb	r3, r3
 800a41a:	2b32      	cmp	r3, #50	; 0x32
 800a41c:	d107      	bne.n	800a42e <HAL_SPI_TransmitReceive_DMA+0x182>
    {
      /* Set the DMA error callback */
      hspi->hdmatx->XferErrorCallback = SPI_DMAError;
 800a41e:	68fb      	ldr	r3, [r7, #12]
 800a420:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800a422:	f64a 639d 	movw	r3, #44701	; 0xae9d
 800a426:	f6c0 0300 	movt	r3, #2048	; 0x800
 800a42a:	6493      	str	r3, [r2, #72]	; 0x48
 800a42c:	e003      	b.n	800a436 <HAL_SPI_TransmitReceive_DMA+0x18a>
    }
    else
    {
      hspi->hdmatx->XferErrorCallback = NULL;
 800a42e:	68fb      	ldr	r3, [r7, #12]
 800a430:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800a432:	2200      	movs	r2, #0
 800a434:	649a      	str	r2, [r3, #72]	; 0x48
    }    
    
    /* Enable the Tx DMA Stream */
    HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
 800a436:	68fb      	ldr	r3, [r7, #12]
 800a438:	6c18      	ldr	r0, [r3, #64]	; 0x40
 800a43a:	68fb      	ldr	r3, [r7, #12]
 800a43c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a43e:	4619      	mov	r1, r3
 800a440:	68fb      	ldr	r3, [r7, #12]
 800a442:	681b      	ldr	r3, [r3, #0]
 800a444:	330c      	adds	r3, #12
 800a446:	461a      	mov	r2, r3
 800a448:	68fb      	ldr	r3, [r7, #12]
 800a44a:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800a44c:	f7fa f8ac 	bl	80045a8 <HAL_DMA_Start_IT>

    /* Process Unlocked */
    __HAL_UNLOCK(hspi);
 800a450:	68fb      	ldr	r3, [r7, #12]
 800a452:	2200      	movs	r2, #0
 800a454:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    /* Check if the SPI is already enabled */ 
    if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 800a458:	68fb      	ldr	r3, [r7, #12]
 800a45a:	681b      	ldr	r3, [r3, #0]
 800a45c:	681b      	ldr	r3, [r3, #0]
 800a45e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800a462:	2b00      	cmp	r3, #0
 800a464:	d107      	bne.n	800a476 <HAL_SPI_TransmitReceive_DMA+0x1ca>
    {
      /* Enable SPI peripheral */
      __HAL_SPI_ENABLE(hspi);
 800a466:	68fb      	ldr	r3, [r7, #12]
 800a468:	681b      	ldr	r3, [r3, #0]
 800a46a:	68fa      	ldr	r2, [r7, #12]
 800a46c:	6812      	ldr	r2, [r2, #0]
 800a46e:	6812      	ldr	r2, [r2, #0]
 800a470:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800a474:	601a      	str	r2, [r3, #0]
    }

    /* Enable Tx DMA Request */  
    hspi->Instance->CR2 |= SPI_CR2_TXDMAEN;
 800a476:	68fb      	ldr	r3, [r7, #12]
 800a478:	681b      	ldr	r3, [r3, #0]
 800a47a:	68fa      	ldr	r2, [r7, #12]
 800a47c:	6812      	ldr	r2, [r2, #0]
 800a47e:	6852      	ldr	r2, [r2, #4]
 800a480:	f042 0202 	orr.w	r2, r2, #2
 800a484:	605a      	str	r2, [r3, #4]

    return HAL_OK;
 800a486:	2300      	movs	r3, #0
 800a488:	e000      	b.n	800a48c <HAL_SPI_TransmitReceive_DMA+0x1e0>
  }
  else
  {
    return HAL_BUSY;
 800a48a:	2302      	movs	r3, #2
  }
}
 800a48c:	4618      	mov	r0, r3
 800a48e:	3718      	adds	r7, #24
 800a490:	46bd      	mov	sp, r7
 800a492:	bd80      	pop	{r7, pc}

0800a494 <HAL_SPI_DMAPause>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for the specified SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
{
 800a494:	b480      	push	{r7}
 800a496:	b083      	sub	sp, #12
 800a498:	af00      	add	r7, sp, #0
 800a49a:	6078      	str	r0, [r7, #4]
  /* Process Locked */
  __HAL_LOCK(hspi);
 800a49c:	687b      	ldr	r3, [r7, #4]
 800a49e:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800a4a2:	2b01      	cmp	r3, #1
 800a4a4:	d101      	bne.n	800a4aa <HAL_SPI_DMAPause+0x16>
 800a4a6:	2302      	movs	r3, #2
 800a4a8:	e018      	b.n	800a4dc <HAL_SPI_DMAPause+0x48>
 800a4aa:	687b      	ldr	r3, [r7, #4]
 800a4ac:	2201      	movs	r2, #1
 800a4ae:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
  
  /* Disable the SPI DMA Tx & Rx requests */
  hspi->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
 800a4b2:	687b      	ldr	r3, [r7, #4]
 800a4b4:	681b      	ldr	r3, [r3, #0]
 800a4b6:	687a      	ldr	r2, [r7, #4]
 800a4b8:	6812      	ldr	r2, [r2, #0]
 800a4ba:	6852      	ldr	r2, [r2, #4]
 800a4bc:	f022 0202 	bic.w	r2, r2, #2
 800a4c0:	605a      	str	r2, [r3, #4]
  hspi->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
 800a4c2:	687b      	ldr	r3, [r7, #4]
 800a4c4:	681b      	ldr	r3, [r3, #0]
 800a4c6:	687a      	ldr	r2, [r7, #4]
 800a4c8:	6812      	ldr	r2, [r2, #0]
 800a4ca:	6852      	ldr	r2, [r2, #4]
 800a4cc:	f022 0201 	bic.w	r2, r2, #1
 800a4d0:	605a      	str	r2, [r3, #4]
  
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 800a4d2:	687b      	ldr	r3, [r7, #4]
 800a4d4:	2200      	movs	r2, #0
 800a4d6:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
  
  return HAL_OK; 
 800a4da:	2300      	movs	r3, #0
}
 800a4dc:	4618      	mov	r0, r3
 800a4de:	370c      	adds	r7, #12
 800a4e0:	46bd      	mov	sp, r7
 800a4e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a4e6:	4770      	bx	lr

0800a4e8 <HAL_SPI_DMAResume>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for the specified SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
{
 800a4e8:	b480      	push	{r7}
 800a4ea:	b083      	sub	sp, #12
 800a4ec:	af00      	add	r7, sp, #0
 800a4ee:	6078      	str	r0, [r7, #4]
  /* Process Locked */
  __HAL_LOCK(hspi);
 800a4f0:	687b      	ldr	r3, [r7, #4]
 800a4f2:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800a4f6:	2b01      	cmp	r3, #1
 800a4f8:	d101      	bne.n	800a4fe <HAL_SPI_DMAResume+0x16>
 800a4fa:	2302      	movs	r3, #2
 800a4fc:	e018      	b.n	800a530 <HAL_SPI_DMAResume+0x48>
 800a4fe:	687b      	ldr	r3, [r7, #4]
 800a500:	2201      	movs	r2, #1
 800a502:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
  
  /* Enable the SPI DMA Tx & Rx requests */
  hspi->Instance->CR2 |= SPI_CR2_TXDMAEN;
 800a506:	687b      	ldr	r3, [r7, #4]
 800a508:	681b      	ldr	r3, [r3, #0]
 800a50a:	687a      	ldr	r2, [r7, #4]
 800a50c:	6812      	ldr	r2, [r2, #0]
 800a50e:	6852      	ldr	r2, [r2, #4]
 800a510:	f042 0202 	orr.w	r2, r2, #2
 800a514:	605a      	str	r2, [r3, #4]
  hspi->Instance->CR2 |= SPI_CR2_RXDMAEN;
 800a516:	687b      	ldr	r3, [r7, #4]
 800a518:	681b      	ldr	r3, [r3, #0]
 800a51a:	687a      	ldr	r2, [r7, #4]
 800a51c:	6812      	ldr	r2, [r2, #0]
 800a51e:	6852      	ldr	r2, [r2, #4]
 800a520:	f042 0201 	orr.w	r2, r2, #1
 800a524:	605a      	str	r2, [r3, #4]
  
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 800a526:	687b      	ldr	r3, [r7, #4]
 800a528:	2200      	movs	r2, #0
 800a52a:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
  
  return HAL_OK;
 800a52e:	2300      	movs	r3, #0
}
 800a530:	4618      	mov	r0, r3
 800a532:	370c      	adds	r7, #12
 800a534:	46bd      	mov	sp, r7
 800a536:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a53a:	4770      	bx	lr

0800a53c <HAL_SPI_DMAStop>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for the specified SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)
{
 800a53c:	b580      	push	{r7, lr}
 800a53e:	b082      	sub	sp, #8
 800a540:	af00      	add	r7, sp, #0
 800a542:	6078      	str	r0, [r7, #4]
     when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
     and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback()
     */
  
  /* Abort the SPI DMA tx Stream */
  if(hspi->hdmatx != NULL)
 800a544:	687b      	ldr	r3, [r7, #4]
 800a546:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800a548:	2b00      	cmp	r3, #0
 800a54a:	d004      	beq.n	800a556 <HAL_SPI_DMAStop+0x1a>
  {
    HAL_DMA_Abort(hspi->hdmatx);
 800a54c:	687b      	ldr	r3, [r7, #4]
 800a54e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800a550:	4618      	mov	r0, r3
 800a552:	f7fa f86b 	bl	800462c <HAL_DMA_Abort>
  }
  /* Abort the SPI DMA rx Stream */
  if(hspi->hdmarx != NULL)
 800a556:	687b      	ldr	r3, [r7, #4]
 800a558:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a55a:	2b00      	cmp	r3, #0
 800a55c:	d004      	beq.n	800a568 <HAL_SPI_DMAStop+0x2c>
  {
    HAL_DMA_Abort(hspi->hdmarx);
 800a55e:	687b      	ldr	r3, [r7, #4]
 800a560:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a562:	4618      	mov	r0, r3
 800a564:	f7fa f862 	bl	800462c <HAL_DMA_Abort>
  }
  
  /* Disable the SPI DMA Tx & Rx requests */
  hspi->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
 800a568:	687b      	ldr	r3, [r7, #4]
 800a56a:	681b      	ldr	r3, [r3, #0]
 800a56c:	687a      	ldr	r2, [r7, #4]
 800a56e:	6812      	ldr	r2, [r2, #0]
 800a570:	6852      	ldr	r2, [r2, #4]
 800a572:	f022 0202 	bic.w	r2, r2, #2
 800a576:	605a      	str	r2, [r3, #4]
  hspi->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
 800a578:	687b      	ldr	r3, [r7, #4]
 800a57a:	681b      	ldr	r3, [r3, #0]
 800a57c:	687a      	ldr	r2, [r7, #4]
 800a57e:	6812      	ldr	r2, [r2, #0]
 800a580:	6852      	ldr	r2, [r2, #4]
 800a582:	f022 0201 	bic.w	r2, r2, #1
 800a586:	605a      	str	r2, [r3, #4]
  
  hspi->State = HAL_SPI_STATE_READY;
 800a588:	687b      	ldr	r3, [r7, #4]
 800a58a:	2201      	movs	r2, #1
 800a58c:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
  
  return HAL_OK;
 800a590:	2300      	movs	r3, #0
}
 800a592:	4618      	mov	r0, r3
 800a594:	3708      	adds	r7, #8
 800a596:	46bd      	mov	sp, r7
 800a598:	bd80      	pop	{r7, pc}
 800a59a:	bf00      	nop

0800a59c <HAL_SPI_IRQHandler>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval HAL status
  */
void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
{
 800a59c:	b580      	push	{r7, lr}
 800a59e:	b088      	sub	sp, #32
 800a5a0:	af00      	add	r7, sp, #0
 800a5a2:	6078      	str	r0, [r7, #4]
  uint32_t tmp1 = 0, tmp2 = 0, tmp3 = 0;
 800a5a4:	2300      	movs	r3, #0
 800a5a6:	61fb      	str	r3, [r7, #28]
 800a5a8:	2300      	movs	r3, #0
 800a5aa:	61bb      	str	r3, [r7, #24]
 800a5ac:	2300      	movs	r3, #0
 800a5ae:	617b      	str	r3, [r7, #20]

  tmp1 = __HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE);
 800a5b0:	687b      	ldr	r3, [r7, #4]
 800a5b2:	681b      	ldr	r3, [r3, #0]
 800a5b4:	689b      	ldr	r3, [r3, #8]
 800a5b6:	f003 0301 	and.w	r3, r3, #1
 800a5ba:	2b00      	cmp	r3, #0
 800a5bc:	bf0c      	ite	eq
 800a5be:	2300      	moveq	r3, #0
 800a5c0:	2301      	movne	r3, #1
 800a5c2:	b2db      	uxtb	r3, r3
 800a5c4:	61fb      	str	r3, [r7, #28]
  tmp2 = __HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_RXNE);
 800a5c6:	687b      	ldr	r3, [r7, #4]
 800a5c8:	681b      	ldr	r3, [r3, #0]
 800a5ca:	685b      	ldr	r3, [r3, #4]
 800a5cc:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800a5d0:	2b00      	cmp	r3, #0
 800a5d2:	bf0c      	ite	eq
 800a5d4:	2300      	moveq	r3, #0
 800a5d6:	2301      	movne	r3, #1
 800a5d8:	b2db      	uxtb	r3, r3
 800a5da:	61bb      	str	r3, [r7, #24]
  tmp3 = __HAL_SPI_GET_FLAG(hspi, SPI_FLAG_OVR);
 800a5dc:	687b      	ldr	r3, [r7, #4]
 800a5de:	681b      	ldr	r3, [r3, #0]
 800a5e0:	689b      	ldr	r3, [r3, #8]
 800a5e2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800a5e6:	2b00      	cmp	r3, #0
 800a5e8:	bf0c      	ite	eq
 800a5ea:	2300      	moveq	r3, #0
 800a5ec:	2301      	movne	r3, #1
 800a5ee:	b2db      	uxtb	r3, r3
 800a5f0:	617b      	str	r3, [r7, #20]
  /* SPI in mode Receiver and Overrun not occurred ---------------------------*/
  if((tmp1 != RESET) && (tmp2 != RESET) && (tmp3 == RESET))
 800a5f2:	69fb      	ldr	r3, [r7, #28]
 800a5f4:	2b00      	cmp	r3, #0
 800a5f6:	d00a      	beq.n	800a60e <HAL_SPI_IRQHandler+0x72>
 800a5f8:	69bb      	ldr	r3, [r7, #24]
 800a5fa:	2b00      	cmp	r3, #0
 800a5fc:	d007      	beq.n	800a60e <HAL_SPI_IRQHandler+0x72>
 800a5fe:	697b      	ldr	r3, [r7, #20]
 800a600:	2b00      	cmp	r3, #0
 800a602:	d104      	bne.n	800a60e <HAL_SPI_IRQHandler+0x72>
  {
    hspi->RxISR(hspi);
 800a604:	687b      	ldr	r3, [r7, #4]
 800a606:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a608:	6878      	ldr	r0, [r7, #4]
 800a60a:	4798      	blx	r3
    return;
 800a60c:	e08c      	b.n	800a728 <HAL_SPI_IRQHandler+0x18c>
  } 

  tmp1 = __HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE);
 800a60e:	687b      	ldr	r3, [r7, #4]
 800a610:	681b      	ldr	r3, [r3, #0]
 800a612:	689b      	ldr	r3, [r3, #8]
 800a614:	f003 0302 	and.w	r3, r3, #2
 800a618:	2b00      	cmp	r3, #0
 800a61a:	bf0c      	ite	eq
 800a61c:	2300      	moveq	r3, #0
 800a61e:	2301      	movne	r3, #1
 800a620:	b2db      	uxtb	r3, r3
 800a622:	61fb      	str	r3, [r7, #28]
  tmp2 = __HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_TXE);
 800a624:	687b      	ldr	r3, [r7, #4]
 800a626:	681b      	ldr	r3, [r3, #0]
 800a628:	685b      	ldr	r3, [r3, #4]
 800a62a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800a62e:	2b00      	cmp	r3, #0
 800a630:	bf0c      	ite	eq
 800a632:	2300      	moveq	r3, #0
 800a634:	2301      	movne	r3, #1
 800a636:	b2db      	uxtb	r3, r3
 800a638:	61bb      	str	r3, [r7, #24]
  /* SPI in mode Transmitter ---------------------------------------------------*/
  if((tmp1 != RESET) && (tmp2 != RESET))
 800a63a:	69fb      	ldr	r3, [r7, #28]
 800a63c:	2b00      	cmp	r3, #0
 800a63e:	d007      	beq.n	800a650 <HAL_SPI_IRQHandler+0xb4>
 800a640:	69bb      	ldr	r3, [r7, #24]
 800a642:	2b00      	cmp	r3, #0
 800a644:	d004      	beq.n	800a650 <HAL_SPI_IRQHandler+0xb4>
  {
    hspi->TxISR(hspi);
 800a646:	687b      	ldr	r3, [r7, #4]
 800a648:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800a64a:	6878      	ldr	r0, [r7, #4]
 800a64c:	4798      	blx	r3
    return;
 800a64e:	e06b      	b.n	800a728 <HAL_SPI_IRQHandler+0x18c>
  }

  if(__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_ERR) != RESET)
 800a650:	687b      	ldr	r3, [r7, #4]
 800a652:	681b      	ldr	r3, [r3, #0]
 800a654:	685b      	ldr	r3, [r3, #4]
 800a656:	f003 0320 	and.w	r3, r3, #32
 800a65a:	2b00      	cmp	r3, #0
 800a65c:	d064      	beq.n	800a728 <HAL_SPI_IRQHandler+0x18c>
  {
    /* SPI CRC error interrupt occurred ---------------------------------------*/
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 800a65e:	687b      	ldr	r3, [r7, #4]
 800a660:	681b      	ldr	r3, [r3, #0]
 800a662:	689b      	ldr	r3, [r3, #8]
 800a664:	f003 0310 	and.w	r3, r3, #16
 800a668:	2b00      	cmp	r3, #0
 800a66a:	d00a      	beq.n	800a682 <HAL_SPI_IRQHandler+0xe6>
    {
      hspi->ErrorCode |= HAL_SPI_ERROR_CRC;
 800a66c:	687b      	ldr	r3, [r7, #4]
 800a66e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a670:	f043 0202 	orr.w	r2, r3, #2
 800a674:	687b      	ldr	r3, [r7, #4]
 800a676:	655a      	str	r2, [r3, #84]	; 0x54
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 800a678:	687b      	ldr	r3, [r7, #4]
 800a67a:	681b      	ldr	r3, [r3, #0]
 800a67c:	f06f 0210 	mvn.w	r2, #16
 800a680:	609a      	str	r2, [r3, #8]
    }
    /* SPI Mode Fault error interrupt occurred --------------------------------*/
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_MODF) != RESET)
 800a682:	687b      	ldr	r3, [r7, #4]
 800a684:	681b      	ldr	r3, [r3, #0]
 800a686:	689b      	ldr	r3, [r3, #8]
 800a688:	f003 0320 	and.w	r3, r3, #32
 800a68c:	2b00      	cmp	r3, #0
 800a68e:	d012      	beq.n	800a6b6 <HAL_SPI_IRQHandler+0x11a>
    {
      hspi->ErrorCode |= HAL_SPI_ERROR_MODF;
 800a690:	687b      	ldr	r3, [r7, #4]
 800a692:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a694:	f043 0201 	orr.w	r2, r3, #1
 800a698:	687b      	ldr	r3, [r7, #4]
 800a69a:	655a      	str	r2, [r3, #84]	; 0x54
      __HAL_SPI_CLEAR_MODFFLAG(hspi);
 800a69c:	687b      	ldr	r3, [r7, #4]
 800a69e:	681b      	ldr	r3, [r3, #0]
 800a6a0:	689b      	ldr	r3, [r3, #8]
 800a6a2:	613b      	str	r3, [r7, #16]
 800a6a4:	687b      	ldr	r3, [r7, #4]
 800a6a6:	681b      	ldr	r3, [r3, #0]
 800a6a8:	687a      	ldr	r2, [r7, #4]
 800a6aa:	6812      	ldr	r2, [r2, #0]
 800a6ac:	6812      	ldr	r2, [r2, #0]
 800a6ae:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800a6b2:	601a      	str	r2, [r3, #0]
 800a6b4:	693b      	ldr	r3, [r7, #16]
    }
    
    /* SPI Overrun error interrupt occurred -----------------------------------*/
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_OVR) != RESET)
 800a6b6:	687b      	ldr	r3, [r7, #4]
 800a6b8:	681b      	ldr	r3, [r3, #0]
 800a6ba:	689b      	ldr	r3, [r3, #8]
 800a6bc:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800a6c0:	2b00      	cmp	r3, #0
 800a6c2:	d014      	beq.n	800a6ee <HAL_SPI_IRQHandler+0x152>
    {
      if(hspi->State != HAL_SPI_STATE_BUSY_TX)
 800a6c4:	687b      	ldr	r3, [r7, #4]
 800a6c6:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 800a6ca:	b2db      	uxtb	r3, r3
 800a6cc:	2b12      	cmp	r3, #18
 800a6ce:	d00e      	beq.n	800a6ee <HAL_SPI_IRQHandler+0x152>
      {
        hspi->ErrorCode |= HAL_SPI_ERROR_OVR;
 800a6d0:	687b      	ldr	r3, [r7, #4]
 800a6d2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a6d4:	f043 0204 	orr.w	r2, r3, #4
 800a6d8:	687b      	ldr	r3, [r7, #4]
 800a6da:	655a      	str	r2, [r3, #84]	; 0x54
        __HAL_SPI_CLEAR_OVRFLAG(hspi);      
 800a6dc:	687b      	ldr	r3, [r7, #4]
 800a6de:	681b      	ldr	r3, [r3, #0]
 800a6e0:	68db      	ldr	r3, [r3, #12]
 800a6e2:	60fb      	str	r3, [r7, #12]
 800a6e4:	687b      	ldr	r3, [r7, #4]
 800a6e6:	681b      	ldr	r3, [r3, #0]
 800a6e8:	689b      	ldr	r3, [r3, #8]
 800a6ea:	60fb      	str	r3, [r7, #12]
 800a6ec:	68fb      	ldr	r3, [r7, #12]
      }
    }

    /* SPI Frame error interrupt occurred -------------------------------------*/
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_FRE) != RESET)
 800a6ee:	687b      	ldr	r3, [r7, #4]
 800a6f0:	681b      	ldr	r3, [r3, #0]
 800a6f2:	689b      	ldr	r3, [r3, #8]
 800a6f4:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800a6f8:	2b00      	cmp	r3, #0
 800a6fa:	d00a      	beq.n	800a712 <HAL_SPI_IRQHandler+0x176>
    {
      hspi->ErrorCode |= HAL_SPI_ERROR_FRE;
 800a6fc:	687b      	ldr	r3, [r7, #4]
 800a6fe:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a700:	f043 0208 	orr.w	r2, r3, #8
 800a704:	687b      	ldr	r3, [r7, #4]
 800a706:	655a      	str	r2, [r3, #84]	; 0x54
      __HAL_SPI_CLEAR_FREFLAG(hspi);
 800a708:	687b      	ldr	r3, [r7, #4]
 800a70a:	681b      	ldr	r3, [r3, #0]
 800a70c:	689b      	ldr	r3, [r3, #8]
 800a70e:	60bb      	str	r3, [r7, #8]
 800a710:	68bb      	ldr	r3, [r7, #8]
    }

    /* Call the Error call Back in case of Errors */
    if(hspi->ErrorCode!=HAL_SPI_ERROR_NONE)
 800a712:	687b      	ldr	r3, [r7, #4]
 800a714:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a716:	2b00      	cmp	r3, #0
 800a718:	d006      	beq.n	800a728 <HAL_SPI_IRQHandler+0x18c>
    {
      hspi->State = HAL_SPI_STATE_READY;
 800a71a:	687b      	ldr	r3, [r7, #4]
 800a71c:	2201      	movs	r2, #1
 800a71e:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
      HAL_SPI_ErrorCallback(hspi);
 800a722:	6878      	ldr	r0, [r7, #4]
 800a724:	f000 f840 	bl	800a7a8 <HAL_SPI_ErrorCallback>
    }
  }
}
 800a728:	3720      	adds	r7, #32
 800a72a:	46bd      	mov	sp, r7
 800a72c:	bd80      	pop	{r7, pc}
 800a72e:	bf00      	nop

0800a730 <HAL_SPI_TxCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
{
 800a730:	b480      	push	{r7}
 800a732:	b083      	sub	sp, #12
 800a734:	af00      	add	r7, sp, #0
 800a736:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SPI_TxCpltCallback could be implemented in the user file
   */
}
 800a738:	370c      	adds	r7, #12
 800a73a:	46bd      	mov	sp, r7
 800a73c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a740:	4770      	bx	lr
 800a742:	bf00      	nop

0800a744 <HAL_SPI_RxCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
{
 800a744:	b480      	push	{r7}
 800a746:	b083      	sub	sp, #12
 800a748:	af00      	add	r7, sp, #0
 800a74a:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SPI_RxCpltCallback() could be implemented in the user file
   */
}
 800a74c:	370c      	adds	r7, #12
 800a74e:	46bd      	mov	sp, r7
 800a750:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a754:	4770      	bx	lr
 800a756:	bf00      	nop

0800a758 <HAL_SPI_TxRxCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
{
 800a758:	b480      	push	{r7}
 800a75a:	b083      	sub	sp, #12
 800a75c:	af00      	add	r7, sp, #0
 800a75e:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SPI_TxRxCpltCallback() could be implemented in the user file
   */
}
 800a760:	370c      	adds	r7, #12
 800a762:	46bd      	mov	sp, r7
 800a764:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a768:	4770      	bx	lr
 800a76a:	bf00      	nop

0800a76c <HAL_SPI_TxHalfCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi)
{
 800a76c:	b480      	push	{r7}
 800a76e:	b083      	sub	sp, #12
 800a770:	af00      	add	r7, sp, #0
 800a772:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SPI_TxHalfCpltCallback could be implemented in the user file
   */
}
 800a774:	370c      	adds	r7, #12
 800a776:	46bd      	mov	sp, r7
 800a778:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a77c:	4770      	bx	lr
 800a77e:	bf00      	nop

0800a780 <HAL_SPI_RxHalfCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
{
 800a780:	b480      	push	{r7}
 800a782:	b083      	sub	sp, #12
 800a784:	af00      	add	r7, sp, #0
 800a786:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SPI_RxHalfCpltCallback() could be implemented in the user file
   */
}
 800a788:	370c      	adds	r7, #12
 800a78a:	46bd      	mov	sp, r7
 800a78c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a790:	4770      	bx	lr
 800a792:	bf00      	nop

0800a794 <HAL_SPI_TxRxHalfCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
{
 800a794:	b480      	push	{r7}
 800a796:	b083      	sub	sp, #12
 800a798:	af00      	add	r7, sp, #0
 800a79a:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SPI_TxRxHalfCpltCallback() could be implemented in the user file
   */
}
 800a79c:	370c      	adds	r7, #12
 800a79e:	46bd      	mov	sp, r7
 800a7a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a7a4:	4770      	bx	lr
 800a7a6:	bf00      	nop

0800a7a8 <HAL_SPI_ErrorCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval None
  */
 __weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
{
 800a7a8:	b480      	push	{r7}
 800a7aa:	b083      	sub	sp, #12
 800a7ac:	af00      	add	r7, sp, #0
 800a7ae:	6078      	str	r0, [r7, #4]
  /* NOTE : - This function Should not be modified, when the callback is needed,
            the HAL_SPI_ErrorCallback() could be implemented in the user file.
            - The ErrorCode parameter in the hspi handle is updated by the SPI processes
            and user can use HAL_SPI_GetError() API to check the latest error occurred.
   */
}
 800a7b0:	370c      	adds	r7, #12
 800a7b2:	46bd      	mov	sp, r7
 800a7b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a7b8:	4770      	bx	lr
 800a7ba:	bf00      	nop

0800a7bc <HAL_SPI_GetState>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval HAL state
  */
HAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)
{
 800a7bc:	b480      	push	{r7}
 800a7be:	b083      	sub	sp, #12
 800a7c0:	af00      	add	r7, sp, #0
 800a7c2:	6078      	str	r0, [r7, #4]
  return hspi->State;
 800a7c4:	687b      	ldr	r3, [r7, #4]
 800a7c6:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 800a7ca:	b2db      	uxtb	r3, r3
}
 800a7cc:	4618      	mov	r0, r3
 800a7ce:	370c      	adds	r7, #12
 800a7d0:	46bd      	mov	sp, r7
 800a7d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a7d6:	4770      	bx	lr

0800a7d8 <HAL_SPI_GetError>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval SPI Error Code
  */
uint32_t HAL_SPI_GetError(SPI_HandleTypeDef *hspi)
{
 800a7d8:	b480      	push	{r7}
 800a7da:	b083      	sub	sp, #12
 800a7dc:	af00      	add	r7, sp, #0
 800a7de:	6078      	str	r0, [r7, #4]
  return hspi->ErrorCode;
 800a7e0:	687b      	ldr	r3, [r7, #4]
 800a7e2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
}
 800a7e4:	4618      	mov	r0, r3
 800a7e6:	370c      	adds	r7, #12
 800a7e8:	46bd      	mov	sp, r7
 800a7ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a7ee:	4770      	bx	lr

0800a7f0 <SPI_TxCloseIRQHandler>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval void
  */
static void SPI_TxCloseIRQHandler(SPI_HandleTypeDef *hspi)
{
 800a7f0:	b580      	push	{r7, lr}
 800a7f2:	b084      	sub	sp, #16
 800a7f4:	af00      	add	r7, sp, #0
 800a7f6:	6078      	str	r0, [r7, #4]
  /* Wait until TXE flag is set to send data */
  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
 800a7f8:	6878      	ldr	r0, [r7, #4]
 800a7fa:	2102      	movs	r1, #2
 800a7fc:	2200      	movs	r2, #0
 800a7fe:	230a      	movs	r3, #10
 800a800:	f000 fb6a 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 800a804:	4603      	mov	r3, r0
 800a806:	2b00      	cmp	r3, #0
 800a808:	d005      	beq.n	800a816 <SPI_TxCloseIRQHandler+0x26>
  {
    hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 800a80a:	687b      	ldr	r3, [r7, #4]
 800a80c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a80e:	f043 0220 	orr.w	r2, r3, #32
 800a812:	687b      	ldr	r3, [r7, #4]
 800a814:	655a      	str	r2, [r3, #84]	; 0x54
  }

  /* Disable TXE interrupt */
  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE ));
 800a816:	687b      	ldr	r3, [r7, #4]
 800a818:	681b      	ldr	r3, [r3, #0]
 800a81a:	687a      	ldr	r2, [r7, #4]
 800a81c:	6812      	ldr	r2, [r2, #0]
 800a81e:	6852      	ldr	r2, [r2, #4]
 800a820:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800a824:	605a      	str	r2, [r3, #4]

  /* Disable ERR interrupt if Receive process is finished */
  if(__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_RXNE) == RESET)
 800a826:	687b      	ldr	r3, [r7, #4]
 800a828:	681b      	ldr	r3, [r3, #0]
 800a82a:	685b      	ldr	r3, [r3, #4]
 800a82c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800a830:	2b00      	cmp	r3, #0
 800a832:	d144      	bne.n	800a8be <SPI_TxCloseIRQHandler+0xce>
  {
    __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_ERR));
 800a834:	687b      	ldr	r3, [r7, #4]
 800a836:	681b      	ldr	r3, [r3, #0]
 800a838:	687a      	ldr	r2, [r7, #4]
 800a83a:	6812      	ldr	r2, [r2, #0]
 800a83c:	6852      	ldr	r2, [r2, #4]
 800a83e:	f022 0220 	bic.w	r2, r2, #32
 800a842:	605a      	str	r2, [r3, #4]

    /* Wait until Busy flag is reset before disabling SPI */
    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, SPI_TIMEOUT_VALUE) != HAL_OK)
 800a844:	6878      	ldr	r0, [r7, #4]
 800a846:	2180      	movs	r1, #128	; 0x80
 800a848:	2201      	movs	r2, #1
 800a84a:	230a      	movs	r3, #10
 800a84c:	f000 fb44 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 800a850:	4603      	mov	r3, r0
 800a852:	2b00      	cmp	r3, #0
 800a854:	d005      	beq.n	800a862 <SPI_TxCloseIRQHandler+0x72>
    {
      hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 800a856:	687b      	ldr	r3, [r7, #4]
 800a858:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a85a:	f043 0220 	orr.w	r2, r3, #32
 800a85e:	687b      	ldr	r3, [r7, #4]
 800a860:	655a      	str	r2, [r3, #84]	; 0x54
    }

    /* Clear OVERRUN flag in 2 Lines communication mode because received is not read */
    if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
 800a862:	687b      	ldr	r3, [r7, #4]
 800a864:	689b      	ldr	r3, [r3, #8]
 800a866:	2b00      	cmp	r3, #0
 800a868:	d108      	bne.n	800a87c <SPI_TxCloseIRQHandler+0x8c>
    {
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800a86a:	687b      	ldr	r3, [r7, #4]
 800a86c:	681b      	ldr	r3, [r3, #0]
 800a86e:	68db      	ldr	r3, [r3, #12]
 800a870:	60fb      	str	r3, [r7, #12]
 800a872:	687b      	ldr	r3, [r7, #4]
 800a874:	681b      	ldr	r3, [r3, #0]
 800a876:	689b      	ldr	r3, [r3, #8]
 800a878:	60fb      	str	r3, [r7, #12]
 800a87a:	68fb      	ldr	r3, [r7, #12]
    }
    
    /* Check if Errors has been detected during transfer */
    if(hspi->ErrorCode ==  HAL_SPI_ERROR_NONE)
 800a87c:	687b      	ldr	r3, [r7, #4]
 800a87e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a880:	2b00      	cmp	r3, #0
 800a882:	d115      	bne.n	800a8b0 <SPI_TxCloseIRQHandler+0xc0>
    {
      /* Check if we are in Tx or in Rx/Tx Mode */
      if(hspi->State == HAL_SPI_STATE_BUSY_TX_RX)
 800a884:	687b      	ldr	r3, [r7, #4]
 800a886:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 800a88a:	b2db      	uxtb	r3, r3
 800a88c:	2b32      	cmp	r3, #50	; 0x32
 800a88e:	d107      	bne.n	800a8a0 <SPI_TxCloseIRQHandler+0xb0>
      {
        /* Set state to READY before run the Callback Complete */
        hspi->State = HAL_SPI_STATE_READY;
 800a890:	687b      	ldr	r3, [r7, #4]
 800a892:	2201      	movs	r2, #1
 800a894:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
        HAL_SPI_TxRxCpltCallback(hspi);
 800a898:	6878      	ldr	r0, [r7, #4]
 800a89a:	f7ff ff5d 	bl	800a758 <HAL_SPI_TxRxCpltCallback>
 800a89e:	e00e      	b.n	800a8be <SPI_TxCloseIRQHandler+0xce>
      }
      else
      {
        /* Set state to READY before run the Callback Complete */
        hspi->State = HAL_SPI_STATE_READY;
 800a8a0:	687b      	ldr	r3, [r7, #4]
 800a8a2:	2201      	movs	r2, #1
 800a8a4:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
        HAL_SPI_TxCpltCallback(hspi);
 800a8a8:	6878      	ldr	r0, [r7, #4]
 800a8aa:	f7ff ff41 	bl	800a730 <HAL_SPI_TxCpltCallback>
 800a8ae:	e006      	b.n	800a8be <SPI_TxCloseIRQHandler+0xce>
      }
    }
    else
    {
      /* Set state to READY before run the Callback Complete */
      hspi->State = HAL_SPI_STATE_READY;
 800a8b0:	687b      	ldr	r3, [r7, #4]
 800a8b2:	2201      	movs	r2, #1
 800a8b4:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
      /* Call Error call back in case of Error */
      HAL_SPI_ErrorCallback(hspi);
 800a8b8:	6878      	ldr	r0, [r7, #4]
 800a8ba:	f7ff ff75 	bl	800a7a8 <HAL_SPI_ErrorCallback>
    }
  }
}
 800a8be:	3710      	adds	r7, #16
 800a8c0:	46bd      	mov	sp, r7
 800a8c2:	bd80      	pop	{r7, pc}

0800a8c4 <SPI_TxISR>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval void
  */
static void SPI_TxISR(SPI_HandleTypeDef *hspi)
{
 800a8c4:	b580      	push	{r7, lr}
 800a8c6:	b082      	sub	sp, #8
 800a8c8:	af00      	add	r7, sp, #0
 800a8ca:	6078      	str	r0, [r7, #4]
  /* Transmit data in 8 Bit mode */
  if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
 800a8cc:	687b      	ldr	r3, [r7, #4]
 800a8ce:	68db      	ldr	r3, [r3, #12]
 800a8d0:	2b00      	cmp	r3, #0
 800a8d2:	d109      	bne.n	800a8e8 <SPI_TxISR+0x24>
  {
    hspi->Instance->DR = (*hspi->pTxBuffPtr++);
 800a8d4:	687b      	ldr	r3, [r7, #4]
 800a8d6:	681a      	ldr	r2, [r3, #0]
 800a8d8:	687b      	ldr	r3, [r7, #4]
 800a8da:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a8dc:	1c58      	adds	r0, r3, #1
 800a8de:	6879      	ldr	r1, [r7, #4]
 800a8e0:	6308      	str	r0, [r1, #48]	; 0x30
 800a8e2:	781b      	ldrb	r3, [r3, #0]
 800a8e4:	60d3      	str	r3, [r2, #12]
 800a8e6:	e00a      	b.n	800a8fe <SPI_TxISR+0x3a>
  }
  /* Transmit data in 16 Bit mode */
  else
  {
    hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
 800a8e8:	687b      	ldr	r3, [r7, #4]
 800a8ea:	681b      	ldr	r3, [r3, #0]
 800a8ec:	687a      	ldr	r2, [r7, #4]
 800a8ee:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800a8f0:	8812      	ldrh	r2, [r2, #0]
 800a8f2:	60da      	str	r2, [r3, #12]
    hspi->pTxBuffPtr+=2;
 800a8f4:	687b      	ldr	r3, [r7, #4]
 800a8f6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a8f8:	1c9a      	adds	r2, r3, #2
 800a8fa:	687b      	ldr	r3, [r7, #4]
 800a8fc:	631a      	str	r2, [r3, #48]	; 0x30
  }
  hspi->TxXferCount--;
 800a8fe:	687b      	ldr	r3, [r7, #4]
 800a900:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800a902:	3b01      	subs	r3, #1
 800a904:	b29a      	uxth	r2, r3
 800a906:	687b      	ldr	r3, [r7, #4]
 800a908:	86da      	strh	r2, [r3, #54]	; 0x36

  if(hspi->TxXferCount == 0)
 800a90a:	687b      	ldr	r3, [r7, #4]
 800a90c:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800a90e:	2b00      	cmp	r3, #0
 800a910:	d10f      	bne.n	800a932 <SPI_TxISR+0x6e>
  {
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800a912:	687b      	ldr	r3, [r7, #4]
 800a914:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a916:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a91a:	d107      	bne.n	800a92c <SPI_TxISR+0x68>
    {
      /* calculate and transfer CRC on Tx line */
      hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 800a91c:	687b      	ldr	r3, [r7, #4]
 800a91e:	681b      	ldr	r3, [r3, #0]
 800a920:	687a      	ldr	r2, [r7, #4]
 800a922:	6812      	ldr	r2, [r2, #0]
 800a924:	6812      	ldr	r2, [r2, #0]
 800a926:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800a92a:	601a      	str	r2, [r3, #0]
    }
    SPI_TxCloseIRQHandler(hspi);
 800a92c:	6878      	ldr	r0, [r7, #4]
 800a92e:	f7ff ff5f 	bl	800a7f0 <SPI_TxCloseIRQHandler>
  }
}
 800a932:	3708      	adds	r7, #8
 800a934:	46bd      	mov	sp, r7
 800a936:	bd80      	pop	{r7, pc}

0800a938 <SPI_RxCloseIRQHandler>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval void
  */
static void SPI_RxCloseIRQHandler(SPI_HandleTypeDef *hspi)
{
 800a938:	b580      	push	{r7, lr}
 800a93a:	b084      	sub	sp, #16
 800a93c:	af00      	add	r7, sp, #0
 800a93e:	6078      	str	r0, [r7, #4]
  __IO uint16_t tmpreg;

  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800a940:	687b      	ldr	r3, [r7, #4]
 800a942:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a944:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a948:	d140      	bne.n	800a9cc <SPI_RxCloseIRQHandler+0x94>
  {
    /* Wait until RXNE flag is set to send data */
    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
 800a94a:	6878      	ldr	r0, [r7, #4]
 800a94c:	2101      	movs	r1, #1
 800a94e:	2200      	movs	r2, #0
 800a950:	230a      	movs	r3, #10
 800a952:	f000 fac1 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 800a956:	4603      	mov	r3, r0
 800a958:	2b00      	cmp	r3, #0
 800a95a:	d005      	beq.n	800a968 <SPI_RxCloseIRQHandler+0x30>
    {
      hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 800a95c:	687b      	ldr	r3, [r7, #4]
 800a95e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a960:	f043 0220 	orr.w	r2, r3, #32
 800a964:	687b      	ldr	r3, [r7, #4]
 800a966:	655a      	str	r2, [r3, #84]	; 0x54
    }

    /* Read CRC to reset RXNE flag */
    tmpreg = hspi->Instance->DR;
 800a968:	687b      	ldr	r3, [r7, #4]
 800a96a:	681b      	ldr	r3, [r3, #0]
 800a96c:	68db      	ldr	r3, [r3, #12]
 800a96e:	b29b      	uxth	r3, r3
 800a970:	81fb      	strh	r3, [r7, #14]
    UNUSED(tmpreg);
 800a972:	89fb      	ldrh	r3, [r7, #14]

    /* Wait until RXNE flag is set to send data */
    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_TIMEOUT_VALUE) != HAL_OK)
 800a974:	6878      	ldr	r0, [r7, #4]
 800a976:	2101      	movs	r1, #1
 800a978:	2201      	movs	r2, #1
 800a97a:	230a      	movs	r3, #10
 800a97c:	f000 faac 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 800a980:	4603      	mov	r3, r0
 800a982:	2b00      	cmp	r3, #0
 800a984:	d005      	beq.n	800a992 <SPI_RxCloseIRQHandler+0x5a>
    {
      hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 800a986:	687b      	ldr	r3, [r7, #4]
 800a988:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a98a:	f043 0220 	orr.w	r2, r3, #32
 800a98e:	687b      	ldr	r3, [r7, #4]
 800a990:	655a      	str	r2, [r3, #84]	; 0x54
    }

    /* Check if CRC error occurred */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 800a992:	687b      	ldr	r3, [r7, #4]
 800a994:	681b      	ldr	r3, [r3, #0]
 800a996:	689b      	ldr	r3, [r3, #8]
 800a998:	f003 0310 	and.w	r3, r3, #16
 800a99c:	2b00      	cmp	r3, #0
 800a99e:	d015      	beq.n	800a9cc <SPI_RxCloseIRQHandler+0x94>
    {
      hspi->ErrorCode |= HAL_SPI_ERROR_CRC;
 800a9a0:	687b      	ldr	r3, [r7, #4]
 800a9a2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a9a4:	f043 0202 	orr.w	r2, r3, #2
 800a9a8:	687b      	ldr	r3, [r7, #4]
 800a9aa:	655a      	str	r2, [r3, #84]	; 0x54

      /* Reset CRC Calculation */
      SPI_RESET_CRC(hspi);
 800a9ac:	687b      	ldr	r3, [r7, #4]
 800a9ae:	681b      	ldr	r3, [r3, #0]
 800a9b0:	687a      	ldr	r2, [r7, #4]
 800a9b2:	6812      	ldr	r2, [r2, #0]
 800a9b4:	6812      	ldr	r2, [r2, #0]
 800a9b6:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800a9ba:	601a      	str	r2, [r3, #0]
 800a9bc:	687b      	ldr	r3, [r7, #4]
 800a9be:	681b      	ldr	r3, [r3, #0]
 800a9c0:	687a      	ldr	r2, [r7, #4]
 800a9c2:	6812      	ldr	r2, [r2, #0]
 800a9c4:	6812      	ldr	r2, [r2, #0]
 800a9c6:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800a9ca:	601a      	str	r2, [r3, #0]
    }
  }

  /* Disable RXNE and ERR interrupt */
  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE));
 800a9cc:	687b      	ldr	r3, [r7, #4]
 800a9ce:	681b      	ldr	r3, [r3, #0]
 800a9d0:	687a      	ldr	r2, [r7, #4]
 800a9d2:	6812      	ldr	r2, [r2, #0]
 800a9d4:	6852      	ldr	r2, [r2, #4]
 800a9d6:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800a9da:	605a      	str	r2, [r3, #4]

  /* if Transmit process is finished */
  if(__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_TXE) == RESET)
 800a9dc:	687b      	ldr	r3, [r7, #4]
 800a9de:	681b      	ldr	r3, [r3, #0]
 800a9e0:	685b      	ldr	r3, [r3, #4]
 800a9e2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800a9e6:	2b00      	cmp	r3, #0
 800a9e8:	d13f      	bne.n	800aa6a <SPI_RxCloseIRQHandler+0x132>
  {
    /* Disable ERR interrupt */
    __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_ERR));
 800a9ea:	687b      	ldr	r3, [r7, #4]
 800a9ec:	681b      	ldr	r3, [r3, #0]
 800a9ee:	687a      	ldr	r2, [r7, #4]
 800a9f0:	6812      	ldr	r2, [r2, #0]
 800a9f2:	6852      	ldr	r2, [r2, #4]
 800a9f4:	f022 0220 	bic.w	r2, r2, #32
 800a9f8:	605a      	str	r2, [r3, #4]

    if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800a9fa:	687b      	ldr	r3, [r7, #4]
 800a9fc:	685b      	ldr	r3, [r3, #4]
 800a9fe:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 800aa02:	d111      	bne.n	800aa28 <SPI_RxCloseIRQHandler+0xf0>
 800aa04:	687b      	ldr	r3, [r7, #4]
 800aa06:	689b      	ldr	r3, [r3, #8]
 800aa08:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800aa0c:	d004      	beq.n	800aa18 <SPI_RxCloseIRQHandler+0xe0>
 800aa0e:	687b      	ldr	r3, [r7, #4]
 800aa10:	689b      	ldr	r3, [r3, #8]
 800aa12:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800aa16:	d107      	bne.n	800aa28 <SPI_RxCloseIRQHandler+0xf0>
    {
      /* Disable SPI peripheral */
      __HAL_SPI_DISABLE(hspi);
 800aa18:	687b      	ldr	r3, [r7, #4]
 800aa1a:	681b      	ldr	r3, [r3, #0]
 800aa1c:	687a      	ldr	r2, [r7, #4]
 800aa1e:	6812      	ldr	r2, [r2, #0]
 800aa20:	6812      	ldr	r2, [r2, #0]
 800aa22:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800aa26:	601a      	str	r2, [r3, #0]
    }
    
    /* Check if Errors has been detected during transfer */
    if(hspi->ErrorCode ==  HAL_SPI_ERROR_NONE)
 800aa28:	687b      	ldr	r3, [r7, #4]
 800aa2a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800aa2c:	2b00      	cmp	r3, #0
 800aa2e:	d115      	bne.n	800aa5c <SPI_RxCloseIRQHandler+0x124>
    {
      /* Check if we are in Rx or in Rx/Tx Mode */
      if(hspi->State == HAL_SPI_STATE_BUSY_TX_RX)
 800aa30:	687b      	ldr	r3, [r7, #4]
 800aa32:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 800aa36:	b2db      	uxtb	r3, r3
 800aa38:	2b32      	cmp	r3, #50	; 0x32
 800aa3a:	d107      	bne.n	800aa4c <SPI_RxCloseIRQHandler+0x114>
      {
        /* Set state to READY before run the Callback Complete */
        hspi->State = HAL_SPI_STATE_READY;
 800aa3c:	687b      	ldr	r3, [r7, #4]
 800aa3e:	2201      	movs	r2, #1
 800aa40:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
        HAL_SPI_TxRxCpltCallback(hspi);
 800aa44:	6878      	ldr	r0, [r7, #4]
 800aa46:	f7ff fe87 	bl	800a758 <HAL_SPI_TxRxCpltCallback>
 800aa4a:	e00e      	b.n	800aa6a <SPI_RxCloseIRQHandler+0x132>
      }
      else
      {
        /* Set state to READY before run the Callback Complete */
        hspi->State = HAL_SPI_STATE_READY;
 800aa4c:	687b      	ldr	r3, [r7, #4]
 800aa4e:	2201      	movs	r2, #1
 800aa50:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
        HAL_SPI_RxCpltCallback(hspi);
 800aa54:	6878      	ldr	r0, [r7, #4]
 800aa56:	f7ff fe75 	bl	800a744 <HAL_SPI_RxCpltCallback>
 800aa5a:	e006      	b.n	800aa6a <SPI_RxCloseIRQHandler+0x132>
      }
    }
    else
    {
      /* Set state to READY before run the Callback Complete */
      hspi->State = HAL_SPI_STATE_READY;
 800aa5c:	687b      	ldr	r3, [r7, #4]
 800aa5e:	2201      	movs	r2, #1
 800aa60:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
      /* Call Error call back in case of Error */
      HAL_SPI_ErrorCallback(hspi);
 800aa64:	6878      	ldr	r0, [r7, #4]
 800aa66:	f7ff fe9f 	bl	800a7a8 <HAL_SPI_ErrorCallback>
    }
  }
}
 800aa6a:	3710      	adds	r7, #16
 800aa6c:	46bd      	mov	sp, r7
 800aa6e:	bd80      	pop	{r7, pc}

0800aa70 <SPI_2LinesRxISR>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval void
  */
static void SPI_2LinesRxISR(SPI_HandleTypeDef *hspi)
{
 800aa70:	b580      	push	{r7, lr}
 800aa72:	b082      	sub	sp, #8
 800aa74:	af00      	add	r7, sp, #0
 800aa76:	6078      	str	r0, [r7, #4]
  /* Receive data in 8 Bit mode */
  if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
 800aa78:	687b      	ldr	r3, [r7, #4]
 800aa7a:	68db      	ldr	r3, [r3, #12]
 800aa7c:	2b00      	cmp	r3, #0
 800aa7e:	d10a      	bne.n	800aa96 <SPI_2LinesRxISR+0x26>
  {
    (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
 800aa80:	687b      	ldr	r3, [r7, #4]
 800aa82:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800aa84:	1c59      	adds	r1, r3, #1
 800aa86:	687a      	ldr	r2, [r7, #4]
 800aa88:	6391      	str	r1, [r2, #56]	; 0x38
 800aa8a:	687a      	ldr	r2, [r7, #4]
 800aa8c:	6812      	ldr	r2, [r2, #0]
 800aa8e:	68d2      	ldr	r2, [r2, #12]
 800aa90:	b2d2      	uxtb	r2, r2
 800aa92:	701a      	strb	r2, [r3, #0]
 800aa94:	e00b      	b.n	800aaae <SPI_2LinesRxISR+0x3e>
  }
  /* Receive data in 16 Bit mode */
  else
  {
    *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 800aa96:	687b      	ldr	r3, [r7, #4]
 800aa98:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800aa9a:	687a      	ldr	r2, [r7, #4]
 800aa9c:	6812      	ldr	r2, [r2, #0]
 800aa9e:	68d2      	ldr	r2, [r2, #12]
 800aaa0:	b292      	uxth	r2, r2
 800aaa2:	801a      	strh	r2, [r3, #0]
    hspi->pRxBuffPtr+=2;
 800aaa4:	687b      	ldr	r3, [r7, #4]
 800aaa6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800aaa8:	1c9a      	adds	r2, r3, #2
 800aaaa:	687b      	ldr	r3, [r7, #4]
 800aaac:	639a      	str	r2, [r3, #56]	; 0x38
  }
  hspi->RxXferCount--;
 800aaae:	687b      	ldr	r3, [r7, #4]
 800aab0:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800aab2:	3b01      	subs	r3, #1
 800aab4:	b29a      	uxth	r2, r3
 800aab6:	687b      	ldr	r3, [r7, #4]
 800aab8:	87da      	strh	r2, [r3, #62]	; 0x3e

  if(hspi->RxXferCount==0)
 800aaba:	687b      	ldr	r3, [r7, #4]
 800aabc:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800aabe:	2b00      	cmp	r3, #0
 800aac0:	d102      	bne.n	800aac8 <SPI_2LinesRxISR+0x58>
  {
    SPI_RxCloseIRQHandler(hspi);
 800aac2:	6878      	ldr	r0, [r7, #4]
 800aac4:	f7ff ff38 	bl	800a938 <SPI_RxCloseIRQHandler>
  }
}
 800aac8:	3708      	adds	r7, #8
 800aaca:	46bd      	mov	sp, r7
 800aacc:	bd80      	pop	{r7, pc}
 800aace:	bf00      	nop

0800aad0 <SPI_RxISR>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval void
  */
static void SPI_RxISR(SPI_HandleTypeDef *hspi)
{
 800aad0:	b580      	push	{r7, lr}
 800aad2:	b082      	sub	sp, #8
 800aad4:	af00      	add	r7, sp, #0
 800aad6:	6078      	str	r0, [r7, #4]
  /* Receive data in 8 Bit mode */
  if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
 800aad8:	687b      	ldr	r3, [r7, #4]
 800aada:	68db      	ldr	r3, [r3, #12]
 800aadc:	2b00      	cmp	r3, #0
 800aade:	d10a      	bne.n	800aaf6 <SPI_RxISR+0x26>
  {
    (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
 800aae0:	687b      	ldr	r3, [r7, #4]
 800aae2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800aae4:	1c59      	adds	r1, r3, #1
 800aae6:	687a      	ldr	r2, [r7, #4]
 800aae8:	6391      	str	r1, [r2, #56]	; 0x38
 800aaea:	687a      	ldr	r2, [r7, #4]
 800aaec:	6812      	ldr	r2, [r2, #0]
 800aaee:	68d2      	ldr	r2, [r2, #12]
 800aaf0:	b2d2      	uxtb	r2, r2
 800aaf2:	701a      	strb	r2, [r3, #0]
 800aaf4:	e00b      	b.n	800ab0e <SPI_RxISR+0x3e>
  }
  /* Receive data in 16 Bit mode */
  else
  {
    *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 800aaf6:	687b      	ldr	r3, [r7, #4]
 800aaf8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800aafa:	687a      	ldr	r2, [r7, #4]
 800aafc:	6812      	ldr	r2, [r2, #0]
 800aafe:	68d2      	ldr	r2, [r2, #12]
 800ab00:	b292      	uxth	r2, r2
 800ab02:	801a      	strh	r2, [r3, #0]
    hspi->pRxBuffPtr+=2;
 800ab04:	687b      	ldr	r3, [r7, #4]
 800ab06:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ab08:	1c9a      	adds	r2, r3, #2
 800ab0a:	687b      	ldr	r3, [r7, #4]
 800ab0c:	639a      	str	r2, [r3, #56]	; 0x38
  }
    hspi->RxXferCount--;
 800ab0e:	687b      	ldr	r3, [r7, #4]
 800ab10:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800ab12:	3b01      	subs	r3, #1
 800ab14:	b29a      	uxth	r2, r3
 800ab16:	687b      	ldr	r3, [r7, #4]
 800ab18:	87da      	strh	r2, [r3, #62]	; 0x3e

  /* Enable CRC Transmission */
  if((hspi->RxXferCount == 1) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 800ab1a:	687b      	ldr	r3, [r7, #4]
 800ab1c:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800ab1e:	2b01      	cmp	r3, #1
 800ab20:	d10c      	bne.n	800ab3c <SPI_RxISR+0x6c>
 800ab22:	687b      	ldr	r3, [r7, #4]
 800ab24:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ab26:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800ab2a:	d107      	bne.n	800ab3c <SPI_RxISR+0x6c>
  {
    /* Set CRC Next to calculate CRC on Rx side */
    hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;  
 800ab2c:	687b      	ldr	r3, [r7, #4]
 800ab2e:	681b      	ldr	r3, [r3, #0]
 800ab30:	687a      	ldr	r2, [r7, #4]
 800ab32:	6812      	ldr	r2, [r2, #0]
 800ab34:	6812      	ldr	r2, [r2, #0]
 800ab36:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800ab3a:	601a      	str	r2, [r3, #0]
  }

  if(hspi->RxXferCount == 0)
 800ab3c:	687b      	ldr	r3, [r7, #4]
 800ab3e:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800ab40:	2b00      	cmp	r3, #0
 800ab42:	d102      	bne.n	800ab4a <SPI_RxISR+0x7a>
  {
    SPI_RxCloseIRQHandler(hspi);
 800ab44:	6878      	ldr	r0, [r7, #4]
 800ab46:	f7ff fef7 	bl	800a938 <SPI_RxCloseIRQHandler>
  }
}
 800ab4a:	3708      	adds	r7, #8
 800ab4c:	46bd      	mov	sp, r7
 800ab4e:	bd80      	pop	{r7, pc}

0800ab50 <SPI_DMATransmitCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
 800ab50:	b580      	push	{r7, lr}
 800ab52:	b084      	sub	sp, #16
 800ab54:	af00      	add	r7, sp, #0
 800ab56:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800ab58:	687b      	ldr	r3, [r7, #4]
 800ab5a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ab5c:	60fb      	str	r3, [r7, #12]

  /* DMA Normal Mode */
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 800ab5e:	687b      	ldr	r3, [r7, #4]
 800ab60:	681b      	ldr	r3, [r3, #0]
 800ab62:	681b      	ldr	r3, [r3, #0]
 800ab64:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800ab68:	2b00      	cmp	r3, #0
 800ab6a:	d12c      	bne.n	800abc6 <SPI_DMATransmitCplt+0x76>
  {
    /* Wait until TXE flag is set to send data */
    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
 800ab6c:	68f8      	ldr	r0, [r7, #12]
 800ab6e:	2102      	movs	r1, #2
 800ab70:	2200      	movs	r2, #0
 800ab72:	230a      	movs	r3, #10
 800ab74:	f000 f9b0 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 800ab78:	4603      	mov	r3, r0
 800ab7a:	2b00      	cmp	r3, #0
 800ab7c:	d005      	beq.n	800ab8a <SPI_DMATransmitCplt+0x3a>
    {
      hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 800ab7e:	68fb      	ldr	r3, [r7, #12]
 800ab80:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ab82:	f043 0220 	orr.w	r2, r3, #32
 800ab86:	68fb      	ldr	r3, [r7, #12]
 800ab88:	655a      	str	r2, [r3, #84]	; 0x54
    }
    /* Disable Tx DMA Request */
    hspi->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
 800ab8a:	68fb      	ldr	r3, [r7, #12]
 800ab8c:	681b      	ldr	r3, [r3, #0]
 800ab8e:	68fa      	ldr	r2, [r7, #12]
 800ab90:	6812      	ldr	r2, [r2, #0]
 800ab92:	6852      	ldr	r2, [r2, #4]
 800ab94:	f022 0202 	bic.w	r2, r2, #2
 800ab98:	605a      	str	r2, [r3, #4]

    /* Wait until Busy flag is reset before disabling SPI */
    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, SPI_TIMEOUT_VALUE) != HAL_OK)
 800ab9a:	68f8      	ldr	r0, [r7, #12]
 800ab9c:	2180      	movs	r1, #128	; 0x80
 800ab9e:	2201      	movs	r2, #1
 800aba0:	230a      	movs	r3, #10
 800aba2:	f000 f999 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 800aba6:	4603      	mov	r3, r0
 800aba8:	2b00      	cmp	r3, #0
 800abaa:	d005      	beq.n	800abb8 <SPI_DMATransmitCplt+0x68>
    {
      hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 800abac:	68fb      	ldr	r3, [r7, #12]
 800abae:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800abb0:	f043 0220 	orr.w	r2, r3, #32
 800abb4:	68fb      	ldr	r3, [r7, #12]
 800abb6:	655a      	str	r2, [r3, #84]	; 0x54
    }

    hspi->TxXferCount = 0;
 800abb8:	68fb      	ldr	r3, [r7, #12]
 800abba:	2200      	movs	r2, #0
 800abbc:	86da      	strh	r2, [r3, #54]	; 0x36

    hspi->State = HAL_SPI_STATE_READY;
 800abbe:	68fb      	ldr	r3, [r7, #12]
 800abc0:	2201      	movs	r2, #1
 800abc2:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
  }

  /* Clear OVERRUN flag in 2 Lines communication mode because received is not read */
  if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
 800abc6:	68fb      	ldr	r3, [r7, #12]
 800abc8:	689b      	ldr	r3, [r3, #8]
 800abca:	2b00      	cmp	r3, #0
 800abcc:	d108      	bne.n	800abe0 <SPI_DMATransmitCplt+0x90>
  {
   __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800abce:	68fb      	ldr	r3, [r7, #12]
 800abd0:	681b      	ldr	r3, [r3, #0]
 800abd2:	68db      	ldr	r3, [r3, #12]
 800abd4:	60bb      	str	r3, [r7, #8]
 800abd6:	68fb      	ldr	r3, [r7, #12]
 800abd8:	681b      	ldr	r3, [r3, #0]
 800abda:	689b      	ldr	r3, [r3, #8]
 800abdc:	60bb      	str	r3, [r7, #8]
 800abde:	68bb      	ldr	r3, [r7, #8]
  }

  /* Check if Errors has been detected during transfer */
  if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 800abe0:	68fb      	ldr	r3, [r7, #12]
 800abe2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800abe4:	2b00      	cmp	r3, #0
 800abe6:	d003      	beq.n	800abf0 <SPI_DMATransmitCplt+0xa0>
  {
    HAL_SPI_ErrorCallback(hspi);
 800abe8:	68f8      	ldr	r0, [r7, #12]
 800abea:	f7ff fddd 	bl	800a7a8 <HAL_SPI_ErrorCallback>
 800abee:	e002      	b.n	800abf6 <SPI_DMATransmitCplt+0xa6>
  }
  else
  {
    HAL_SPI_TxCpltCallback(hspi);
 800abf0:	68f8      	ldr	r0, [r7, #12]
 800abf2:	f7ff fd9d 	bl	800a730 <HAL_SPI_TxCpltCallback>
  }
}
 800abf6:	3710      	adds	r7, #16
 800abf8:	46bd      	mov	sp, r7
 800abfa:	bd80      	pop	{r7, pc}

0800abfc <SPI_DMAReceiveCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
{
 800abfc:	b580      	push	{r7, lr}
 800abfe:	b084      	sub	sp, #16
 800ac00:	af00      	add	r7, sp, #0
 800ac02:	6078      	str	r0, [r7, #4]
  __IO uint16_t tmpreg;
  
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800ac04:	687b      	ldr	r3, [r7, #4]
 800ac06:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ac08:	60fb      	str	r3, [r7, #12]
  /* DMA Normal mode */
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 800ac0a:	687b      	ldr	r3, [r7, #4]
 800ac0c:	681b      	ldr	r3, [r3, #0]
 800ac0e:	681b      	ldr	r3, [r3, #0]
 800ac10:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800ac14:	2b00      	cmp	r3, #0
 800ac16:	d179      	bne.n	800ad0c <SPI_DMAReceiveCplt+0x110>
  {
    if((hspi->Init.Direction == SPI_DIRECTION_2LINES)&&(hspi->Init.Mode == SPI_MODE_MASTER))
 800ac18:	68fb      	ldr	r3, [r7, #12]
 800ac1a:	689b      	ldr	r3, [r3, #8]
 800ac1c:	2b00      	cmp	r3, #0
 800ac1e:	d108      	bne.n	800ac32 <SPI_DMAReceiveCplt+0x36>
 800ac20:	68fb      	ldr	r3, [r7, #12]
 800ac22:	685b      	ldr	r3, [r3, #4]
 800ac24:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 800ac28:	d103      	bne.n	800ac32 <SPI_DMAReceiveCplt+0x36>
    {
       SPI_DMAEndTransmitReceive(hspi);  
 800ac2a:	68f8      	ldr	r0, [r7, #12]
 800ac2c:	f000 f874 	bl	800ad18 <SPI_DMAEndTransmitReceive>
 800ac30:	e05c      	b.n	800acec <SPI_DMAReceiveCplt+0xf0>
    }
    /* SPI_DIRECTION_1LINE or SPI_DIRECTION_2LINES_RXONLY */
    else
    {
      if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800ac32:	68fb      	ldr	r3, [r7, #12]
 800ac34:	685b      	ldr	r3, [r3, #4]
 800ac36:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 800ac3a:	d111      	bne.n	800ac60 <SPI_DMAReceiveCplt+0x64>
 800ac3c:	68fb      	ldr	r3, [r7, #12]
 800ac3e:	689b      	ldr	r3, [r3, #8]
 800ac40:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800ac44:	d004      	beq.n	800ac50 <SPI_DMAReceiveCplt+0x54>
 800ac46:	68fb      	ldr	r3, [r7, #12]
 800ac48:	689b      	ldr	r3, [r3, #8]
 800ac4a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800ac4e:	d107      	bne.n	800ac60 <SPI_DMAReceiveCplt+0x64>
      {
        /* Disable SPI peripheral */
        __HAL_SPI_DISABLE(hspi);
 800ac50:	68fb      	ldr	r3, [r7, #12]
 800ac52:	681b      	ldr	r3, [r3, #0]
 800ac54:	68fa      	ldr	r2, [r7, #12]
 800ac56:	6812      	ldr	r2, [r2, #0]
 800ac58:	6812      	ldr	r2, [r2, #0]
 800ac5a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800ac5e:	601a      	str	r2, [r3, #0]
      }
      
      /* Disable Rx DMA Request */
      hspi->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
 800ac60:	68fb      	ldr	r3, [r7, #12]
 800ac62:	681b      	ldr	r3, [r3, #0]
 800ac64:	68fa      	ldr	r2, [r7, #12]
 800ac66:	6812      	ldr	r2, [r2, #0]
 800ac68:	6852      	ldr	r2, [r2, #4]
 800ac6a:	f022 0201 	bic.w	r2, r2, #1
 800ac6e:	605a      	str	r2, [r3, #4]
      
      hspi->RxXferCount = 0;
 800ac70:	68fb      	ldr	r3, [r7, #12]
 800ac72:	2200      	movs	r2, #0
 800ac74:	87da      	strh	r2, [r3, #62]	; 0x3e
      
      /* Reset CRC Calculation */
      if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800ac76:	68fb      	ldr	r3, [r7, #12]
 800ac78:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ac7a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800ac7e:	d135      	bne.n	800acec <SPI_DMAReceiveCplt+0xf0>
      {
        /* Wait until RXNE flag is set to send data */
        if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
 800ac80:	68f8      	ldr	r0, [r7, #12]
 800ac82:	2101      	movs	r1, #1
 800ac84:	2200      	movs	r2, #0
 800ac86:	230a      	movs	r3, #10
 800ac88:	f000 f926 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 800ac8c:	4603      	mov	r3, r0
 800ac8e:	2b00      	cmp	r3, #0
 800ac90:	d005      	beq.n	800ac9e <SPI_DMAReceiveCplt+0xa2>
        {
          hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 800ac92:	68fb      	ldr	r3, [r7, #12]
 800ac94:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ac96:	f043 0220 	orr.w	r2, r3, #32
 800ac9a:	68fb      	ldr	r3, [r7, #12]
 800ac9c:	655a      	str	r2, [r3, #84]	; 0x54
        }
        
        /* Read CRC */
        tmpreg = hspi->Instance->DR;
 800ac9e:	68fb      	ldr	r3, [r7, #12]
 800aca0:	681b      	ldr	r3, [r3, #0]
 800aca2:	68db      	ldr	r3, [r3, #12]
 800aca4:	b29b      	uxth	r3, r3
 800aca6:	817b      	strh	r3, [r7, #10]
        UNUSED(tmpreg);
 800aca8:	897b      	ldrh	r3, [r7, #10]
        
        /* Wait until RXNE flag is set */
        if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_TIMEOUT_VALUE) != HAL_OK)
 800acaa:	68f8      	ldr	r0, [r7, #12]
 800acac:	2101      	movs	r1, #1
 800acae:	2201      	movs	r2, #1
 800acb0:	230a      	movs	r3, #10
 800acb2:	f000 f911 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 800acb6:	4603      	mov	r3, r0
 800acb8:	2b00      	cmp	r3, #0
 800acba:	d005      	beq.n	800acc8 <SPI_DMAReceiveCplt+0xcc>
        {
          hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 800acbc:	68fb      	ldr	r3, [r7, #12]
 800acbe:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800acc0:	f043 0220 	orr.w	r2, r3, #32
 800acc4:	68fb      	ldr	r3, [r7, #12]
 800acc6:	655a      	str	r2, [r3, #84]	; 0x54
        }
        
        /* Check if CRC error occurred */
        if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 800acc8:	68fb      	ldr	r3, [r7, #12]
 800acca:	681b      	ldr	r3, [r3, #0]
 800accc:	689b      	ldr	r3, [r3, #8]
 800acce:	f003 0310 	and.w	r3, r3, #16
 800acd2:	2b00      	cmp	r3, #0
 800acd4:	d00a      	beq.n	800acec <SPI_DMAReceiveCplt+0xf0>
        {
          hspi->ErrorCode |= HAL_SPI_ERROR_CRC;
 800acd6:	68fb      	ldr	r3, [r7, #12]
 800acd8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800acda:	f043 0202 	orr.w	r2, r3, #2
 800acde:	68fb      	ldr	r3, [r7, #12]
 800ace0:	655a      	str	r2, [r3, #84]	; 0x54
          __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 800ace2:	68fb      	ldr	r3, [r7, #12]
 800ace4:	681b      	ldr	r3, [r3, #0]
 800ace6:	f06f 0210 	mvn.w	r2, #16
 800acea:	609a      	str	r2, [r3, #8]
        }
      }
    }
    
    hspi->State = HAL_SPI_STATE_READY;
 800acec:	68fb      	ldr	r3, [r7, #12]
 800acee:	2201      	movs	r2, #1
 800acf0:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
    
    /* Check if Errors has been detected during transfer */
    if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 800acf4:	68fb      	ldr	r3, [r7, #12]
 800acf6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800acf8:	2b00      	cmp	r3, #0
 800acfa:	d003      	beq.n	800ad04 <SPI_DMAReceiveCplt+0x108>
    {
      HAL_SPI_ErrorCallback(hspi);
 800acfc:	68f8      	ldr	r0, [r7, #12]
 800acfe:	f7ff fd53 	bl	800a7a8 <HAL_SPI_ErrorCallback>
 800ad02:	e006      	b.n	800ad12 <SPI_DMAReceiveCplt+0x116>
    }
    else
    {
      HAL_SPI_RxCpltCallback(hspi);
 800ad04:	68f8      	ldr	r0, [r7, #12]
 800ad06:	f7ff fd1d 	bl	800a744 <HAL_SPI_RxCpltCallback>
 800ad0a:	e002      	b.n	800ad12 <SPI_DMAReceiveCplt+0x116>
    } 
  }
  else
  {
    HAL_SPI_RxCpltCallback(hspi);
 800ad0c:	68f8      	ldr	r0, [r7, #12]
 800ad0e:	f7ff fd19 	bl	800a744 <HAL_SPI_RxCpltCallback>
  }
}
 800ad12:	3710      	adds	r7, #16
 800ad14:	46bd      	mov	sp, r7
 800ad16:	bd80      	pop	{r7, pc}

0800ad18 <SPI_DMAEndTransmitReceive>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval None
  */
static void SPI_DMAEndTransmitReceive(SPI_HandleTypeDef *hspi)   
{
 800ad18:	b580      	push	{r7, lr}
 800ad1a:	b084      	sub	sp, #16
 800ad1c:	af00      	add	r7, sp, #0
 800ad1e:	6078      	str	r0, [r7, #4]
  __IO uint16_t tmpreg;
  
  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800ad20:	687b      	ldr	r3, [r7, #4]
 800ad22:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ad24:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800ad28:	d12f      	bne.n	800ad8a <SPI_DMAEndTransmitReceive+0x72>
  {
    /* Check if CRC is done on going (RXNE flag set) */
    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_TIMEOUT_VALUE) == HAL_OK)
 800ad2a:	6878      	ldr	r0, [r7, #4]
 800ad2c:	2101      	movs	r1, #1
 800ad2e:	2201      	movs	r2, #1
 800ad30:	230a      	movs	r3, #10
 800ad32:	f000 f8d1 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 800ad36:	4603      	mov	r3, r0
 800ad38:	2b00      	cmp	r3, #0
 800ad3a:	d10e      	bne.n	800ad5a <SPI_DMAEndTransmitReceive+0x42>
    {
      /* Wait until RXNE flag is set to send data */
      if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
 800ad3c:	6878      	ldr	r0, [r7, #4]
 800ad3e:	2101      	movs	r1, #1
 800ad40:	2200      	movs	r2, #0
 800ad42:	230a      	movs	r3, #10
 800ad44:	f000 f8c8 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 800ad48:	4603      	mov	r3, r0
 800ad4a:	2b00      	cmp	r3, #0
 800ad4c:	d005      	beq.n	800ad5a <SPI_DMAEndTransmitReceive+0x42>
      {
        hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 800ad4e:	687b      	ldr	r3, [r7, #4]
 800ad50:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ad52:	f043 0220 	orr.w	r2, r3, #32
 800ad56:	687b      	ldr	r3, [r7, #4]
 800ad58:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* Read CRC */
    tmpreg = hspi->Instance->DR;
 800ad5a:	687b      	ldr	r3, [r7, #4]
 800ad5c:	681b      	ldr	r3, [r3, #0]
 800ad5e:	68db      	ldr	r3, [r3, #12]
 800ad60:	b29b      	uxth	r3, r3
 800ad62:	81fb      	strh	r3, [r7, #14]
    UNUSED(tmpreg);
 800ad64:	89fb      	ldrh	r3, [r7, #14]
    
    /* Check if CRC error occurred */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 800ad66:	687b      	ldr	r3, [r7, #4]
 800ad68:	681b      	ldr	r3, [r3, #0]
 800ad6a:	689b      	ldr	r3, [r3, #8]
 800ad6c:	f003 0310 	and.w	r3, r3, #16
 800ad70:	2b00      	cmp	r3, #0
 800ad72:	d00a      	beq.n	800ad8a <SPI_DMAEndTransmitReceive+0x72>
    {
      hspi->ErrorCode |= HAL_SPI_ERROR_CRC;
 800ad74:	687b      	ldr	r3, [r7, #4]
 800ad76:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ad78:	f043 0202 	orr.w	r2, r3, #2
 800ad7c:	687b      	ldr	r3, [r7, #4]
 800ad7e:	655a      	str	r2, [r3, #84]	; 0x54
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 800ad80:	687b      	ldr	r3, [r7, #4]
 800ad82:	681b      	ldr	r3, [r3, #0]
 800ad84:	f06f 0210 	mvn.w	r2, #16
 800ad88:	609a      	str	r2, [r3, #8]
    }
  }
  
  /* Wait until TXE flag is set to send data */
  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
 800ad8a:	6878      	ldr	r0, [r7, #4]
 800ad8c:	2102      	movs	r1, #2
 800ad8e:	2200      	movs	r2, #0
 800ad90:	230a      	movs	r3, #10
 800ad92:	f000 f8a1 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 800ad96:	4603      	mov	r3, r0
 800ad98:	2b00      	cmp	r3, #0
 800ad9a:	d005      	beq.n	800ada8 <SPI_DMAEndTransmitReceive+0x90>
  {
    hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 800ad9c:	687b      	ldr	r3, [r7, #4]
 800ad9e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ada0:	f043 0220 	orr.w	r2, r3, #32
 800ada4:	687b      	ldr	r3, [r7, #4]
 800ada6:	655a      	str	r2, [r3, #84]	; 0x54
  }
  /* Disable Tx DMA Request */
  hspi->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
 800ada8:	687b      	ldr	r3, [r7, #4]
 800adaa:	681b      	ldr	r3, [r3, #0]
 800adac:	687a      	ldr	r2, [r7, #4]
 800adae:	6812      	ldr	r2, [r2, #0]
 800adb0:	6852      	ldr	r2, [r2, #4]
 800adb2:	f022 0202 	bic.w	r2, r2, #2
 800adb6:	605a      	str	r2, [r3, #4]
  
  /* Wait until Busy flag is reset before disabling SPI */
  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, SPI_TIMEOUT_VALUE) != HAL_OK)
 800adb8:	6878      	ldr	r0, [r7, #4]
 800adba:	2180      	movs	r1, #128	; 0x80
 800adbc:	2201      	movs	r2, #1
 800adbe:	230a      	movs	r3, #10
 800adc0:	f000 f88a 	bl	800aed8 <SPI_WaitOnFlagUntilTimeout>
 800adc4:	4603      	mov	r3, r0
 800adc6:	2b00      	cmp	r3, #0
 800adc8:	d005      	beq.n	800add6 <SPI_DMAEndTransmitReceive+0xbe>
  {
    hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 800adca:	687b      	ldr	r3, [r7, #4]
 800adcc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800adce:	f043 0220 	orr.w	r2, r3, #32
 800add2:	687b      	ldr	r3, [r7, #4]
 800add4:	655a      	str	r2, [r3, #84]	; 0x54
  }
  
  /* Disable Rx DMA Request */
  hspi->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
 800add6:	687b      	ldr	r3, [r7, #4]
 800add8:	681b      	ldr	r3, [r3, #0]
 800adda:	687a      	ldr	r2, [r7, #4]
 800addc:	6812      	ldr	r2, [r2, #0]
 800adde:	6852      	ldr	r2, [r2, #4]
 800ade0:	f022 0201 	bic.w	r2, r2, #1
 800ade4:	605a      	str	r2, [r3, #4]
  
  hspi->TxXferCount = 0;
 800ade6:	687b      	ldr	r3, [r7, #4]
 800ade8:	2200      	movs	r2, #0
 800adea:	86da      	strh	r2, [r3, #54]	; 0x36
  hspi->RxXferCount = 0;
 800adec:	687b      	ldr	r3, [r7, #4]
 800adee:	2200      	movs	r2, #0
 800adf0:	87da      	strh	r2, [r3, #62]	; 0x3e
}
 800adf2:	3710      	adds	r7, #16
 800adf4:	46bd      	mov	sp, r7
 800adf6:	bd80      	pop	{r7, pc}

0800adf8 <SPI_DMATransmitReceiveCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
{
 800adf8:	b580      	push	{r7, lr}
 800adfa:	b084      	sub	sp, #16
 800adfc:	af00      	add	r7, sp, #0
 800adfe:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800ae00:	687b      	ldr	r3, [r7, #4]
 800ae02:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ae04:	60fb      	str	r3, [r7, #12]
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 800ae06:	687b      	ldr	r3, [r7, #4]
 800ae08:	681b      	ldr	r3, [r3, #0]
 800ae0a:	681b      	ldr	r3, [r3, #0]
 800ae0c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800ae10:	2b00      	cmp	r3, #0
 800ae12:	d112      	bne.n	800ae3a <SPI_DMATransmitReceiveCplt+0x42>
  { /**/
    SPI_DMAEndTransmitReceive(hspi);
 800ae14:	68f8      	ldr	r0, [r7, #12]
 800ae16:	f7ff ff7f 	bl	800ad18 <SPI_DMAEndTransmitReceive>
    
    hspi->State = HAL_SPI_STATE_READY;
 800ae1a:	68fb      	ldr	r3, [r7, #12]
 800ae1c:	2201      	movs	r2, #1
 800ae1e:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
    
    /* Check if Errors has been detected during transfer */
    if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 800ae22:	68fb      	ldr	r3, [r7, #12]
 800ae24:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ae26:	2b00      	cmp	r3, #0
 800ae28:	d003      	beq.n	800ae32 <SPI_DMATransmitReceiveCplt+0x3a>
    {
      HAL_SPI_ErrorCallback(hspi);
 800ae2a:	68f8      	ldr	r0, [r7, #12]
 800ae2c:	f7ff fcbc 	bl	800a7a8 <HAL_SPI_ErrorCallback>
 800ae30:	e006      	b.n	800ae40 <SPI_DMATransmitReceiveCplt+0x48>
    }
    else
    {
      HAL_SPI_TxRxCpltCallback(hspi);
 800ae32:	68f8      	ldr	r0, [r7, #12]
 800ae34:	f7ff fc90 	bl	800a758 <HAL_SPI_TxRxCpltCallback>
 800ae38:	e002      	b.n	800ae40 <SPI_DMATransmitReceiveCplt+0x48>
    }
  }
  else
  {
    HAL_SPI_TxRxCpltCallback(hspi);
 800ae3a:	68f8      	ldr	r0, [r7, #12]
 800ae3c:	f7ff fc8c 	bl	800a758 <HAL_SPI_TxRxCpltCallback>
  }
}
 800ae40:	3710      	adds	r7, #16
 800ae42:	46bd      	mov	sp, r7
 800ae44:	bd80      	pop	{r7, pc}
 800ae46:	bf00      	nop

0800ae48 <SPI_DMAHalfTransmitCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma)
{
 800ae48:	b580      	push	{r7, lr}
 800ae4a:	b084      	sub	sp, #16
 800ae4c:	af00      	add	r7, sp, #0
 800ae4e:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800ae50:	687b      	ldr	r3, [r7, #4]
 800ae52:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ae54:	60fb      	str	r3, [r7, #12]

  HAL_SPI_TxHalfCpltCallback(hspi);
 800ae56:	68f8      	ldr	r0, [r7, #12]
 800ae58:	f7ff fc88 	bl	800a76c <HAL_SPI_TxHalfCpltCallback>
}
 800ae5c:	3710      	adds	r7, #16
 800ae5e:	46bd      	mov	sp, r7
 800ae60:	bd80      	pop	{r7, pc}
 800ae62:	bf00      	nop

0800ae64 <SPI_DMAHalfReceiveCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
{
 800ae64:	b580      	push	{r7, lr}
 800ae66:	b084      	sub	sp, #16
 800ae68:	af00      	add	r7, sp, #0
 800ae6a:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800ae6c:	687b      	ldr	r3, [r7, #4]
 800ae6e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ae70:	60fb      	str	r3, [r7, #12]

  HAL_SPI_RxHalfCpltCallback(hspi);
 800ae72:	68f8      	ldr	r0, [r7, #12]
 800ae74:	f7ff fc84 	bl	800a780 <HAL_SPI_RxHalfCpltCallback>
}
 800ae78:	3710      	adds	r7, #16
 800ae7a:	46bd      	mov	sp, r7
 800ae7c:	bd80      	pop	{r7, pc}
 800ae7e:	bf00      	nop

0800ae80 <SPI_DMAHalfTransmitReceiveCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)   
{
 800ae80:	b580      	push	{r7, lr}
 800ae82:	b084      	sub	sp, #16
 800ae84:	af00      	add	r7, sp, #0
 800ae86:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800ae88:	687b      	ldr	r3, [r7, #4]
 800ae8a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ae8c:	60fb      	str	r3, [r7, #12]

  HAL_SPI_TxRxHalfCpltCallback(hspi);
 800ae8e:	68f8      	ldr	r0, [r7, #12]
 800ae90:	f7ff fc80 	bl	800a794 <HAL_SPI_TxRxHalfCpltCallback>
}
 800ae94:	3710      	adds	r7, #16
 800ae96:	46bd      	mov	sp, r7
 800ae98:	bd80      	pop	{r7, pc}
 800ae9a:	bf00      	nop

0800ae9c <SPI_DMAError>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAError(DMA_HandleTypeDef *hdma)
{
 800ae9c:	b580      	push	{r7, lr}
 800ae9e:	b084      	sub	sp, #16
 800aea0:	af00      	add	r7, sp, #0
 800aea2:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef* hspi = (SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800aea4:	687b      	ldr	r3, [r7, #4]
 800aea6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800aea8:	60fb      	str	r3, [r7, #12]
  hspi->TxXferCount = 0;
 800aeaa:	68fb      	ldr	r3, [r7, #12]
 800aeac:	2200      	movs	r2, #0
 800aeae:	86da      	strh	r2, [r3, #54]	; 0x36
  hspi->RxXferCount = 0;
 800aeb0:	68fb      	ldr	r3, [r7, #12]
 800aeb2:	2200      	movs	r2, #0
 800aeb4:	87da      	strh	r2, [r3, #62]	; 0x3e
  hspi->State= HAL_SPI_STATE_READY;
 800aeb6:	68fb      	ldr	r3, [r7, #12]
 800aeb8:	2201      	movs	r2, #1
 800aeba:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
  hspi->ErrorCode |= HAL_SPI_ERROR_DMA;
 800aebe:	68fb      	ldr	r3, [r7, #12]
 800aec0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800aec2:	f043 0210 	orr.w	r2, r3, #16
 800aec6:	68fb      	ldr	r3, [r7, #12]
 800aec8:	655a      	str	r2, [r3, #84]	; 0x54
  HAL_SPI_ErrorCallback(hspi);
 800aeca:	68f8      	ldr	r0, [r7, #12]
 800aecc:	f7ff fc6c 	bl	800a7a8 <HAL_SPI_ErrorCallback>
}
 800aed0:	3710      	adds	r7, #16
 800aed2:	46bd      	mov	sp, r7
 800aed4:	bd80      	pop	{r7, pc}
 800aed6:	bf00      	nop

0800aed8 <SPI_WaitOnFlagUntilTimeout>:
  * @param  Status: Flag status to check: RESET or set
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitOnFlagUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus Status, uint32_t Timeout)  
{
 800aed8:	b580      	push	{r7, lr}
 800aeda:	b086      	sub	sp, #24
 800aedc:	af00      	add	r7, sp, #0
 800aede:	60f8      	str	r0, [r7, #12]
 800aee0:	60b9      	str	r1, [r7, #8]
 800aee2:	603b      	str	r3, [r7, #0]
 800aee4:	4613      	mov	r3, r2
 800aee6:	71fb      	strb	r3, [r7, #7]
  uint32_t tickstart = 0;
 800aee8:	2300      	movs	r3, #0
 800aeea:	617b      	str	r3, [r7, #20]

  /* Get tick */ 
  tickstart = HAL_GetTick();
 800aeec:	f7f6 fd6c 	bl	80019c8 <HAL_GetTick>
 800aef0:	6178      	str	r0, [r7, #20]

  /* Wait until flag is set */
  if(Status == RESET)
 800aef2:	79fb      	ldrb	r3, [r7, #7]
 800aef4:	2b00      	cmp	r3, #0
 800aef6:	d147      	bne.n	800af88 <SPI_WaitOnFlagUntilTimeout+0xb0>
  {
    while(__HAL_SPI_GET_FLAG(hspi, Flag) == RESET)
 800aef8:	e03d      	b.n	800af76 <SPI_WaitOnFlagUntilTimeout+0x9e>
    {
      if(Timeout != HAL_MAX_DELAY)
 800aefa:	683b      	ldr	r3, [r7, #0]
 800aefc:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800af00:	d039      	beq.n	800af76 <SPI_WaitOnFlagUntilTimeout+0x9e>
      {
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 800af02:	683b      	ldr	r3, [r7, #0]
 800af04:	2b00      	cmp	r3, #0
 800af06:	d007      	beq.n	800af18 <SPI_WaitOnFlagUntilTimeout+0x40>
 800af08:	f7f6 fd5e 	bl	80019c8 <HAL_GetTick>
 800af0c:	4602      	mov	r2, r0
 800af0e:	697b      	ldr	r3, [r7, #20]
 800af10:	1ad2      	subs	r2, r2, r3
 800af12:	683b      	ldr	r3, [r7, #0]
 800af14:	429a      	cmp	r2, r3
 800af16:	d92e      	bls.n	800af76 <SPI_WaitOnFlagUntilTimeout+0x9e>
          /* Disable the SPI and reset the CRC: the CRC value should be cleared
             on both master and slave sides in order to resynchronize the master
             and slave for their respective CRC calculation */

          /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
          __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 800af18:	68fb      	ldr	r3, [r7, #12]
 800af1a:	681b      	ldr	r3, [r3, #0]
 800af1c:	68fa      	ldr	r2, [r7, #12]
 800af1e:	6812      	ldr	r2, [r2, #0]
 800af20:	6852      	ldr	r2, [r2, #4]
 800af22:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 800af26:	605a      	str	r2, [r3, #4]

          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 800af28:	68fb      	ldr	r3, [r7, #12]
 800af2a:	681b      	ldr	r3, [r3, #0]
 800af2c:	68fa      	ldr	r2, [r7, #12]
 800af2e:	6812      	ldr	r2, [r2, #0]
 800af30:	6812      	ldr	r2, [r2, #0]
 800af32:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800af36:	601a      	str	r2, [r3, #0]

          /* Reset CRC Calculation */
          if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800af38:	68fb      	ldr	r3, [r7, #12]
 800af3a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800af3c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800af40:	d10f      	bne.n	800af62 <SPI_WaitOnFlagUntilTimeout+0x8a>
          {
            SPI_RESET_CRC(hspi);
 800af42:	68fb      	ldr	r3, [r7, #12]
 800af44:	681b      	ldr	r3, [r3, #0]
 800af46:	68fa      	ldr	r2, [r7, #12]
 800af48:	6812      	ldr	r2, [r2, #0]
 800af4a:	6812      	ldr	r2, [r2, #0]
 800af4c:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800af50:	601a      	str	r2, [r3, #0]
 800af52:	68fb      	ldr	r3, [r7, #12]
 800af54:	681b      	ldr	r3, [r3, #0]
 800af56:	68fa      	ldr	r2, [r7, #12]
 800af58:	6812      	ldr	r2, [r2, #0]
 800af5a:	6812      	ldr	r2, [r2, #0]
 800af5c:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800af60:	601a      	str	r2, [r3, #0]
          }

          hspi->State= HAL_SPI_STATE_READY;
 800af62:	68fb      	ldr	r3, [r7, #12]
 800af64:	2201      	movs	r2, #1
 800af66:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

          /* Process Unlocked */
          __HAL_UNLOCK(hspi);
 800af6a:	68fb      	ldr	r3, [r7, #12]
 800af6c:	2200      	movs	r2, #0
 800af6e:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

          return HAL_TIMEOUT;
 800af72:	2303      	movs	r3, #3
 800af74:	e050      	b.n	800b018 <SPI_WaitOnFlagUntilTimeout+0x140>
  tickstart = HAL_GetTick();

  /* Wait until flag is set */
  if(Status == RESET)
  {
    while(__HAL_SPI_GET_FLAG(hspi, Flag) == RESET)
 800af76:	68fb      	ldr	r3, [r7, #12]
 800af78:	681b      	ldr	r3, [r3, #0]
 800af7a:	689a      	ldr	r2, [r3, #8]
 800af7c:	68bb      	ldr	r3, [r7, #8]
 800af7e:	401a      	ands	r2, r3
 800af80:	68bb      	ldr	r3, [r7, #8]
 800af82:	429a      	cmp	r2, r3
 800af84:	d1b9      	bne.n	800aefa <SPI_WaitOnFlagUntilTimeout+0x22>
 800af86:	e046      	b.n	800b016 <SPI_WaitOnFlagUntilTimeout+0x13e>
      }
    }
  }
  else
  {
    while(__HAL_SPI_GET_FLAG(hspi, Flag) != RESET)
 800af88:	e03d      	b.n	800b006 <SPI_WaitOnFlagUntilTimeout+0x12e>
    {
      if(Timeout != HAL_MAX_DELAY)
 800af8a:	683b      	ldr	r3, [r7, #0]
 800af8c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800af90:	d039      	beq.n	800b006 <SPI_WaitOnFlagUntilTimeout+0x12e>
      {
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 800af92:	683b      	ldr	r3, [r7, #0]
 800af94:	2b00      	cmp	r3, #0
 800af96:	d007      	beq.n	800afa8 <SPI_WaitOnFlagUntilTimeout+0xd0>
 800af98:	f7f6 fd16 	bl	80019c8 <HAL_GetTick>
 800af9c:	4602      	mov	r2, r0
 800af9e:	697b      	ldr	r3, [r7, #20]
 800afa0:	1ad2      	subs	r2, r2, r3
 800afa2:	683b      	ldr	r3, [r7, #0]
 800afa4:	429a      	cmp	r2, r3
 800afa6:	d92e      	bls.n	800b006 <SPI_WaitOnFlagUntilTimeout+0x12e>
          /* Disable the SPI and reset the CRC: the CRC value should be cleared
             on both master and slave sides in order to resynchronize the master
             and slave for their respective CRC calculation */

          /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
          __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 800afa8:	68fb      	ldr	r3, [r7, #12]
 800afaa:	681b      	ldr	r3, [r3, #0]
 800afac:	68fa      	ldr	r2, [r7, #12]
 800afae:	6812      	ldr	r2, [r2, #0]
 800afb0:	6852      	ldr	r2, [r2, #4]
 800afb2:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 800afb6:	605a      	str	r2, [r3, #4]

          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 800afb8:	68fb      	ldr	r3, [r7, #12]
 800afba:	681b      	ldr	r3, [r3, #0]
 800afbc:	68fa      	ldr	r2, [r7, #12]
 800afbe:	6812      	ldr	r2, [r2, #0]
 800afc0:	6812      	ldr	r2, [r2, #0]
 800afc2:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800afc6:	601a      	str	r2, [r3, #0]

          /* Reset CRC Calculation */
          if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800afc8:	68fb      	ldr	r3, [r7, #12]
 800afca:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800afcc:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800afd0:	d10f      	bne.n	800aff2 <SPI_WaitOnFlagUntilTimeout+0x11a>
          {
            SPI_RESET_CRC(hspi);
 800afd2:	68fb      	ldr	r3, [r7, #12]
 800afd4:	681b      	ldr	r3, [r3, #0]
 800afd6:	68fa      	ldr	r2, [r7, #12]
 800afd8:	6812      	ldr	r2, [r2, #0]
 800afda:	6812      	ldr	r2, [r2, #0]
 800afdc:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800afe0:	601a      	str	r2, [r3, #0]
 800afe2:	68fb      	ldr	r3, [r7, #12]
 800afe4:	681b      	ldr	r3, [r3, #0]
 800afe6:	68fa      	ldr	r2, [r7, #12]
 800afe8:	6812      	ldr	r2, [r2, #0]
 800afea:	6812      	ldr	r2, [r2, #0]
 800afec:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800aff0:	601a      	str	r2, [r3, #0]
          }

          hspi->State= HAL_SPI_STATE_READY;
 800aff2:	68fb      	ldr	r3, [r7, #12]
 800aff4:	2201      	movs	r2, #1
 800aff6:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

          /* Process Unlocked */
          __HAL_UNLOCK(hspi);
 800affa:	68fb      	ldr	r3, [r7, #12]
 800affc:	2200      	movs	r2, #0
 800affe:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

          return HAL_TIMEOUT;
 800b002:	2303      	movs	r3, #3
 800b004:	e008      	b.n	800b018 <SPI_WaitOnFlagUntilTimeout+0x140>
      }
    }
  }
  else
  {
    while(__HAL_SPI_GET_FLAG(hspi, Flag) != RESET)
 800b006:	68fb      	ldr	r3, [r7, #12]
 800b008:	681b      	ldr	r3, [r3, #0]
 800b00a:	689a      	ldr	r2, [r3, #8]
 800b00c:	68bb      	ldr	r3, [r7, #8]
 800b00e:	401a      	ands	r2, r3
 800b010:	68bb      	ldr	r3, [r7, #8]
 800b012:	429a      	cmp	r2, r3
 800b014:	d0b9      	beq.n	800af8a <SPI_WaitOnFlagUntilTimeout+0xb2>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
 800b016:	2300      	movs	r3, #0
}
 800b018:	4618      	mov	r0, r3
 800b01a:	3718      	adds	r7, #24
 800b01c:	46bd      	mov	sp, r7
 800b01e:	bd80      	pop	{r7, pc}

0800b020 <__aeabi_drsub>:
 800b020:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 800b024:	e002      	b.n	800b02c <__adddf3>
 800b026:	bf00      	nop

0800b028 <__aeabi_dsub>:
 800b028:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800b02c <__adddf3>:
 800b02c:	b530      	push	{r4, r5, lr}
 800b02e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 800b032:	ea4f 0543 	mov.w	r5, r3, lsl #1
 800b036:	ea94 0f05 	teq	r4, r5
 800b03a:	bf08      	it	eq
 800b03c:	ea90 0f02 	teqeq	r0, r2
 800b040:	bf1f      	itttt	ne
 800b042:	ea54 0c00 	orrsne.w	ip, r4, r0
 800b046:	ea55 0c02 	orrsne.w	ip, r5, r2
 800b04a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800b04e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800b052:	f000 80e2 	beq.w	800b21a <__adddf3+0x1ee>
 800b056:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800b05a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800b05e:	bfb8      	it	lt
 800b060:	426d      	neglt	r5, r5
 800b062:	dd0c      	ble.n	800b07e <__adddf3+0x52>
 800b064:	442c      	add	r4, r5
 800b066:	ea80 0202 	eor.w	r2, r0, r2
 800b06a:	ea81 0303 	eor.w	r3, r1, r3
 800b06e:	ea82 0000 	eor.w	r0, r2, r0
 800b072:	ea83 0101 	eor.w	r1, r3, r1
 800b076:	ea80 0202 	eor.w	r2, r0, r2
 800b07a:	ea81 0303 	eor.w	r3, r1, r3
 800b07e:	2d36      	cmp	r5, #54	; 0x36
 800b080:	bf88      	it	hi
 800b082:	bd30      	pophi	{r4, r5, pc}
 800b084:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800b088:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800b08c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 800b090:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 800b094:	d002      	beq.n	800b09c <__adddf3+0x70>
 800b096:	4240      	negs	r0, r0
 800b098:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800b09c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 800b0a0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800b0a4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 800b0a8:	d002      	beq.n	800b0b0 <__adddf3+0x84>
 800b0aa:	4252      	negs	r2, r2
 800b0ac:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800b0b0:	ea94 0f05 	teq	r4, r5
 800b0b4:	f000 80a7 	beq.w	800b206 <__adddf3+0x1da>
 800b0b8:	f1a4 0401 	sub.w	r4, r4, #1
 800b0bc:	f1d5 0e20 	rsbs	lr, r5, #32
 800b0c0:	db0d      	blt.n	800b0de <__adddf3+0xb2>
 800b0c2:	fa02 fc0e 	lsl.w	ip, r2, lr
 800b0c6:	fa22 f205 	lsr.w	r2, r2, r5
 800b0ca:	1880      	adds	r0, r0, r2
 800b0cc:	f141 0100 	adc.w	r1, r1, #0
 800b0d0:	fa03 f20e 	lsl.w	r2, r3, lr
 800b0d4:	1880      	adds	r0, r0, r2
 800b0d6:	fa43 f305 	asr.w	r3, r3, r5
 800b0da:	4159      	adcs	r1, r3
 800b0dc:	e00e      	b.n	800b0fc <__adddf3+0xd0>
 800b0de:	f1a5 0520 	sub.w	r5, r5, #32
 800b0e2:	f10e 0e20 	add.w	lr, lr, #32
 800b0e6:	2a01      	cmp	r2, #1
 800b0e8:	fa03 fc0e 	lsl.w	ip, r3, lr
 800b0ec:	bf28      	it	cs
 800b0ee:	f04c 0c02 	orrcs.w	ip, ip, #2
 800b0f2:	fa43 f305 	asr.w	r3, r3, r5
 800b0f6:	18c0      	adds	r0, r0, r3
 800b0f8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800b0fc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800b100:	d507      	bpl.n	800b112 <__adddf3+0xe6>
 800b102:	f04f 0e00 	mov.w	lr, #0
 800b106:	f1dc 0c00 	rsbs	ip, ip, #0
 800b10a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800b10e:	eb6e 0101 	sbc.w	r1, lr, r1
 800b112:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 800b116:	d31b      	bcc.n	800b150 <__adddf3+0x124>
 800b118:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800b11c:	d30c      	bcc.n	800b138 <__adddf3+0x10c>
 800b11e:	0849      	lsrs	r1, r1, #1
 800b120:	ea5f 0030 	movs.w	r0, r0, rrx
 800b124:	ea4f 0c3c 	mov.w	ip, ip, rrx
 800b128:	f104 0401 	add.w	r4, r4, #1
 800b12c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 800b130:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 800b134:	f080 809a 	bcs.w	800b26c <__adddf3+0x240>
 800b138:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800b13c:	bf08      	it	eq
 800b13e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800b142:	f150 0000 	adcs.w	r0, r0, #0
 800b146:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800b14a:	ea41 0105 	orr.w	r1, r1, r5
 800b14e:	bd30      	pop	{r4, r5, pc}
 800b150:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 800b154:	4140      	adcs	r0, r0
 800b156:	eb41 0101 	adc.w	r1, r1, r1
 800b15a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800b15e:	f1a4 0401 	sub.w	r4, r4, #1
 800b162:	d1e9      	bne.n	800b138 <__adddf3+0x10c>
 800b164:	f091 0f00 	teq	r1, #0
 800b168:	bf04      	itt	eq
 800b16a:	4601      	moveq	r1, r0
 800b16c:	2000      	moveq	r0, #0
 800b16e:	fab1 f381 	clz	r3, r1
 800b172:	bf08      	it	eq
 800b174:	3320      	addeq	r3, #32
 800b176:	f1a3 030b 	sub.w	r3, r3, #11
 800b17a:	f1b3 0220 	subs.w	r2, r3, #32
 800b17e:	da0c      	bge.n	800b19a <__adddf3+0x16e>
 800b180:	320c      	adds	r2, #12
 800b182:	dd08      	ble.n	800b196 <__adddf3+0x16a>
 800b184:	f102 0c14 	add.w	ip, r2, #20
 800b188:	f1c2 020c 	rsb	r2, r2, #12
 800b18c:	fa01 f00c 	lsl.w	r0, r1, ip
 800b190:	fa21 f102 	lsr.w	r1, r1, r2
 800b194:	e00c      	b.n	800b1b0 <__adddf3+0x184>
 800b196:	f102 0214 	add.w	r2, r2, #20
 800b19a:	bfd8      	it	le
 800b19c:	f1c2 0c20 	rsble	ip, r2, #32
 800b1a0:	fa01 f102 	lsl.w	r1, r1, r2
 800b1a4:	fa20 fc0c 	lsr.w	ip, r0, ip
 800b1a8:	bfdc      	itt	le
 800b1aa:	ea41 010c 	orrle.w	r1, r1, ip
 800b1ae:	4090      	lslle	r0, r2
 800b1b0:	1ae4      	subs	r4, r4, r3
 800b1b2:	bfa2      	ittt	ge
 800b1b4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 800b1b8:	4329      	orrge	r1, r5
 800b1ba:	bd30      	popge	{r4, r5, pc}
 800b1bc:	ea6f 0404 	mvn.w	r4, r4
 800b1c0:	3c1f      	subs	r4, #31
 800b1c2:	da1c      	bge.n	800b1fe <__adddf3+0x1d2>
 800b1c4:	340c      	adds	r4, #12
 800b1c6:	dc0e      	bgt.n	800b1e6 <__adddf3+0x1ba>
 800b1c8:	f104 0414 	add.w	r4, r4, #20
 800b1cc:	f1c4 0220 	rsb	r2, r4, #32
 800b1d0:	fa20 f004 	lsr.w	r0, r0, r4
 800b1d4:	fa01 f302 	lsl.w	r3, r1, r2
 800b1d8:	ea40 0003 	orr.w	r0, r0, r3
 800b1dc:	fa21 f304 	lsr.w	r3, r1, r4
 800b1e0:	ea45 0103 	orr.w	r1, r5, r3
 800b1e4:	bd30      	pop	{r4, r5, pc}
 800b1e6:	f1c4 040c 	rsb	r4, r4, #12
 800b1ea:	f1c4 0220 	rsb	r2, r4, #32
 800b1ee:	fa20 f002 	lsr.w	r0, r0, r2
 800b1f2:	fa01 f304 	lsl.w	r3, r1, r4
 800b1f6:	ea40 0003 	orr.w	r0, r0, r3
 800b1fa:	4629      	mov	r1, r5
 800b1fc:	bd30      	pop	{r4, r5, pc}
 800b1fe:	fa21 f004 	lsr.w	r0, r1, r4
 800b202:	4629      	mov	r1, r5
 800b204:	bd30      	pop	{r4, r5, pc}
 800b206:	f094 0f00 	teq	r4, #0
 800b20a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800b20e:	bf06      	itte	eq
 800b210:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 800b214:	3401      	addeq	r4, #1
 800b216:	3d01      	subne	r5, #1
 800b218:	e74e      	b.n	800b0b8 <__adddf3+0x8c>
 800b21a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800b21e:	bf18      	it	ne
 800b220:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800b224:	d029      	beq.n	800b27a <__adddf3+0x24e>
 800b226:	ea94 0f05 	teq	r4, r5
 800b22a:	bf08      	it	eq
 800b22c:	ea90 0f02 	teqeq	r0, r2
 800b230:	d005      	beq.n	800b23e <__adddf3+0x212>
 800b232:	ea54 0c00 	orrs.w	ip, r4, r0
 800b236:	bf04      	itt	eq
 800b238:	4619      	moveq	r1, r3
 800b23a:	4610      	moveq	r0, r2
 800b23c:	bd30      	pop	{r4, r5, pc}
 800b23e:	ea91 0f03 	teq	r1, r3
 800b242:	bf1e      	ittt	ne
 800b244:	2100      	movne	r1, #0
 800b246:	2000      	movne	r0, #0
 800b248:	bd30      	popne	{r4, r5, pc}
 800b24a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800b24e:	d105      	bne.n	800b25c <__adddf3+0x230>
 800b250:	0040      	lsls	r0, r0, #1
 800b252:	4149      	adcs	r1, r1
 800b254:	bf28      	it	cs
 800b256:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800b25a:	bd30      	pop	{r4, r5, pc}
 800b25c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 800b260:	bf3c      	itt	cc
 800b262:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 800b266:	bd30      	popcc	{r4, r5, pc}
 800b268:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800b26c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 800b270:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800b274:	f04f 0000 	mov.w	r0, #0
 800b278:	bd30      	pop	{r4, r5, pc}
 800b27a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800b27e:	bf1a      	itte	ne
 800b280:	4619      	movne	r1, r3
 800b282:	4610      	movne	r0, r2
 800b284:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 800b288:	bf1c      	itt	ne
 800b28a:	460b      	movne	r3, r1
 800b28c:	4602      	movne	r2, r0
 800b28e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800b292:	bf06      	itte	eq
 800b294:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 800b298:	ea91 0f03 	teqeq	r1, r3
 800b29c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 800b2a0:	bd30      	pop	{r4, r5, pc}
 800b2a2:	bf00      	nop

0800b2a4 <__aeabi_ui2d>:
 800b2a4:	f090 0f00 	teq	r0, #0
 800b2a8:	bf04      	itt	eq
 800b2aa:	2100      	moveq	r1, #0
 800b2ac:	4770      	bxeq	lr
 800b2ae:	b530      	push	{r4, r5, lr}
 800b2b0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800b2b4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800b2b8:	f04f 0500 	mov.w	r5, #0
 800b2bc:	f04f 0100 	mov.w	r1, #0
 800b2c0:	e750      	b.n	800b164 <__adddf3+0x138>
 800b2c2:	bf00      	nop

0800b2c4 <__aeabi_i2d>:
 800b2c4:	f090 0f00 	teq	r0, #0
 800b2c8:	bf04      	itt	eq
 800b2ca:	2100      	moveq	r1, #0
 800b2cc:	4770      	bxeq	lr
 800b2ce:	b530      	push	{r4, r5, lr}
 800b2d0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800b2d4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800b2d8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800b2dc:	bf48      	it	mi
 800b2de:	4240      	negmi	r0, r0
 800b2e0:	f04f 0100 	mov.w	r1, #0
 800b2e4:	e73e      	b.n	800b164 <__adddf3+0x138>
 800b2e6:	bf00      	nop

0800b2e8 <__aeabi_f2d>:
 800b2e8:	0042      	lsls	r2, r0, #1
 800b2ea:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800b2ee:	ea4f 0131 	mov.w	r1, r1, rrx
 800b2f2:	ea4f 7002 	mov.w	r0, r2, lsl #28
 800b2f6:	bf1f      	itttt	ne
 800b2f8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800b2fc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800b300:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 800b304:	4770      	bxne	lr
 800b306:	f092 0f00 	teq	r2, #0
 800b30a:	bf14      	ite	ne
 800b30c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800b310:	4770      	bxeq	lr
 800b312:	b530      	push	{r4, r5, lr}
 800b314:	f44f 7460 	mov.w	r4, #896	; 0x380
 800b318:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800b31c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800b320:	e720      	b.n	800b164 <__adddf3+0x138>
 800b322:	bf00      	nop

0800b324 <__aeabi_ul2d>:
 800b324:	ea50 0201 	orrs.w	r2, r0, r1
 800b328:	bf08      	it	eq
 800b32a:	4770      	bxeq	lr
 800b32c:	b530      	push	{r4, r5, lr}
 800b32e:	f04f 0500 	mov.w	r5, #0
 800b332:	e00a      	b.n	800b34a <__aeabi_l2d+0x16>

0800b334 <__aeabi_l2d>:
 800b334:	ea50 0201 	orrs.w	r2, r0, r1
 800b338:	bf08      	it	eq
 800b33a:	4770      	bxeq	lr
 800b33c:	b530      	push	{r4, r5, lr}
 800b33e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 800b342:	d502      	bpl.n	800b34a <__aeabi_l2d+0x16>
 800b344:	4240      	negs	r0, r0
 800b346:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800b34a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800b34e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800b352:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800b356:	f43f aedc 	beq.w	800b112 <__adddf3+0xe6>
 800b35a:	f04f 0203 	mov.w	r2, #3
 800b35e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800b362:	bf18      	it	ne
 800b364:	3203      	addne	r2, #3
 800b366:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800b36a:	bf18      	it	ne
 800b36c:	3203      	addne	r2, #3
 800b36e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800b372:	f1c2 0320 	rsb	r3, r2, #32
 800b376:	fa00 fc03 	lsl.w	ip, r0, r3
 800b37a:	fa20 f002 	lsr.w	r0, r0, r2
 800b37e:	fa01 fe03 	lsl.w	lr, r1, r3
 800b382:	ea40 000e 	orr.w	r0, r0, lr
 800b386:	fa21 f102 	lsr.w	r1, r1, r2
 800b38a:	4414      	add	r4, r2
 800b38c:	e6c1      	b.n	800b112 <__adddf3+0xe6>
 800b38e:	bf00      	nop

0800b390 <__aeabi_dmul>:
 800b390:	b570      	push	{r4, r5, r6, lr}
 800b392:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800b396:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800b39a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800b39e:	bf1d      	ittte	ne
 800b3a0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800b3a4:	ea94 0f0c 	teqne	r4, ip
 800b3a8:	ea95 0f0c 	teqne	r5, ip
 800b3ac:	f000 f8de 	bleq	800b56c <__aeabi_dmul+0x1dc>
 800b3b0:	442c      	add	r4, r5
 800b3b2:	ea81 0603 	eor.w	r6, r1, r3
 800b3b6:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800b3ba:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800b3be:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800b3c2:	bf18      	it	ne
 800b3c4:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 800b3c8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800b3cc:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800b3d0:	d038      	beq.n	800b444 <__aeabi_dmul+0xb4>
 800b3d2:	fba0 ce02 	umull	ip, lr, r0, r2
 800b3d6:	f04f 0500 	mov.w	r5, #0
 800b3da:	fbe1 e502 	umlal	lr, r5, r1, r2
 800b3de:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800b3e2:	fbe0 e503 	umlal	lr, r5, r0, r3
 800b3e6:	f04f 0600 	mov.w	r6, #0
 800b3ea:	fbe1 5603 	umlal	r5, r6, r1, r3
 800b3ee:	f09c 0f00 	teq	ip, #0
 800b3f2:	bf18      	it	ne
 800b3f4:	f04e 0e01 	orrne.w	lr, lr, #1
 800b3f8:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800b3fc:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 800b400:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 800b404:	d204      	bcs.n	800b410 <__aeabi_dmul+0x80>
 800b406:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800b40a:	416d      	adcs	r5, r5
 800b40c:	eb46 0606 	adc.w	r6, r6, r6
 800b410:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 800b414:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 800b418:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 800b41c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 800b420:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 800b424:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800b428:	bf88      	it	hi
 800b42a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800b42e:	d81e      	bhi.n	800b46e <__aeabi_dmul+0xde>
 800b430:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 800b434:	bf08      	it	eq
 800b436:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800b43a:	f150 0000 	adcs.w	r0, r0, #0
 800b43e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800b442:	bd70      	pop	{r4, r5, r6, pc}
 800b444:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 800b448:	ea46 0101 	orr.w	r1, r6, r1
 800b44c:	ea40 0002 	orr.w	r0, r0, r2
 800b450:	ea81 0103 	eor.w	r1, r1, r3
 800b454:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 800b458:	bfc2      	ittt	gt
 800b45a:	ebd4 050c 	rsbsgt	r5, r4, ip
 800b45e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800b462:	bd70      	popgt	{r4, r5, r6, pc}
 800b464:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800b468:	f04f 0e00 	mov.w	lr, #0
 800b46c:	3c01      	subs	r4, #1
 800b46e:	f300 80ab 	bgt.w	800b5c8 <__aeabi_dmul+0x238>
 800b472:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800b476:	bfde      	ittt	le
 800b478:	2000      	movle	r0, #0
 800b47a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800b47e:	bd70      	pople	{r4, r5, r6, pc}
 800b480:	f1c4 0400 	rsb	r4, r4, #0
 800b484:	3c20      	subs	r4, #32
 800b486:	da35      	bge.n	800b4f4 <__aeabi_dmul+0x164>
 800b488:	340c      	adds	r4, #12
 800b48a:	dc1b      	bgt.n	800b4c4 <__aeabi_dmul+0x134>
 800b48c:	f104 0414 	add.w	r4, r4, #20
 800b490:	f1c4 0520 	rsb	r5, r4, #32
 800b494:	fa00 f305 	lsl.w	r3, r0, r5
 800b498:	fa20 f004 	lsr.w	r0, r0, r4
 800b49c:	fa01 f205 	lsl.w	r2, r1, r5
 800b4a0:	ea40 0002 	orr.w	r0, r0, r2
 800b4a4:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 800b4a8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800b4ac:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800b4b0:	fa21 f604 	lsr.w	r6, r1, r4
 800b4b4:	eb42 0106 	adc.w	r1, r2, r6
 800b4b8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800b4bc:	bf08      	it	eq
 800b4be:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800b4c2:	bd70      	pop	{r4, r5, r6, pc}
 800b4c4:	f1c4 040c 	rsb	r4, r4, #12
 800b4c8:	f1c4 0520 	rsb	r5, r4, #32
 800b4cc:	fa00 f304 	lsl.w	r3, r0, r4
 800b4d0:	fa20 f005 	lsr.w	r0, r0, r5
 800b4d4:	fa01 f204 	lsl.w	r2, r1, r4
 800b4d8:	ea40 0002 	orr.w	r0, r0, r2
 800b4dc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800b4e0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800b4e4:	f141 0100 	adc.w	r1, r1, #0
 800b4e8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800b4ec:	bf08      	it	eq
 800b4ee:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800b4f2:	bd70      	pop	{r4, r5, r6, pc}
 800b4f4:	f1c4 0520 	rsb	r5, r4, #32
 800b4f8:	fa00 f205 	lsl.w	r2, r0, r5
 800b4fc:	ea4e 0e02 	orr.w	lr, lr, r2
 800b500:	fa20 f304 	lsr.w	r3, r0, r4
 800b504:	fa01 f205 	lsl.w	r2, r1, r5
 800b508:	ea43 0302 	orr.w	r3, r3, r2
 800b50c:	fa21 f004 	lsr.w	r0, r1, r4
 800b510:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800b514:	fa21 f204 	lsr.w	r2, r1, r4
 800b518:	ea20 0002 	bic.w	r0, r0, r2
 800b51c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 800b520:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800b524:	bf08      	it	eq
 800b526:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800b52a:	bd70      	pop	{r4, r5, r6, pc}
 800b52c:	f094 0f00 	teq	r4, #0
 800b530:	d10f      	bne.n	800b552 <__aeabi_dmul+0x1c2>
 800b532:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 800b536:	0040      	lsls	r0, r0, #1
 800b538:	eb41 0101 	adc.w	r1, r1, r1
 800b53c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800b540:	bf08      	it	eq
 800b542:	3c01      	subeq	r4, #1
 800b544:	d0f7      	beq.n	800b536 <__aeabi_dmul+0x1a6>
 800b546:	ea41 0106 	orr.w	r1, r1, r6
 800b54a:	f095 0f00 	teq	r5, #0
 800b54e:	bf18      	it	ne
 800b550:	4770      	bxne	lr
 800b552:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 800b556:	0052      	lsls	r2, r2, #1
 800b558:	eb43 0303 	adc.w	r3, r3, r3
 800b55c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800b560:	bf08      	it	eq
 800b562:	3d01      	subeq	r5, #1
 800b564:	d0f7      	beq.n	800b556 <__aeabi_dmul+0x1c6>
 800b566:	ea43 0306 	orr.w	r3, r3, r6
 800b56a:	4770      	bx	lr
 800b56c:	ea94 0f0c 	teq	r4, ip
 800b570:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800b574:	bf18      	it	ne
 800b576:	ea95 0f0c 	teqne	r5, ip
 800b57a:	d00c      	beq.n	800b596 <__aeabi_dmul+0x206>
 800b57c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800b580:	bf18      	it	ne
 800b582:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800b586:	d1d1      	bne.n	800b52c <__aeabi_dmul+0x19c>
 800b588:	ea81 0103 	eor.w	r1, r1, r3
 800b58c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800b590:	f04f 0000 	mov.w	r0, #0
 800b594:	bd70      	pop	{r4, r5, r6, pc}
 800b596:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800b59a:	bf06      	itte	eq
 800b59c:	4610      	moveq	r0, r2
 800b59e:	4619      	moveq	r1, r3
 800b5a0:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800b5a4:	d019      	beq.n	800b5da <__aeabi_dmul+0x24a>
 800b5a6:	ea94 0f0c 	teq	r4, ip
 800b5aa:	d102      	bne.n	800b5b2 <__aeabi_dmul+0x222>
 800b5ac:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 800b5b0:	d113      	bne.n	800b5da <__aeabi_dmul+0x24a>
 800b5b2:	ea95 0f0c 	teq	r5, ip
 800b5b6:	d105      	bne.n	800b5c4 <__aeabi_dmul+0x234>
 800b5b8:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800b5bc:	bf1c      	itt	ne
 800b5be:	4610      	movne	r0, r2
 800b5c0:	4619      	movne	r1, r3
 800b5c2:	d10a      	bne.n	800b5da <__aeabi_dmul+0x24a>
 800b5c4:	ea81 0103 	eor.w	r1, r1, r3
 800b5c8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800b5cc:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800b5d0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800b5d4:	f04f 0000 	mov.w	r0, #0
 800b5d8:	bd70      	pop	{r4, r5, r6, pc}
 800b5da:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800b5de:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800b5e2:	bd70      	pop	{r4, r5, r6, pc}

0800b5e4 <__aeabi_ddiv>:
 800b5e4:	b570      	push	{r4, r5, r6, lr}
 800b5e6:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800b5ea:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800b5ee:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800b5f2:	bf1d      	ittte	ne
 800b5f4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800b5f8:	ea94 0f0c 	teqne	r4, ip
 800b5fc:	ea95 0f0c 	teqne	r5, ip
 800b600:	f000 f8a7 	bleq	800b752 <__aeabi_ddiv+0x16e>
 800b604:	eba4 0405 	sub.w	r4, r4, r5
 800b608:	ea81 0e03 	eor.w	lr, r1, r3
 800b60c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800b610:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800b614:	f000 8088 	beq.w	800b728 <__aeabi_ddiv+0x144>
 800b618:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800b61c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 800b620:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800b624:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800b628:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800b62c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 800b630:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 800b634:	ea4f 2600 	mov.w	r6, r0, lsl #8
 800b638:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 800b63c:	429d      	cmp	r5, r3
 800b63e:	bf08      	it	eq
 800b640:	4296      	cmpeq	r6, r2
 800b642:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 800b646:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800b64a:	d202      	bcs.n	800b652 <__aeabi_ddiv+0x6e>
 800b64c:	085b      	lsrs	r3, r3, #1
 800b64e:	ea4f 0232 	mov.w	r2, r2, rrx
 800b652:	1ab6      	subs	r6, r6, r2
 800b654:	eb65 0503 	sbc.w	r5, r5, r3
 800b658:	085b      	lsrs	r3, r3, #1
 800b65a:	ea4f 0232 	mov.w	r2, r2, rrx
 800b65e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800b662:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800b666:	ebb6 0e02 	subs.w	lr, r6, r2
 800b66a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800b66e:	bf22      	ittt	cs
 800b670:	1ab6      	subcs	r6, r6, r2
 800b672:	4675      	movcs	r5, lr
 800b674:	ea40 000c 	orrcs.w	r0, r0, ip
 800b678:	085b      	lsrs	r3, r3, #1
 800b67a:	ea4f 0232 	mov.w	r2, r2, rrx
 800b67e:	ebb6 0e02 	subs.w	lr, r6, r2
 800b682:	eb75 0e03 	sbcs.w	lr, r5, r3
 800b686:	bf22      	ittt	cs
 800b688:	1ab6      	subcs	r6, r6, r2
 800b68a:	4675      	movcs	r5, lr
 800b68c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 800b690:	085b      	lsrs	r3, r3, #1
 800b692:	ea4f 0232 	mov.w	r2, r2, rrx
 800b696:	ebb6 0e02 	subs.w	lr, r6, r2
 800b69a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800b69e:	bf22      	ittt	cs
 800b6a0:	1ab6      	subcs	r6, r6, r2
 800b6a2:	4675      	movcs	r5, lr
 800b6a4:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 800b6a8:	085b      	lsrs	r3, r3, #1
 800b6aa:	ea4f 0232 	mov.w	r2, r2, rrx
 800b6ae:	ebb6 0e02 	subs.w	lr, r6, r2
 800b6b2:	eb75 0e03 	sbcs.w	lr, r5, r3
 800b6b6:	bf22      	ittt	cs
 800b6b8:	1ab6      	subcs	r6, r6, r2
 800b6ba:	4675      	movcs	r5, lr
 800b6bc:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 800b6c0:	ea55 0e06 	orrs.w	lr, r5, r6
 800b6c4:	d018      	beq.n	800b6f8 <__aeabi_ddiv+0x114>
 800b6c6:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800b6ca:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800b6ce:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800b6d2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800b6d6:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800b6da:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800b6de:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800b6e2:	d1c0      	bne.n	800b666 <__aeabi_ddiv+0x82>
 800b6e4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800b6e8:	d10b      	bne.n	800b702 <__aeabi_ddiv+0x11e>
 800b6ea:	ea41 0100 	orr.w	r1, r1, r0
 800b6ee:	f04f 0000 	mov.w	r0, #0
 800b6f2:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800b6f6:	e7b6      	b.n	800b666 <__aeabi_ddiv+0x82>
 800b6f8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800b6fc:	bf04      	itt	eq
 800b6fe:	4301      	orreq	r1, r0
 800b700:	2000      	moveq	r0, #0
 800b702:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800b706:	bf88      	it	hi
 800b708:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800b70c:	f63f aeaf 	bhi.w	800b46e <__aeabi_dmul+0xde>
 800b710:	ebb5 0c03 	subs.w	ip, r5, r3
 800b714:	bf04      	itt	eq
 800b716:	ebb6 0c02 	subseq.w	ip, r6, r2
 800b71a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800b71e:	f150 0000 	adcs.w	r0, r0, #0
 800b722:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800b726:	bd70      	pop	{r4, r5, r6, pc}
 800b728:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 800b72c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 800b730:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 800b734:	bfc2      	ittt	gt
 800b736:	ebd4 050c 	rsbsgt	r5, r4, ip
 800b73a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800b73e:	bd70      	popgt	{r4, r5, r6, pc}
 800b740:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800b744:	f04f 0e00 	mov.w	lr, #0
 800b748:	3c01      	subs	r4, #1
 800b74a:	e690      	b.n	800b46e <__aeabi_dmul+0xde>
 800b74c:	ea45 0e06 	orr.w	lr, r5, r6
 800b750:	e68d      	b.n	800b46e <__aeabi_dmul+0xde>
 800b752:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800b756:	ea94 0f0c 	teq	r4, ip
 800b75a:	bf08      	it	eq
 800b75c:	ea95 0f0c 	teqeq	r5, ip
 800b760:	f43f af3b 	beq.w	800b5da <__aeabi_dmul+0x24a>
 800b764:	ea94 0f0c 	teq	r4, ip
 800b768:	d10a      	bne.n	800b780 <__aeabi_ddiv+0x19c>
 800b76a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800b76e:	f47f af34 	bne.w	800b5da <__aeabi_dmul+0x24a>
 800b772:	ea95 0f0c 	teq	r5, ip
 800b776:	f47f af25 	bne.w	800b5c4 <__aeabi_dmul+0x234>
 800b77a:	4610      	mov	r0, r2
 800b77c:	4619      	mov	r1, r3
 800b77e:	e72c      	b.n	800b5da <__aeabi_dmul+0x24a>
 800b780:	ea95 0f0c 	teq	r5, ip
 800b784:	d106      	bne.n	800b794 <__aeabi_ddiv+0x1b0>
 800b786:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800b78a:	f43f aefd 	beq.w	800b588 <__aeabi_dmul+0x1f8>
 800b78e:	4610      	mov	r0, r2
 800b790:	4619      	mov	r1, r3
 800b792:	e722      	b.n	800b5da <__aeabi_dmul+0x24a>
 800b794:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800b798:	bf18      	it	ne
 800b79a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800b79e:	f47f aec5 	bne.w	800b52c <__aeabi_dmul+0x19c>
 800b7a2:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 800b7a6:	f47f af0d 	bne.w	800b5c4 <__aeabi_dmul+0x234>
 800b7aa:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 800b7ae:	f47f aeeb 	bne.w	800b588 <__aeabi_dmul+0x1f8>
 800b7b2:	e712      	b.n	800b5da <__aeabi_dmul+0x24a>

0800b7b4 <__aeabi_d2iz>:
 800b7b4:	ea4f 0241 	mov.w	r2, r1, lsl #1
 800b7b8:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 800b7bc:	d215      	bcs.n	800b7ea <__aeabi_d2iz+0x36>
 800b7be:	d511      	bpl.n	800b7e4 <__aeabi_d2iz+0x30>
 800b7c0:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 800b7c4:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 800b7c8:	d912      	bls.n	800b7f0 <__aeabi_d2iz+0x3c>
 800b7ca:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800b7ce:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800b7d2:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 800b7d6:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800b7da:	fa23 f002 	lsr.w	r0, r3, r2
 800b7de:	bf18      	it	ne
 800b7e0:	4240      	negne	r0, r0
 800b7e2:	4770      	bx	lr
 800b7e4:	f04f 0000 	mov.w	r0, #0
 800b7e8:	4770      	bx	lr
 800b7ea:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 800b7ee:	d105      	bne.n	800b7fc <__aeabi_d2iz+0x48>
 800b7f0:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 800b7f4:	bf08      	it	eq
 800b7f6:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 800b7fa:	4770      	bx	lr
 800b7fc:	f04f 0000 	mov.w	r0, #0
 800b800:	4770      	bx	lr
 800b802:	bf00      	nop

0800b804 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 800b804:	f8df d034 	ldr.w	sp, [pc, #52]	; 800b83c <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 800b808:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800b80a:	e003      	b.n	800b814 <LoopCopyDataInit>

0800b80c <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800b80c:	4b0c      	ldr	r3, [pc, #48]	; (800b840 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 800b80e:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800b810:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800b812:	3104      	adds	r1, #4

0800b814 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800b814:	480b      	ldr	r0, [pc, #44]	; (800b844 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 800b816:	4b0c      	ldr	r3, [pc, #48]	; (800b848 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 800b818:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800b81a:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800b81c:	d3f6      	bcc.n	800b80c <CopyDataInit>
  ldr  r2, =_sbss
 800b81e:	4a0b      	ldr	r2, [pc, #44]	; (800b84c <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 800b820:	e002      	b.n	800b828 <LoopFillZerobss>

0800b822 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 800b822:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800b824:	f842 3b04 	str.w	r3, [r2], #4

0800b828 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800b828:	4b09      	ldr	r3, [pc, #36]	; (800b850 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 800b82a:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800b82c:	d3f9      	bcc.n	800b822 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 800b82e:	f7f4 fd13 	bl	8000258 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800b832:	f000 f845 	bl	800b8c0 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800b836:	f7f5 fad3 	bl	8000de0 <main>
  bx  lr    
 800b83a:	4770      	bx	lr

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 800b83c:	20020000 	.word	0x20020000
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 800b840:	0800ba38 	.word	0x0800ba38
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800b844:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 800b848:	20000430 	.word	0x20000430
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 800b84c:	20000430 	.word	0x20000430
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800b850:	20000e84 	.word	0x20000e84
	...

0800b860 <ADC_IRQHandler>:


    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
  /* Load the address of the interrupt control register into r3. */
  ldr r3, NVIC_INT_CTRL_CONST
 800b860:	4b03      	ldr	r3, [pc, #12]	; (800b870 <NVIC_INT_CTRL_CONST>)
  /* Load the value of the interrupt control register into r2 from the
  address held in r3. */
  ldr r2, [r3, #0]
 800b862:	681a      	ldr	r2, [r3, #0]
  /* The interrupt number is in the least significant byte - clear all
  other bits. */
  uxtb r2, r2
 800b864:	b2d2      	uxtb	r2, r2

0800b866 <Infinite_Loop>:
Infinite_Loop:
  b  Infinite_Loop
 800b866:	e7fe      	b.n	800b866 <Infinite_Loop>
 800b868:	f3af 8000 	nop.w
 800b86c:	f3af 8000 	nop.w

0800b870 <NVIC_INT_CTRL_CONST>:
 800b870:	e000ed04 	.word	0xe000ed04
 800b874:	f3af 8000 	nop.w
 800b878:	f3af 8000 	nop.w
 800b87c:	f3af 8000 	nop.w

0800b880 <atexit>:
 800b880:	4601      	mov	r1, r0
 800b882:	2000      	movs	r0, #0
 800b884:	4602      	mov	r2, r0
 800b886:	4603      	mov	r3, r0
 800b888:	f000 b848 	b.w	800b91c <__register_exitproc>

0800b88c <__libc_fini_array>:
 800b88c:	b538      	push	{r3, r4, r5, lr}
 800b88e:	f64b 2438 	movw	r4, #47672	; 0xba38
 800b892:	f64b 2534 	movw	r5, #47668	; 0xba34
 800b896:	f6c0 0500 	movt	r5, #2048	; 0x800
 800b89a:	f6c0 0400 	movt	r4, #2048	; 0x800
 800b89e:	1b64      	subs	r4, r4, r5
 800b8a0:	10a4      	asrs	r4, r4, #2
 800b8a2:	bf18      	it	ne
 800b8a4:	eb05 0584 	addne.w	r5, r5, r4, lsl #2
 800b8a8:	d005      	beq.n	800b8b6 <__libc_fini_array+0x2a>
 800b8aa:	3c01      	subs	r4, #1
 800b8ac:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 800b8b0:	4798      	blx	r3
 800b8b2:	2c00      	cmp	r4, #0
 800b8b4:	d1f9      	bne.n	800b8aa <__libc_fini_array+0x1e>
 800b8b6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800b8ba:	f000 b897 	b.w	800b9ec <_fini>
 800b8be:	bf00      	nop

0800b8c0 <__libc_init_array>:
 800b8c0:	b570      	push	{r4, r5, r6, lr}
 800b8c2:	f64b 262c 	movw	r6, #47660	; 0xba2c
 800b8c6:	f64b 252c 	movw	r5, #47660	; 0xba2c
 800b8ca:	f6c0 0500 	movt	r5, #2048	; 0x800
 800b8ce:	f6c0 0600 	movt	r6, #2048	; 0x800
 800b8d2:	1b76      	subs	r6, r6, r5
 800b8d4:	10b6      	asrs	r6, r6, #2
 800b8d6:	bf1c      	itt	ne
 800b8d8:	3d04      	subne	r5, #4
 800b8da:	2400      	movne	r4, #0
 800b8dc:	d005      	beq.n	800b8ea <__libc_init_array+0x2a>
 800b8de:	3401      	adds	r4, #1
 800b8e0:	f855 3f04 	ldr.w	r3, [r5, #4]!
 800b8e4:	4798      	blx	r3
 800b8e6:	42a6      	cmp	r6, r4
 800b8e8:	d1f9      	bne.n	800b8de <__libc_init_array+0x1e>
 800b8ea:	f64b 2634 	movw	r6, #47668	; 0xba34
 800b8ee:	f64b 252c 	movw	r5, #47660	; 0xba2c
 800b8f2:	f6c0 0500 	movt	r5, #2048	; 0x800
 800b8f6:	f6c0 0600 	movt	r6, #2048	; 0x800
 800b8fa:	1b76      	subs	r6, r6, r5
 800b8fc:	f000 f870 	bl	800b9e0 <_init>
 800b900:	10b6      	asrs	r6, r6, #2
 800b902:	bf1c      	itt	ne
 800b904:	3d04      	subne	r5, #4
 800b906:	2400      	movne	r4, #0
 800b908:	d006      	beq.n	800b918 <__libc_init_array+0x58>
 800b90a:	3401      	adds	r4, #1
 800b90c:	f855 3f04 	ldr.w	r3, [r5, #4]!
 800b910:	4798      	blx	r3
 800b912:	42a6      	cmp	r6, r4
 800b914:	d1f9      	bne.n	800b90a <__libc_init_array+0x4a>
 800b916:	bd70      	pop	{r4, r5, r6, pc}
 800b918:	bd70      	pop	{r4, r5, r6, pc}
 800b91a:	bf00      	nop

0800b91c <__register_exitproc>:
 800b91c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b91e:	f64b 2428 	movw	r4, #47656	; 0xba28
 800b922:	f6c0 0400 	movt	r4, #2048	; 0x800
 800b926:	b085      	sub	sp, #20
 800b928:	6826      	ldr	r6, [r4, #0]
 800b92a:	f8d6 4148 	ldr.w	r4, [r6, #328]	; 0x148
 800b92e:	4607      	mov	r7, r0
 800b930:	2c00      	cmp	r4, #0
 800b932:	d044      	beq.n	800b9be <__register_exitproc+0xa2>
 800b934:	6865      	ldr	r5, [r4, #4]
 800b936:	2d1f      	cmp	r5, #31
 800b938:	dd21      	ble.n	800b97e <__register_exitproc+0x62>
 800b93a:	f240 0400 	movw	r4, #0
 800b93e:	f2c0 0400 	movt	r4, #0
 800b942:	b91c      	cbnz	r4, 800b94c <__register_exitproc+0x30>
 800b944:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800b948:	b005      	add	sp, #20
 800b94a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b94c:	f44f 70c8 	mov.w	r0, #400	; 0x190
 800b950:	9103      	str	r1, [sp, #12]
 800b952:	9202      	str	r2, [sp, #8]
 800b954:	9301      	str	r3, [sp, #4]
 800b956:	f3af 8000 	nop.w
 800b95a:	9903      	ldr	r1, [sp, #12]
 800b95c:	9a02      	ldr	r2, [sp, #8]
 800b95e:	9b01      	ldr	r3, [sp, #4]
 800b960:	4604      	mov	r4, r0
 800b962:	2800      	cmp	r0, #0
 800b964:	d0ee      	beq.n	800b944 <__register_exitproc+0x28>
 800b966:	f8d6 5148 	ldr.w	r5, [r6, #328]	; 0x148
 800b96a:	2000      	movs	r0, #0
 800b96c:	6025      	str	r5, [r4, #0]
 800b96e:	6060      	str	r0, [r4, #4]
 800b970:	4605      	mov	r5, r0
 800b972:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
 800b976:	f8c4 0188 	str.w	r0, [r4, #392]	; 0x188
 800b97a:	f8c4 018c 	str.w	r0, [r4, #396]	; 0x18c
 800b97e:	b93f      	cbnz	r7, 800b990 <__register_exitproc+0x74>
 800b980:	1cab      	adds	r3, r5, #2
 800b982:	2000      	movs	r0, #0
 800b984:	3501      	adds	r5, #1
 800b986:	6065      	str	r5, [r4, #4]
 800b988:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
 800b98c:	b005      	add	sp, #20
 800b98e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b990:	eb04 0085 	add.w	r0, r4, r5, lsl #2
 800b994:	f04f 0c01 	mov.w	ip, #1
 800b998:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
 800b99c:	f8d4 6188 	ldr.w	r6, [r4, #392]	; 0x188
 800b9a0:	fa0c f205 	lsl.w	r2, ip, r5
 800b9a4:	4316      	orrs	r6, r2
 800b9a6:	2f02      	cmp	r7, #2
 800b9a8:	f8c4 6188 	str.w	r6, [r4, #392]	; 0x188
 800b9ac:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
 800b9b0:	bf02      	ittt	eq
 800b9b2:	f8d4 318c 	ldreq.w	r3, [r4, #396]	; 0x18c
 800b9b6:	431a      	orreq	r2, r3
 800b9b8:	f8c4 218c 	streq.w	r2, [r4, #396]	; 0x18c
 800b9bc:	e7e0      	b.n	800b980 <__register_exitproc+0x64>
 800b9be:	f506 74a6 	add.w	r4, r6, #332	; 0x14c
 800b9c2:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
 800b9c6:	e7b5      	b.n	800b934 <__register_exitproc+0x18>

0800b9c8 <register_fini>:
 800b9c8:	f240 0300 	movw	r3, #0
 800b9cc:	f2c0 0300 	movt	r3, #0
 800b9d0:	b12b      	cbz	r3, 800b9de <register_fini+0x16>
 800b9d2:	f64b 008d 	movw	r0, #47245	; 0xb88d
 800b9d6:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b9da:	f7ff bf51 	b.w	800b880 <atexit>
 800b9de:	4770      	bx	lr

0800b9e0 <_init>:
 800b9e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800b9e2:	bf00      	nop
 800b9e4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800b9e6:	bc08      	pop	{r3}
 800b9e8:	469e      	mov	lr, r3
 800b9ea:	4770      	bx	lr

0800b9ec <_fini>:
 800b9ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800b9ee:	bf00      	nop
 800b9f0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800b9f2:	bc08      	pop	{r3}
 800b9f4:	469e      	mov	lr, r3
 800b9f6:	4770      	bx	lr
